diff --git b/document/Makefile a/document/Makefile
index 2635a43..a432a92 100644
--- b/document/Makefile
+++ a/document/Makefile
@@ -4,8 +4,7 @@ BIBTEX = bibtex
 MAKEINDEX = makeindex
 SCHEME = scheme48 -a batch
 MZSCHEME = mzscheme
-# use the one from tex2page distro, *not* the one included with PLT Scheme
-TEX2PAGE = tex2page
+TEX2PAGE = ./tex2page
 
 report: thirdrun
 
@@ -69,8 +68,8 @@ r6rs.ind : r6rs.idx r6rs-lib.idx
 r6rs-lib.ind : r6rs-lib.idx
 	$(MAKEINDEX) -s r6rs.mst -c r6rs-lib.idx
 
-r6rs-app.ind : r6rs-app.idx
-	$(MAKEINDEX) -s r6rs.mst -c r6rs-app.idx
+# r6rs-app.ind : r6rs-app.idx
+# 	$(MAKEINDEX) -s r6rs.mst -c r6rs-app.idx
 
 r6rs-rationale.ind : r6rs-rationale.idx
 	$(MAKEINDEX) -s r6rs.mst -c r6rs-rationale.idx
@@ -85,7 +84,7 @@ r6rs.dvi : r6rs.bbl r6rs.ind r6-fig-grammar-parti.tex
 r6rs-lib.dvi : r6rs-lib.bbl r6rs-lib.ind
 	$(LATEX) r6rs-lib
 
-r6rs-app.dvi : r6rs-app.bbl r6rs-app.ind
+r6rs-app.dvi : r6rs-app.bbl
 	$(LATEX) r6rs-app
 
 r6rs-rationale.dvi : r6rs-rationale.bbl r6rs-rationale.ind
@@ -109,7 +108,7 @@ r6rs.pdf : r6rs.bbl r6rs.ind r6-fig-grammar-parti.tex
 r6rs-lib.pdf : r6rs-lib.bbl r6rs-lib.ind
 	$(LATEX) r6rs-lib
 
-r6rs-app.pdf : r6rs-app.bbl r6rs-app.ind
+r6rs-app.pdf : r6rs-app.bbl
 	$(LATEX) r6rs-app
 
 r6rs-rationale.pdf : r6rs-rationale.bbl r6rs-rationale.ind
@@ -119,7 +118,7 @@ endif
 r6rs-lib.idx r6rs-lib.aux : $(COMMON_TEX_FILES) $(LIB_TEX_FILES)
 	$(LATEX) r6rs-lib
 
-r6rs-app.idx r6rs-app.aux : $(COMMON_TEX_FILES) $(LIB_TEX_FILES)
+r6rs-app.aux : $(COMMON_TEX_FILES) $(LIB_TEX_FILES)
 	$(LATEX) r6rs-app
 
 r6rs-rationale.idx r6rs-rationale.aux : $(COMMON_TEX_FILES) $(RATIONALE_TEX_FILES)
diff --git b/document/arith.tex a/document/arith.tex
index d45480a..b8d1f58 100644
--- b/document/arith.tex
+++ a/document/arith.tex
@@ -113,11 +113,11 @@ With one argument, this procedure returns the additive
 inverse of its argument, provided that integer object is a
 fixnum.
 
-An exception with condition type {\cf\&assertion} is raised if the
+An exception with condition type {\cf\&implementation-restriction} is raised if the
 mathematically correct result of this procedure is not a fixnum.
 
 \begin{scheme}
-(fx- (least-fixnum))  \xev  \exception{\&assertion}%
+(fx- (least-fixnum))  \lev  \exception{\&implementation-restriction}%
 \end{scheme}
 \end{entry}
 
@@ -225,7 +225,7 @@ number of 1 bits in the two's complement representation of \var{fx}.
 Otherwise it returns the result of the following computation:
 %
 \begin{scheme}
-(fxnot (fxbit-count (fxnot \var{ei})))%
+(fxnot (fxbit-count (fxnot \var{fx})))%
 \end{scheme}
 \end{entry}
 
@@ -264,17 +264,18 @@ the two's complement representation of \var{fx}.  If
 \begin{entry}{%
 \proto{fxbit-set?}{ \vari{fx} \varii{fx}}{procedure}}
 
-\domain{\varii{Fx} must be non-negative and less than {\cf
-    (fixnum-width)}.}  The {\cf fxbit-set?} procedure returns
+\domain{\varii{Fx} must be non-negative.}  The {\cf fxbit-set?} procedure returns
 \schtrue{} if the \varii{fx}th bit is 1 in the two's complement
 representation of \vari{fx}, and \schfalse{} otherwise.  This is the
-fixnum result of the following computation:
+result of the following computation:
 %
 \begin{scheme}
-(not
-  (fxzero?
-    (fxand \vari{fx}
-           (fxarithmetic-shift-left 1 \varii{fx}))))%
+(if (fx>=? \varii{fx} (fx- (fixnum-width) 1))
+    (fxnegative? \vari{fx})
+    (not
+      (fxzero?
+         (fxand \vari{fx}
+                (fxarithmetic-shift-left 1 \varii{fx})))))%
 \end{scheme}
 %
 \end{entry}
@@ -283,7 +284,7 @@ fixnum result of the following computation:
 \proto{fxcopy-bit}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}
 
 \domain{\varii{Fx} must be non-negative and less than {\cf
-  (fixnum-width)}. \variii{Fx} must be 0 or
+  $w-1$}. \variii{Fx} must be 0 or
 1.}  The {\cf fxcopy-bit} procedure returns the result of replacing
 the \varii{fx}th bit of \vari{fx} by \variii{fx}, which is
 the result of the following computation:
@@ -300,7 +301,7 @@ the result of the following computation:
 \proto{fxbit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}
 
 \domain{\varii{Fx} and \variii{fx} must be non-negative and less than
-  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
+  $w$.  Moreover, \varii{fx} must be less than or
   equal to \variii{fx}.}  The {\cf fxbit-field} procedure returns the
 number represented by the bits at the positions from \varii{fx} (inclusive) to
 $\variii{fx}$ (exclusive), which is
@@ -319,10 +320,12 @@ the fixnum result of the following computation:
 \proto{fxcopy-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}
 
 \domain{\varii{Fx} and \variii{fx} must be non-negative and less than
-  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
+  $w$.  Moreover, \varii{fx} must be less than or
   equal to \variii{fx}.}  The {\cf fxcopy-bit-field} procedure returns
 the result of replacing in \vari{fx} the bits at positions from
-\varii{fx} (inclusive) to $\variii{fx}$ (exclusive) by the corresponding bits in \variv{fx}, which
+\varii{fx} (inclusive) to $\variii{fx}$ (exclusive) by the bits in
+\variv{fx} from position 0 (inclusive) to position
+$\variii{fx}-\varii{fx}$ (exclusive), which
 is the fixnum result of the following computation:
 \begin{scheme}
 (let* ((to    \vari{fx})
@@ -332,18 +335,27 @@ is the fixnum result of the following computation:
        (mask1 (fxarithmetic-shift-left -1 start))
        (mask2 (fxnot
                (fxarithmetic-shift-left -1 end)))
-       (mask (fxand mask1 mask2)))
+       (mask (fxand mask1 mask2))
+       (mask3 (fxnot (fxarithmetic-shift-left
+                       -1 (- end start)))))
   (fxif mask
-        (fxarithmetic-shift-left from start)
+        (fxarithmetic-shift-left (fxand from mask3)
+                                 start)
         to))%
 \end{scheme}
+
+\begin{scheme}
+(fxcopy-bit-field \sharpsign{}b0000001 2 5 \sharpsign{}b1111000) \lev 1
+(fxcopy-bit-field \sharpsign{}b0000001 2 5 \sharpsign{}b0001111) \lev 29
+(fxcopy-bit-field \sharpsign{}b0001111 2 5 \sharpsign{}b0001111) \lev 31%
+\end{scheme}
 \end{entry}
 
 \begin{entry}{%
 \proto{fxarithmetic-shift}{ \vari{fx} \varii{fx}}{procedure}}
 
 \domain{The absolute value of \varii{fx} must be less than 
-{\cf (fixnum-width)}.}  If
+$w$.}  If
 %
 \begin{scheme}
 (floor (* \vari{fx} (expt 2 \varii{fx})))%
@@ -358,8 +370,7 @@ raised.
 \proto{fxarithmetic-shift-left}{ \vari{fx} \varii{fx}}{procedure}
 \proto{fxarithmetic-shift-right}{ \vari{fx} \varii{fx}}{procedure}}
 
-\domain{\varii{Fx} must be non-negative, and less than {\cf
-    (fixnum-width)}.}
+\domain{\varii{Fx} must be non-negative, and less than $w$.}
   The {\cf fxarithmetic-shift-left} procedure behaves the same as {\cf
   fxarithmetic-shift}, and {\cf (fxarithmetic-shift-right \vari{fx}
   \varii{fx})} behaves the same as {\cf (fxarithmetic-shift \vari{fx}
@@ -370,8 +381,8 @@ raised.
 \proto{fxrotate-bit-field}{ \vari{fx} \varii{fx} \variii{fx} \variv{fx}}{procedure}}
 
 \domain{\varii{Fx}, \variii{fx}, and \variv{fx} must be non-negative
-  and less than {\cf (fixnum-width)}.  \varii{Fx} must be less than or
-  equal to \variii{fx}. \variv{Fx} must be less than the difference
+  and less than $w$.  \varii{Fx} must be less than or
+  equal to \variii{fx}. \variv{Fx} must be less than or equal to the difference
 between \variii{fx} and \varii{fx}.}  The {\cf fxrotate-bit-field}
 procedure returns the result of cyclically permuting in \vari{fx} the
 bits at positions from \varii{fx} (inclusive) to \variii{fx}
@@ -384,19 +395,14 @@ following computation:
        (end   \variii{fx})
        (count \variv{fx})
        (width (fx- end start)))
-  (if (fxpositive? width)
-      (let* ((count (fxmod count width))
-             (field0
-               (fxbit-field n start end))
-             (field1
-               (fxarithmetic-shift-left
-                 field0 count))
-             (field2
-               (fxarithmetic-shift-right
-                 field0 (fx- width count)))
-             (field (fxior field1 field2)))
-        (fxcopy-bit-field n start end field))
-      n))%
+  (fxcopy-bit-field n start end
+    (fxior
+      (fxarithmetic-shift-left
+        (fxbit-field n start (fx- end count))
+        count)
+      (fxarithmetic-shift-right
+        (fxbit-field n start end)
+        (fx- width count)))))%
 \end{scheme}
 
 \end{entry}
@@ -405,7 +411,7 @@ following computation:
 \proto{fxreverse-bit-field}{ \vari{fx} \varii{fx} \variii{fx}}{procedure}}
 
 \domain{\varii{Fx} and \variii{fx} must be non-negative and less than
-  {\cf (fixnum-width)}.  Moreover, \varii{fx} must be less than or
+  $w$.  Moreover, \varii{fx} must be less than or
   equal to \variii{fx}.}  The {\cf fxreverse-bit-field} procedure
 returns
 the fixnum obtained from \vari{fx} by reversing the
@@ -459,19 +465,19 @@ argument.
 \proto{fl>=?}{ \vari{fl} \varii{fl} \variii{fl} \dotsfoo}{procedure}}
 
 These procedures return \schtrue{} if their arguments are (respectively):
-equal, monotonically increasing, monotonically decreasing,
-monotonically nondecreasing, or monotonically nonincreasing,
+equal, monotonically increasing, monotonically nondecreasing,
+monotonically decreasing, or monotonically nonincreasing,
 \schfalse{} otherwise.  These
 predicates must be transitive.
 
 \begin{scheme}
-(fl= +inf.0 +inf.0)           \ev  \schtrue{}
-(fl= -inf.0 +inf.0)           \ev  \schfalse{}
-(fl= -inf.0 -inf.0)           \ev  \schtrue{}
-(fl= 0.0 -0.0)                \ev  \schtrue{}
-(fl< 0.0 -0.0)                \ev  \schfalse{}
-(fl= +nan.0 \var{fl})               \ev  \schfalse{}
-(fl< +nan.0 \var{fl})               \ev  \schfalse{}%
+(fl=? +inf.0 +inf.0)           \ev  \schtrue{}
+(fl=? -inf.0 +inf.0)           \ev  \schfalse{}
+(fl=? -inf.0 -inf.0)           \ev  \schtrue{}
+(fl=? 0.0 -0.0)                \ev  \schtrue{}
+(fl<? 0.0 -0.0)                \ev  \schfalse{}
+(fl=? +nan.0 \var{fl})               \ev  \schfalse{}
+(fl<? +nan.0 \var{fl})               \ev  \schfalse{}%
 \end{scheme}
 \end{entry}
 
@@ -509,7 +515,7 @@ than zero, {\cf flodd?} tests whether it is odd,
 \begin{note}
 {\cf (flnegative? -0.0)} must return \schfalse{},
 else it would lose the correspondence with
-{\cf (fl< -0.0 0.0)}, which is \schfalse{}
+{\cf (fl<? -0.0 0.0)}, which is \schfalse{}
 according to IEEE 754~\cite{IEEE}.
 \end{note}
 \end{entry}
@@ -584,8 +590,14 @@ Returns the absolute value of \var{fl}.
 
 These procedures implement number-theoretic integer division and
 return the results of the corresponding mathematical operations
-specified in report section~\extref{report:integerdivision}{Integer division}.  For zero divisors, these
-procedures may return a NaN or some unspecified flonum.
+specified in report section~\extref{report:integerdivision}{Integer division}.
+In the cases where the
+mathematical requirements in section~\extref{report:integerdivision} cannot be
+satisfied by any number object, either an exception is raised with
+condition type {\cf\&implementation-restriction}, or unspecified
+flonums (one for {\cf fldiv} {\cf flmod}, {\cf fldiv0} and {\cf
+  flmod0}, two for {\cf fldiv-and-mod} and {\cf fldiv0-and-mod0}) are
+returned.
 
 \begin{scheme}
 (fldiv \vari{fl} \varii{fl})         \ev \(\vari{fl}~\mathrm{div}~\varii{fl}\)
@@ -712,16 +724,19 @@ the result may be a NaN or some unspecified flonum.
   negative, \varii{fl} should be an integer object.}
 The {\cf flexpt} procedure returns \vari{fl} raised to the power \varii{fl}.  If \vari{fl} is
 negative and \varii{fl} is not an integer object, the result may be a
-NaN, or may be some unspecified flonum.  If \vari{fl} is zero, then
-the result is zero.
+NaN, or may be some unspecified flonum.
+If \vari{fl} and \varii{fl} are both zero, the result is
+1.0.  If \vari{fl} is zero and \varii{fl} is positive, the result is zero. 
+If \vari{fl} is zero and \varii{fl} is negative, the result may be a NaN, or may be
+some unspecified flonum.
 \end{entry}
 
 \begin{entry}{%
 \ctproto{no-infinities}
-\proto{make-no-infinities-violation}{ obj}{procedure}
+\proto{make-no-infinities-violation}{}{procedure}
 \proto{no-infinities-violation?}{ obj}{procedure}
 \ctproto{no-nans}
-\proto{make-no-nans-violation}{ obj}{procedure}
+\proto{make-no-nans-violation}{}{procedure}
 \proto{no-nans-violation?}{ obj}{procedure}}
 
 These condition types could be defined by the following code:
@@ -865,7 +880,7 @@ otherwise.  This is the result of the following computation:
 \domain{\varii{Ei} must be non-negative, and \variii{ei}
 must be either $0$ or $1$.}
 The {\cf bitwise-copy-bit} procedure returns the result of replacing
-the \varii{ei}th bit of \vari{ei} by the \varii{ei}th bit of \variii{ei}, which is
+the \varii{ei}th bit of \vari{ei} by \variii{ei}, which is
 the result of the following computation:
 \begin{scheme}
 (let* ((mask (bitwise-arithmetic-shift-left 1 \varii{ei})))
@@ -902,8 +917,10 @@ the result of the following computation:
 and \varii{ei} must be less than or equal to \variii{ei}.}
 The {\cf bitwise-copy-bit-field} procedure returns
 the result of replacing in \vari{ei} the bits at positions from
-\varii{ei} (inclusive) to $\variii{ei}$ (exclusive) by the corresponding bits in \variv{ei}, which
-is the fixnum result of the following computation:
+\varii{ei} (inclusive) to $\variii{ei}$ (exclusive) by the bits in
+\variv{ei} from position 0 (inclusive) to position
+$\variii{ei}-\varii{ei}$ (exclusive), which
+is the result of the following computation:
 %
 \begin{scheme}
 (let* ((to    \vari{ei})
@@ -964,9 +981,8 @@ returns the same result as
 \proto{bitwise-rotate-bit-field}{ \vari{ei} \varii{ei} \variii{ei} \variv{ei}}{procedure}}
 
 \domain{\varii{Ei}, \variii{ei}, \variv{ei} must be non-negative, 
-\varii{ei} must be less than or equal to \variii{ei}, and
-\variv{ei} must be non-negative.}
-procedure returns the result of cyclically permuting in \vari{ei} the
+\varii{ei} must be less than or equal to \variii{ei}.}
+The {\cf bitwise-rotate-bit-field} procedure returns the result of cyclically permuting in \vari{ei} the
 bits at positions from \varii{ei} (inclusive) to \variii{ei} (exclusive) by \variv{ei} bits
 towards the more significant bits, which is the result of the
 following computation:
diff --git b/document/base.tex a/document/base.tex
index 2ff892b..7917cc0 100644
--- b/document/base.tex
+++ a/document/base.tex
@@ -135,9 +135,6 @@ All bindings established by a set of definitions, whether
 keyword or variable definitions, are visible within the definitions
 themselves.
 
-\implresp The implementation should detect if the value of
-\hyper{expression} cannot possibly be a transformer.
-
 Example:
 
 \begin{scheme}
@@ -151,6 +148,9 @@ Example:
   (even? 10))                       \ev \schtrue{}%
 \end{scheme}
 
+\implresp The implementation should detect if the value of
+\hyper{expression} cannot possibly be a transformer.
+
 An implication of the left-to-right processing order
 (section~\ref{expansionchapter}) is that one definition can
 affect whether a subsequent form is also a definition.  
@@ -294,7 +294,7 @@ The results of the last expression in the body are returned as
 the results of the procedure call.
 
 \begin{scheme}
-(lambda (x) (+ x x))      \ev  {\em{}a procedure}
+(lambda (x) (+ x x))      \ev  \textnormal{\textit{a procedure}}
 ((lambda (x) (+ x x)) 4)  \ev  8
 
 ((lambda (x)
@@ -523,7 +523,7 @@ otherwise the {\cf case} expression returns \unspecifiedreturn.
 \begin{scheme}
 (case (* 2 3)
   ((2 3 5 7) 'prime)
-  ((1 4 6 8 9) 'composite))     \ev  composite
+  ((4 6 8 9) 'composite))     \ev  composite
 (case (car '(c d))
   ((a) 'a)
   ((b) 'b))                     \ev  \theunspecified
@@ -956,7 +956,7 @@ context:
 
 (begin (display "4 plus 1 equals ")
        (display (+ 4 1)))      \ev  \unspecified
- \>{\em and prints}  4 plus 1 equals 5%
+ \>\textnormal{\textit{and prints}}  4 plus 1 equals 5%
 \end{scheme}
 \end{entry}
 
@@ -1002,7 +1002,8 @@ The {\cf eqv?} procedure returns \schtrue{} if one of the following holds:
   yield the same results (in the sense of {\cf eqv?}) when passed
   as arguments to any other procedure that can be defined
   as a finite composition of Scheme's standard arithmetic
-  procedures.
+  procedures, as long as the evaluation of that application does not
+  involve NaN.
 
 \item \vari{Obj} and \varii{obj} are both characters and are the same
 character according to the {\cf char=?} procedure
@@ -1012,7 +1013,7 @@ character according to the {\cf char=?} procedure
 
 \item \vari{Obj} and \varii{obj} are objects such as pairs, vectors, bytevectors
   (library chapter~\extref{lib:bytevectorschapter}{Bytevectors}),
-  strings, hashtables, records (library
+  strings, records (library
   chapter~\extref{lib:recordschapter}{Records}), ports (library
   section~\extref{lib:portsiosection}{Port I/O}), or hashtables
   (library chapter~\extref{lib:hashtablechapter}{Hash tables}) that
@@ -1044,7 +1045,8 @@ The {\cf eqv?} procedure returns \schfalse{} if one of the following holds:
 \item \vari{Obj} and \varii{obj} yield different results (in the sense of
   {\cf eqv?}) when passed as arguments to any other procedure
   that can be defined as a finite composition of Scheme's
-  standard arithmetic procedures.
+  standard arithmetic procedures, as long as the evaluation of that
+  application does not involve NaN.
 
 \item \vari{Obj} and \varii{obj} are characters for which the {\cf char=?}
   procedure returns \schfalse{}.
@@ -1105,7 +1107,7 @@ boolean.
       (lambda (x) x))    \ev  \unspecified
 (eqv? (lambda (x) x)
       (lambda (y) y))    \ev  \unspecified
-(eqv? +nan.0 +nan.0)             \ev \unspecified%
+(eqv? +nan.0 +nan.0)             \ev  \unspecified%
 \end{scheme}
 
 The next set of examples shows the use of {\cf eqv?}\ with procedures
@@ -1144,9 +1146,6 @@ not detect this equivalence.
 
 Implementations may
 share structure between constants where appropriate.
-Furthermore, a constant may be copied at any time by the implementation so
-as to exist simultaneously in different sets of locations, as noted in
-section~\ref{quote}.
 Thus the value of {\cf eqv?} on constants is sometimes
 implementation-dependent.
 
@@ -1185,7 +1184,7 @@ from {\cf eqv?} on empty vectors, empty bytevectors, and empty strings.
 (eq? '() '())                   \ev  \schtrue
 (eq? 2 2)                       \ev  \unspecified
 (eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
-(eq? car car)                   \ev  \schtrue
+(eq? car car)                   \ev  \unspecified
 (let ((n (+ 2 3)))
   (eq? n n))      \ev  \unspecified
 (let ((x '(a)))
@@ -1628,7 +1627,7 @@ inexact number objects of the appropriate type have bounded precision, then
 the value returned is an inexact number object that is nearest to the
 argument.  If an exact argument has no reasonably close inexact
 equivalent, an exception with condition type
-{\cf\&implementation-violation} may be
+{\cf\&implementation-restriction} may be
 raised.
 
 \begin{note}
@@ -1644,7 +1643,7 @@ returned is the exact number object that is numerically closest to the
 argument; in most cases, the result of this procedure should be
 numerically equal to its argument.  If an inexact argument has no
 reasonably close exact equivalent, an exception with condition type
-{\cf\&implementation-violation} may be
+{\cf\&implementation-restriction} may be
 raised.
 
 These procedures implement the natural one-to-one correspondence
@@ -1677,8 +1676,8 @@ nonincreasing, and \schfalse{} otherwise.
 For any real number object \var{x} that is neither infinite nor NaN:
 
 \begin{scheme}
-(< -inf.0 \var{x} +inf.0))        \ev  \schtrue{}
-(> +inf.0 \var{x} -inf.0))        \ev  \schtrue{}%
+(< -inf.0 \var{x} +inf.0)        \ev  \schtrue{}
+(> +inf.0 \var{x} -inf.0)        \ev  \schtrue{}%
 \end{scheme}
 
 For any number object \var{z}:
@@ -1762,7 +1761,7 @@ These procedures return the maximum or minimum of their arguments.
 (max 3.9 4)                            \ev  4.0%
 \end{scheme}
 
-For any real number object \var{x}:
+For any real number object \var{x} that is not a NaN:
 
 \begin{scheme}
 (max +inf.0 \var{x})                         \ev  +inf.0
@@ -1842,7 +1841,7 @@ consistent with the following examples:
 
 \begin{entry}{%
 \proto{-}{ z}{procedure}
-\rproto{-}{ \vari{z} \varii{z} \dotsfoo}{procedure}}
+\rproto{-}{ \vari{z} \varii{z} \variii{z} \dotsfoo}{procedure}}
 
 With two or more arguments, this procedures returns the difference of
 its arguments, associating to the left.  With one argument, however,
@@ -1875,7 +1874,7 @@ consistent with the following examples:
 
 \begin{entry}{%
 \proto{/}{ z}{procedure}
-\rproto{/}{ \vari{z} \varii{z} \dotsfoo}{procedure}}
+\rproto{/}{ \vari{z} \varii{z} \variii{z} \dotsfoo}{procedure}}
 
 \domain{If all of the arguments are exact, then the divisors must all
   be nonzero.}
@@ -1927,9 +1926,14 @@ Returns the absolute value of its argument.
 
 These procedures implement number-theoretic integer division and
 return the results of the corresponding mathematical operations
-specified in section~\ref{integerdivision}.  In each case, \vari{x}
-must be neither infinite nor a NaN, and \varii{x} must be nonzero;
-otherwise, an exception with condition type {\cf\&assertion} is raised.
+specified in section~\ref{integerdivision}.  If \vari{x} and \varii{x}
+are exact, \varii{x} must be nonzero.  In the cases where the
+mathematical requirements in section~\ref{integerdivision} cannot be
+satisfied by any number object, either an exception is raised with
+condition type {\cf\&implementation-restriction}, or unspecified
+number objects (one for {\cf div} {\cf mod}, {\cf div0} and {\cf
+  mod0}, two for {\cf div-and-mod} and {\cf div0-and-mod0}) are
+returned.
 
 \begin{scheme}
 (div \vari{x} \varii{x})         \ev \(\vari{x}~\mathrm{div}~\varii{x}\)
@@ -1937,7 +1941,7 @@ otherwise, an exception with condition type {\cf\&assertion} is raised.
 (div-and-mod \vari{x} \varii{x})     \ev \(\vari{x}~\mathrm{div}~\varii{x}, \vari{x}~\mathrm{mod}~\varii{x}\)\\\>\>\>; \textrm{two return values}
 (div0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{div}_0~\varii{x}\)
 (mod0 \vari{x} \varii{x})        \ev \(\vari{x}~\mathrm{mod}_0~\varii{x}\)
-(div0-and-mod0 \vari{x} \varii{x})   \lev \(\vari{x}~\mathrm{div}_0~\varii{x}, \vari{x}~\mathrm{mod}_0~\varii{x}\)\\\>\>; \textrm{two return values}%
+(div0-and-mod0 \vari{x} \varii{x})   \lev \(\vari{x}~\mathrm{div}_0~\varii{x}, \vari{x}~\mathrm{mod}_0~\varii{x}\)\\\>\>\>; \textrm{two return values}%
 \end{scheme}
 
 \begin{entry}{%
@@ -2024,7 +2028,7 @@ given a NaN.
 \begin{entry}{%
 \proto{rationalize}{ \vari{x} \varii{x}}{procedure}}
 
-The {\cf rationalize} procedure returns the a number object
+The {\cf rationalize} procedure returns a number object
 representing the {\em simplest} rational
 number differing from \vari{x} by no more than \varii{x}.    A rational number $r_1$ is
 {\em simpler} \mainindex{simplest rational} than another rational number
@@ -2145,7 +2149,7 @@ values of \vari{z} and \varii{z}, {\cf (expt \vari{z}
 (expt 5 -3)                 \ev  1/125
 (expt 5 0)                  \ev  1
 (expt 0 5)                  \ev  0
-(expt 0 5+.0000312i)        \ev  0
+(expt 0 5+.0000312i)        \ev  0.0
 (expt 0 -5)                 \ev  \unspecified
 (expt 0 -5+.0000312i)       \ev  \unspecified
 (expt 0 0)                  \ev  1
@@ -2186,7 +2190,7 @@ returns $a_3$, and {\cf (angle \var{z})} returns $a_4$.
 
 \begin{scheme}
 (real-part 1.1+2.2i)              \ev 1.1 ; \textrm{approximately}
-(imag-part 1.1+2.2i)              \ev 2.2i ; \textrm{approximately}
+(imag-part 1.1+2.2i)              \ev 2.2 ; \textrm{approximately}
 (magnitude 1.1@2.2)              \ev 1.1 ; \textrm{approximately}
 (angle 1.1@2.2)                  \ev 2.2 ; \textrm{approximately}
 
@@ -2273,7 +2277,9 @@ Returns a number object with maximally precise representation expressed by the
 given \var{string}.  \var{Radix} must be an exact integer object, either 2, 8, 10,
 or 16.  If supplied, \var{radix} is a default radix that may be overridden
 by an explicit radix prefix in \var{string} (e.g., {\tt "\#o177"}).  If \var{radix}
-is not supplied, then the default radix is 10.  If \var{string} is not
+is not supplied, then the default radix is 10.  If
+the arguments are as specified,
+ \var{string} is not
 a syntactically valid notation for a number object or a notation for a
 rational number object with a zero denominator, then {\cf string->number}
 returns \schfalse{}.
@@ -2289,8 +2295,9 @@ returns \schfalse{}.
 \end{scheme}
 
 \begin{note}
-  The {\cf string->number} procedure always returns a number object or
-  \schfalse{}; it never raises an exception.
+  If the arguments to {\cf string->number} are a string and a valid
+  radix as specified, it must produce a number object or \schfalse{};
+  it may not raise an exception.
 \end{note}
 \end{entry}
 
@@ -2495,7 +2502,7 @@ twenty-eight of these procedures in all.
 \proto{null?}{ obj}{procedure}}
 
 Returns \schtrue{} if \var{obj} is the empty list\index{empty list},
-\schfalse otherwise.
+\schfalse{} otherwise.
 
 \end{entry}
 
@@ -2540,24 +2547,28 @@ Returns the length of \var{list}.
 
 
 \begin{entry}{%
-\proto{append}{ list \dotsfoo{} obj}{procedure}}
+\proto{append}{ list \dotsfoo{} obj}{procedure}
+\rproto{append}{}{procedure}}
 
 Returns a possibly improper list consisting of the elements of the first \var{list}
 followed by the elements of the other \var{list}s, with \var{obj} as
 the cdr of the final pair.
 An improper list results if \var{obj} is not a
-list.
+list.  The {\cf append} procedure returns the empty list if called
+with no arguments.
 
 \begin{scheme}
 (append '(x) '(y))              \ev  (x y)
 (append '(a) '(b c d))          \ev  (a b c d)
 (append '(a (b)) '((c)))        \ev  (a (b) (c))
 (append '(a b) '(c . d))        \ev  (a b c . d)
-(append '() 'a)                 \ev  a%
+(append '() 'a)                 \ev  a
+(append)                        \ev  ()
+(append 'a)                     \ev a%
 \end{scheme}
 
-If {\cf append} constructs a nonempty chain of pairs, it is always
-newly allocated.  If no pairs are allocated, \var{obj} is returned.
+The return value is made from new pairs for all arguments but the
+last; the last is merely placed at the end of the new structure.
 \end{entry}
 
 
@@ -2595,7 +2606,7 @@ of pairs beyond this length.
 \proto{list-ref}{ list k}{procedure}}
 
 \domain{\var{List} must be a list whose length is at least $\var{k}+1$.}
-The {\cf list-tail} procedure returns the \var{k}th element of \var{list}.
+The {\cf list-ref} procedure returns the \var{k}th element of \var{list}.
 
 \begin{scheme}
 (list-ref '(a b c d) 2)                 \ev c%
@@ -2762,8 +2773,9 @@ Returns the symbol whose name is \var{string}.
 
 \mainindex{Unicode}
 \mainindex{scalar value}
+\mainindex{character}
 
-\defining{Characters} are objects that represent Unicode scalar
+\textit{Characters} are objects that represent Unicode scalar
 values~\cite{Unicode}.
 
 \begin{note}
@@ -3584,8 +3596,8 @@ As noted in section~\ref{abbreviationsection},
           \lev  (a 3 4 5 6 b)
 `(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
           \lev  ((foo 7) . cons)
-`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
-          \lev  \#(10 5 2 4 3 8)
+`\#(10 5 ,(- 4) ,@(map - '(16 9)) 8) %
+          \lev  \#(10 5 -4 -16 -9 8)
 (let ((name 'foo))
   `((unquote name name name)))%
           \lev (foo foo foo)
@@ -3597,7 +3609,7 @@ As noted in section~\ref{abbreviationsection},
                  (unquote (append x y) (sqrt 9)))
 (let ((x '(2 3))
       (y '(4 5)))
-  `(foo (unquote (append x y) (sqrt 9)))) \lev (foo (2 3 4 5) 3)%
+  `(foo (unquote (append x y) (- 9)))) \lev (foo (2 3 4 5) -9)%
 \end{scheme}
 
 Quasiquote forms may be nested.  Substitutions are made only for
@@ -3965,7 +3977,7 @@ $P_n$.
 \item $P$ is of the form
 {\cf \#($P_1$ \dotsfoo{} $P_k$ $P_e$ \hyper{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)},
 where \hyper{ellipsis} is the identifier {\cf ...}
-and $F$ is a vector of $n$ or more elements
+and $F$ is a vector of $n$ elements
 whose first $k$ elements match $P_1$ through $P_k$,
 whose next $m-k$ elements each match $P_e$,
 and
@@ -4092,7 +4104,7 @@ replaced by \hyperii{template}.
     ((set! \_ e) (set-car! p e))))
 (set! p.car 15)
 p.car           \ev 15
-p               \ev (15 5)%
+p               \ev (15 . 5)%
 \end{scheme}
 
 \end{entry}
diff --git b/document/basic.tex a/document/basic.tex
index 8f77d60..4fc8805 100644
--- b/document/basic.tex
+++ a/document/basic.tex
@@ -218,8 +218,7 @@ variables exported by a library; see
 section~\ref{importsareimmutablesection}) is also
 considered a syntax violation.
 
-If a top-level or library form in a program is not syntactically
-correct, then the implementation must raise an exception with
+If a syntax violation occurs, the implementation must raise an exception with
 condition type {\cf\&syntax}, and execution of that top-level program
 or library must not be allowed to begin.
 
@@ -313,7 +312,11 @@ An object fetched from a location, by a variable reference or by
 a procedure such as {\cf car}, {\cf vector-ref}, or {\cf string-ref}, is
 equivalent in the sense of \ide{eqv?} % and \ide{eq?} ??
 (section~\ref{equivalencesection})
-to the object last stored in the location before the fetch.
+to the object last stored in the location before the fetch, except
+when that object is a procedure.  When the object is a procedure, the
+object fetched from the location will also be a procedure that behaves
+identically to the procedure last stored in the location, but it is
+possible that it is not the same object.
 
 Every location is marked to show whether it is in use.
 No variable or object ever refers to a location that is not in use.
@@ -335,7 +338,6 @@ procedures listed in this report are mutable.  An attempt to store a
 new value into a location referred to by an immutable object
 should raise an exception with condition type {\cf\&assertion}.
 
-
 \section{Proper tail recursion}
 \label{proper tail recursion}
 
diff --git b/document/bytevector.tex a/document/bytevector.tex
index b83c566..55e1b3e 100644
--- b/document/bytevector.tex
+++ a/document/bytevector.tex
@@ -132,7 +132,7 @@ It returns \schfalse{} otherwise.
 \end{entry}
 
 \begin{entry}{%
-\proto{bytevector-fill!}{ bytevector fill}}
+\proto{bytevector-fill!}{ bytevector fill}{procedure}}
 
 \domain{The \var{fill} argument is as in the description of the {\cf
     make-bytevector} procedure.}
@@ -163,7 +163,7 @@ and returns \unspecifiedreturn.  Analogous to {\cf vector-fill!}.
    
   The {\cf bytevector-copy!} procedure copies the bytes from \var{source} at indices 
   \begin{displaymath}
-     \var{source-start}, \ldots \var{source-start} + \var{k} - 1
+     \var{source-start}, \ldots, \var{source-start} + \var{k} - 1
   \end{displaymath}
   to consecutive indices in \var{target} starting at \var{target-index}.
    
@@ -324,8 +324,8 @@ The \ldots{\cf -set!} procedures return \unspecifiedreturn.
   integer objects in the interval $\{0, \ldots, 256^{\mathit{size}}-1\}$.  For
   {\cf sint-list->bytevector}, \var{list} must be a list of exact
   integer objects in the interval $\{-256^{\mathit{size}}/2, \ldots,
-  256^{\mathit{size}}/2-1\}$.  The length of \var{bytevector} or,
-  respectively, of \var{list} must be divisible by \var{size}.}
+  256^{\mathit{size}}/2-1\}$.  The length of \var{bytevector} 
+  must be divisible by \var{size}.}
    
 These procedures convert between lists of integer objects and their consecutive
 representations according to \var{size} and \var{endianness} in the
@@ -412,7 +412,7 @@ The \ldots{\cf -set!} procedures return \unspecifiedreturn.
   object in
   the interval $\{0, \ldots, 2^{32}-1\}$.  For {\cf bytevector-s32-set!}
   and {\cf bytevector-s32-native-set!}, \var{n} must be an exact
-  integer object in the interval $\{-2^{31}, \ldots, 2^{32}-1\}$.}
+  integer object in the interval $\{-2^{31}, \ldots, 2^{31}-1\}$.}
    
 These retrieve and set four-byte representations of numbers at indices $\var{k},
 \ldots, \var{k}+ 3$, according to the endianness specified by \var{endianness}. The
@@ -456,7 +456,7 @@ The \ldots{\cf{}-set!} procedures return \unspecifiedreturn.
   object in
   the interval $\{0, \ldots, 2^{64}-1\}$.  For {\cf bytevector-s64-set!}
   and {\cf bytevector-s64-native-set!}, \var{n} must be an exact
-  integer object in the interval $\{-2^{63}, \ldots, 2^{64}-1\}$.}
+  integer object in the interval $\{-2^{63}, \ldots, 2^{63}-1\}$.}
    
 These retrieve and set eight-byte representations of numbers at
 indices $\var{k}, \ldots, \var{k}+ 7$, according to the endianness
@@ -597,13 +597,14 @@ sequence is encoded by the given bytevector.
 \proto{utf16->string}{ bytevector endianness}{procedure}
 \pproto{(utf16->string \var{bytevector}}{procedure}}
 {\tt\obeyspaces\\
-    \var{endianness} \var{endianness-mandatory})}
+    \var{endianness} \var{endianness-mandatory?})}
 
 \domain{\var{Endianness} must be the symbol {\cf big} or
   the symbol {\cf little}.} The {\cf utf16->string} procedure returns
 a newly allocated (unless empty) string whose character sequence is
-encoded by the given bytevector.  \var{Bytevector} is decoded
-according to UTF-16BE or UTF-16LE: If \var{endianness-mandatory?} is
+encoded by the given bytevector.  \var{Bytevector} is decoded according
+to UTF-16, UTF-16BE, UTF-16LE, or a fourth encoding scheme that differs from
+all three of those as follows: If \var{endianness-mandatory?} is
 absent or \schfalse, {\cf utf16->string} determines the endianness
 according to a UTF-16 BOM at the beginning of \var{bytevector} if a
 BOM is present; in this case, the BOM is not decoded as a character.
@@ -624,13 +625,14 @@ encoding is decoded as a regular character.
 \proto{utf32->string}{ bytevector endianness}{procedure}
 \pproto{(utf32->string \var{bytevector}}{procedure}}
 {\tt\obeyspaces\\
-    \var{endianness} \var{endianness-mandatory})}
+    \var{endianness} \var{endianness-mandatory?})}
 
 \domain{\var{Endianness} must be the symbol {\cf big} or
   the symbol {\cf little}.} The {\cf utf32->string} procedure returns
 a newly allocated (unless empty) string whose character sequence is
-encoded by the given bytevector.  \var{Bytevector} is decoded
-according to UTF-32BE or UTF-32LE: If \var{endianness-mandatory?} is
+encoded by the given bytevector.  \var{Bytevector} is decoded according
+to UTF-32, UTF-32BE, UTF-32LE, or a fourth encoding scheme that differs from
+all three of those as follows: If \var{endianness-mandatory?} is
 absent or \schfalse, {\cf utf32->string} determines the endianness
 according to a UTF-32 BOM at the beginning of \var{bytevector} if a
 BOM is present; in this case, the BOM is not decoded as a character.
diff --git b/document/commands.tex a/document/commands.tex
index 6784eab..4df9f8a 100644
--- b/document/commands.tex
+++ a/document/commands.tex
@@ -9,12 +9,15 @@
 
 \usepackage{makeidx}
 \usepackage{hyperref}
+\usepackage{breakurl}
 
 % \let\htmlonly=\iffalse
 % \let\endhtmlonly=\fi
 % \let\texonly=\iftrue
 % \let\endtexonly=\fi
 
+\usepackage{cancel}
+
 \makeatletter
 
 \texonly
diff --git b/document/convio.tex a/document/convio.tex
index ecef355..c370c7d 100644
--- b/document/convio.tex
+++ a/document/convio.tex
@@ -14,7 +14,7 @@ associated implementation-dependent transcoders.
 \rproto{eof-object?}{ obj}{procedure}}
 
 These are the same as {\cf eof-object} and {\cf eof-object?} from the
-\rsixlibrary{ports} library.\schindex{eof-object}\schindex{eof-object?}
+\rsixlibrary{io ports} library.\schindex{eof-object}\schindex{eof-object?}
 \end{entry}
 
 \begin{entry}{%
diff --git b/document/enum.tex a/document/enum.tex
index 7b63527..7f1daf8 100644
--- b/document/enum.tex
+++ a/document/enum.tex
@@ -46,7 +46,7 @@ the universe of its argument, as an enumeration set.
 Returns a unary procedure that, given a symbol
 that is in the universe of \var{enum-set}, returns its 0-origin index
 within the canonical ordering of the symbols in the universe; given a
-value not in the universe, the unary procedure returns \schfalse.
+symbol not in the universe, the unary procedure returns \schfalse.
 
 \begin{scheme}
 (let* ((e (make-enumeration '(red green blue)))
@@ -179,7 +179,8 @@ Projects \vari{enum-set} into the universe
 of \varii{enum-set}, dropping any elements of \vari{enum-set} that do
 not belong to the universe of \varii{enum-set}.  (If \vari{enum-set}
 is a subset of the universe of its second, no elements are
-dropped, and the injection is returned.)
+dropped, and the injection is returned.)  The result has the enumeration type of
+\varii{enum-set}.
 
 \begin{scheme}
 (let ((e1 (make-enumeration
@@ -187,7 +188,7 @@ dropped, and the injection is returned.)
       (e2 (make-enumeration
             '(red black white))))
   (enum-set->list
-    (enum-set-projection e1 e2))))
+    (enum-set-projection e1 e2)))
 \ev (red black)
 \end{scheme}
 \end{entry}
diff --git b/document/eval.tex a/document/eval.tex
index 68c13ab..0d841fb 100644
--- b/document/eval.tex
+++ a/document/eval.tex
@@ -1,7 +1,7 @@
 \chapter{\tt{eval}}
 \label{evalchapter}
 
-The \rsixlibrary{eval} library allows a program to create Scheme
+The \defrsixlibrary{eval} library allows a program to create Scheme
 expressions as data at run time and evaluate them.
 
 \begin{entry}{%
@@ -34,25 +34,27 @@ The bindings of the environment represented by the specifier are
 immutable: If {\cf eval} is applied to an expression that is
 determined to contain an
 assignment to one of the variables of the environment, then {\cf eval} must
-raise an exception with a condition type {\cf\&assertion}.
+raise an exception with a condition type {\cf\&syntax}.
 
 \begin{scheme}
 (library (foo)
   (export)
-  (import (rnrs))
+  (import (rnrs)
+          (rnrs eval))
   (write
     (eval '(let ((x 3)) x)
           (environment '(rnrs))))) \\\> {\it writes} 3
 
 (library (foo)
   (export)
-  (import (rnrs))
+  (import (rnrs)
+          (rnrs eval))
   (write
     (eval
       '(eval:car (eval:cons 2 4))
       (environment
         '(prefix (only (rnrs) car cdr cons null?)
-                 eval:))))) \\\> {\it writes} 2
+                 eval:))))) \\\> {\it writes} 2%
 \end{scheme}
 \end{entry}
 
diff --git b/document/example.tex a/document/example.tex
index d076ed8..fd74cf8 100644
--- b/document/example.tex
+++ a/document/example.tex
@@ -149,7 +149,9 @@ which models a damped oscillator.
                  (newline)
                  (write (head s))
                  (loop (tail s)))))
-  (loop the-states))%
+  (loop the-states))
+
+(close-output-port (current-output-port))%
 \end{schemenoindent}
 
 This prints output like the following:
diff --git b/document/exc.tex a/document/exc.tex
index 893bc13..5544540 100644
--- b/document/exc.tex
+++ a/document/exc.tex
@@ -2,7 +2,7 @@
 \label{exceptionsconditionschapter}
 
 Scheme allows programs to deal with exceptional situations using two
-cooperating facilities: The exception system for raising and handling
+cooperating facilities: the exception system for raising and handling
 exceptional situations, and the condition system for describing these
 situations.
 
@@ -54,13 +54,15 @@ raised the exception, not as a crash.
 \proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}
 
 \domain{\var{Handler} must be a procedure and should accept one argument.
-\var{Thunk} must be a procedure that accepts zero arguments.}  The {\cf
+\var{Thunk} must be a procedure and should accept zero arguments.}  The {\cf
 with-exception-handler} procedure returns the results of invoking
-\var{thunk}.  \var{Handler} is installed as the current
+\var{thunk} without arguments.  \var{Handler} is installed as the current
 exception handler for the dynamic extent (as determined by {\cf
   dynamic-wind}) of the invocation of \var{thunk}.
 
 \implresp The implementation must check the restrictions on
+\var{thunk} to the extent performed by applying it as described above.
+The implementation must check the restrictions on
 \var{handler} to the extent performed by applying it as described
 when it is called as a result of a call to {\cf raise} or {\cf
   raise-continuable}.
@@ -81,7 +83,7 @@ before applying it.
 \syntax
 Each \hyper{cond clause} is as in the specification of {\cf cond}.
 (See report section~\extref{report:cond}{Derived conditionals}.)
-{\cf \=>} and {\cf else} are the same as in the \rsixlibrary{base} library.
+{\cf =>} and {\cf else} are the same as in the \rsixlibrary{base} library.
 
 \semantics 
 Evaluating a {\cf guard} form evaluates \hyper{body} with an exception
@@ -91,11 +93,11 @@ that binding evaluates the clauses as if they were the clauses of a
 continuation and dynamic environment of the {\cf guard} expression. If every
 \hyper{cond clause}'s \hyper{test} evaluates to \schfalse{} and there
 is no {\cf else} clause, then
-{\cf raise} is re-invoked on the raised object within the dynamic
+{\cf raise-continuable} is invoked on the raised object within the dynamic
 environment of the original call to {\cf raise} except that the current
 exception handler is that of the {\cf guard} expression.  
 
-The final expression in a \hyper{cond} clause is in a tail context if
+The final expression in a \hyper{cond clause} is in a tail context if
 the {\cf guard} expression itself is.
 \end{entry}
 
@@ -153,7 +155,7 @@ returns become the values returned by the call to
           'error))
   (raise
     (condition
-      (make-violation
+      (make-violation)
       (make-message-condition "I am an error"))))
   \ev \exception{\&violation}
 
@@ -331,8 +333,8 @@ of applying \var{proc} to that component.
 (cond1? (condition foo)) \ev \schtrue
 (real-cond1? (condition foo)) \lev \unspecified
 (real-cond1? (condition foo bar)) \lev \schfalse
-(cond1-x (condition foo bar) \lev foo
-(cond2-y (condition foo bar) \lev bar
+(cond1-x (condition foo bar)) \lev foo
+(cond2-y (condition foo bar)) \lev bar
  
 (equal? (simple-conditions (condition foo bar))
         (list foo bar)) \ev \schtrue
@@ -350,7 +352,7 @@ of applying \var{proc} to that component.
   \hyperi{field-spec} \dotsfoo)}
 \mainschindex{define-condition-type}
 
-\syntax \hyper{Condition-type}, \hyper{supertypes},
+\syntax \hyper{Condition-type}, \hyper{supertype},
 \hyper{constructor}, and \hyper{predicate} must all be identifiers.
 Each \hyper{field-spec} must be of the form
 %
diff --git b/document/hashtable.tex a/document/hashtable.tex
index 7db688a..5d8dfeb 100644
--- b/document/hashtable.tex
+++ a/document/hashtable.tex
@@ -91,9 +91,9 @@ hash function more than once.
 \section{Procedures}
 
 \begin{entry}{%
-\proto{hashtable?}{ \var{hashtable}}{procedure}}
+\proto{hashtable?}{ \var{obj}}{procedure}}
 
-Returns \schtrue{} if \var{hashtable} is a hashtable,
+Returns \schtrue{} if \var{obj} is a hashtable,
 \schfalse{} otherwise.
 \end{entry}
 
@@ -190,7 +190,8 @@ vector of the corresponding values.
   (hashtable-set! h 1 'one)
   (hashtable-set! h 2 'two)
   (hashtable-set! h 3 'three)
-  (hashtable-entries h)) \lev \sharpsign(1 2 3) \sharpsign(one two three)\\\>; \textrm{two return values}%
+  (hashtable-entries h)) \lev \sharpsign(1 2 3) \sharpsign(one two three)\\\>; \textrm{two return values}
+\>; \textrm{entries may be in different order}%
 \end{scheme}
 \end{entry}
 
diff --git b/document/intro.tex a/document/intro.tex
index b486b7e..8027f5a 100644
--- b/document/intro.tex
+++ a/document/intro.tex
@@ -116,7 +116,9 @@ thank Alan Bawden, John Cowan, Sebastian Egner, Aubrey Jaffer, Shiro
 Kawai, Bradley Lucier, and Andr\'e van Tonder for contributing insights on
 language design.  Marc Feeley, Martin Gasbichler, Aubrey Jaffer, Lars T Hansen,
 Richard Kelsey, Olin Shivers, and Andr\'e van Tonder wrote SRFIs that
-served as direct input to the report.  Marcus Crestani, David Frese, 
+served as direct input to the report.  
+Casey Klein found and fixed several bugs in the formal semantics.
+Marcus Crestani, David Frese, 
 Aziz Ghuloum, Arthur A.\ Gleckler, Eric Knauel, Jonathan Rees, and Andr\'e
 van Tonder thoroughly proofread early versions of the report.
 
diff --git b/document/iocond.tex a/document/iocond.tex
index 1c8154b..f34cbd7 100644
--- b/document/iocond.tex
+++ a/document/iocond.tex
@@ -167,7 +167,7 @@ non-existent named file under the assumption that it existed.
 
 \begin{entry}{%
 \ctproto{i/o-port}
-\proto{make-i/o-port-error}{ port}{procedure}
+\proto{make-i/o-port-error}{ pobj}{procedure}
 \proto{i/o-port-error?}{ obj}{procedure}
 \proto{i/o-error-port}{ condition}{procedure}}
 
@@ -176,12 +176,12 @@ This condition type could be defined by
 \begin{scheme}
 (define-condition-type \&i/o-port \&i/o
   make-i/o-port-error i/o-port-error?
-  (port i/o-error-port))%
+  (pobj i/o-error-port))%
 \end{scheme}
 
 This condition type specifies the port with which an I/O
 error is associated. 
-\var{Port} should be the port.
+\var{Pobj} should be the port.
 Conditions raised by procedures accepting a port as an argument should
 include an {\cf\&i/o-port-error} condition.
 \end{entry}
diff --git b/document/lex.tex a/document/lex.tex
index 1418be8..3327e9a 100644
--- b/document/lex.tex
+++ a/document/lex.tex
@@ -89,7 +89,7 @@ concise:  \arbno{\meta{thing}} means zero or more occurrences of
 
 Some non-terminal names refer to the Unicode scalar values of the same
 name: \meta{character tabulation} (U+0009), \meta{linefeed} (U+000A),
-\meta{carriage return} (U+000D), \meta{line tabulation} (U+000B),
+\meta{line tabulation} (U+000B),
 \meta{form feed} (U+000C), \meta{carriage return} (U+000D),
 \meta{space} (U+0020), \meta{next line} (U+0085), \meta{line
   separator} (U+2028), and \meta{paragraph separator} (U+2029).
@@ -197,8 +197,8 @@ language: {\tt \verb"{" \verb"}"}
 \meta{string element} \: \meta{any character other than \doublequote{} or \backwhack}
  \> \| \backwhack{}a \| \backwhack{}b \| \backwhack{}t \| \backwhack{}n \| \backwhack{}v \| \backwhack{}f \| \backwhack{}r
  \>  \| \backwhack\doublequote{} \| \backwhack\backwhack 
- \>  \| \backwhack\meta{intraline whitespace}\meta{line ending}
- \>  \hspace*{4em}\meta{intraline whitespace}
+ \>  \| \backwhack\arbno{\meta{intraline whitespace}}\meta{line ending}
+ \>  \hspace*{4em}\arbno{\meta{intraline whitespace}}
  \>  \| \meta{inline hex escape}
 \meta{intraline whitespace} \: \meta{character tabulation}
 \> \| \meta{any character whose category is Zs}%
@@ -216,6 +216,8 @@ and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
 $8$}, and \meta{decimal $16$}, which means that number representations containing
 decimal points or exponents must be in decimal radix.
 
+In the following rules, case is insignificant.
+
 \begin{grammar}%
 \meta{number} \: \meta{num $2$} \| \meta{num $8$}
    \>  \| \meta{num $10$} \| \meta{num $16$}
@@ -246,7 +248,6 @@ decimal points or exponents must be in decimal radix.
          \meta{uinteger $10$} \meta{suffix}
    \> \| . \atleastone{\meta{digit $10$}} \meta{suffix}
    \> \| \atleastone{\meta{digit $10$}} . \arbno{\meta{digit $10$}} \meta{suffix}
-   \> \| \atleastone{\meta{digit $10$}} . \meta{suffix}
 \meta{uinteger $R$} \: \atleastone{\meta{digit $R$}}
 \meta{prefix $R$} \: %
          \meta{radix $R$} \meta{exactness}
@@ -256,17 +257,17 @@ decimal points or exponents must be in decimal radix.
 \begin{grammar}%
 \meta{suffix} \: \meta{empty} 
    \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
-\meta{exponent marker} \: e \| E \| s \| S \| f \| F
-   \> \| d \| D \| l \| L
+\meta{exponent marker} \: e \| s \| f
+   \> \| d \| l
 \meta{mantissa width} \: \meta{empty}
    \> \| | \atleastone{\meta{digit 10}}
 \meta{sign} \: \meta{empty}  \| + \|  -
 \meta{exactness} \: \meta{empty}
-   \> \| \#i\sharpindex{i} \| \#I \| \#e\sharpindex{e} \| \#E
-\meta{radix 2} \: \#b\sharpindex{b} \| \#B
-\meta{radix 8} \: \#o\sharpindex{o} \| \#O
-\meta{radix 10} \: \meta{empty} \| \#d \| \#D
-\meta{radix 16} \: \#x\sharpindex{x} \| \#X
+   \> \| \#i\sharpindex{i} \| \#e\sharpindex{e}
+\meta{radix 2} \: \#b\sharpindex{b}
+\meta{radix 8} \: \#o\sharpindex{o}
+\meta{radix 10} \: \meta{empty} \| \#d
+\meta{radix 16} \: \#x\sharpindex{x}
 \meta{digit 2} \: 0 \| 1
 \meta{digit 8} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7
 \meta{digit 10} \: \meta{digit}
@@ -290,7 +291,7 @@ character of Scheme.
 \subsection{Whitespace and comments}
 \label{whitespaceandcomments}
 
-\defining{Whitespace} characters are spaces, linefeeds,
+\textit{Whitespace}\index{whitespace} characters are spaces, linefeeds,
 carriage returns, character tabulations, form feeds, line tabulations,
 and any other character whose category is Zs, Zl, or Zp.
 Whitespace is used for improved readability and
@@ -314,8 +315,9 @@ Another way to indicate a comment is to prefix a \hyper{datum}
 the comment prefix {\tt \#;} and the \hyper{datum} together.  This
 notation is useful for ``commenting out'' sections of code.
 
+%% XXX: These index entries don't work.
 Block comments may be indicated with properly nested {\tt
-  \#|}\index{#"|@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}}
+  \#|}\index{#\"|@\texttt{\sharpsign\verticalbar}}\index{\"|#@\texttt{\verticalbar\sharpsign}}
 and {\tt |\#} pairs.
 
 \begin{scheme}
@@ -461,7 +463,8 @@ a lexical syntax violation.)
 
 Case is significant in \sharpsign\backwhack\hyper{character}, and in
 \sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
-but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.  
+but not in the \meta{hex scalar value} part of
+{\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.
 A \meta{character} must be followed by a \meta{delimiter} or by the end of the input.
 This rule resolves various ambiguous cases involving named characters,
 requiring, for
@@ -641,7 +644,8 @@ significand.
 The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
 negative infinity, respectively.  The {\cf +nan.0}
 literal represents the NaN that is the result of {\cf (/ 0.0 0.0)},
-and may represent other NaNs as well.
+and may represent other NaNs as well.  The {\cf -nan.0} literal also
+represents a NaN.
 
 If \var{x} is an external representation of an inexact real number
 object and
diff --git b/document/library.tex a/document/library.tex
index 35ab474..c12dc96 100644
--- b/document/library.tex
+++ a/document/library.tex
@@ -181,7 +181,7 @@ A \hyper{sub-version reference} has one of the following forms:
 
 A \hyper{sub-version reference} of the first form matches a
 \hyper{sub-version} if it is equal to it.  A {\cf >=}
-\hyper{sub-version reference} of the first form matches a sub-version
+\hyper{sub-version reference} form matches a sub-version
 if it is greater or equal to the \hyper{sub-version} following it;
 analogously for {\cf <=}.  An {\cf and} \hyper{sub-version reference}
 matches a sub-version if all of the subsequent \hyper{sub-version
@@ -272,7 +272,7 @@ have the following form:
 \end{scheme}
 
 When {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax} forms
-occur in a top-level body prior to the first
+occur in a library body prior to the first
 expression, they are spliced into the body; see section~\ref{begin}.
 Some or all of the body, including portions wrapped in {\cf begin},
 {\cf let-syntax}, or {\cf letrec-syntax}
@@ -474,7 +474,8 @@ Examples for various \hyper{import~spec}s and \hyper{export~spec}s:
 \begin{scheme}
 (library (stack)
   (export make push! pop! empty!)
-  (import (rnrs))
+  (import (rnrs)
+          (rnrs mutable-pairs))
 
   (define (make) (list '()))
   (define (push! s v) (set-car! s (cons v (car s))))
diff --git b/document/list.tex a/document/list.tex
index f7d33b9..10fb5d0 100644
--- b/document/list.tex
+++ a/document/list.tex
@@ -68,7 +68,6 @@ as {\cf for-all} or, respectively, {\cf exists} itself.
 
 \begin{scheme}
 (for-all even? '(3 1 4 1 5 9)) \lev \schfalse{}
-(for-all even? '(3 1 4 1 5 9 . 2)) \lev \schfalse{}
 (for-all even? '(2 4 14)) \ev \schtrue{}
 (for-all even? '(2 4 14 . 9)) \lev \exception{\cf\&assertion}
 (for-all (lambda (n) (and (even? n) n))
diff --git b/document/portio.tex a/document/portio.tex
index 0fd0231..cf35e32 100644
--- b/document/portio.tex
+++ a/document/portio.tex
@@ -235,7 +235,7 @@ Returns the default end-of-line style of the underlying platform, e.g.,
 
 \begin{entry}{%
 \ctproto{i/o-decoding}
-\proto{make-i/o-decoding-error}{ port}{procedure}
+\proto{make-i/o-decoding-error}{ pobj}{procedure}
 \proto{i/o-decoding-error?}{ obj}{procedure}}
 
 This condition type could be defined by
@@ -256,7 +256,7 @@ the invalid encoding.
 
 \begin{entry}{% 
 \ctproto{i/o-encoding}
-\proto{make-i/o-encoding-error}{ port char}{procedure}
+\proto{make-i/o-encoding-error}{ pobj cobj}{procedure}
 \proto{i/o-encoding-error?}{ obj}{procedure}
 \proto{i/o-encoding-error-char}{ condition}{procedure}}
 
@@ -265,13 +265,13 @@ This condition type could be defined by
 \begin{scheme}
 (define-condition-type \&i/o-encoding \&i/o-port
   make-i/o-encoding-error i/o-encoding-error?
-  (char i/o-encoding-error-char))%
+  (cobj i/o-encoding-error-char))%
 \end{scheme}
 
 An exception with this type is raised when one of the operations for
 textual output to a port encounters a character that cannot be
 translated into bytes by the output direction of the port's transcoder.
-\var{Char} is the character that could not be encoded.
+\var{Cobj} should be the character that could not be encoded.
 \end{entry}
 
 \begin{entry}{%
@@ -280,7 +280,7 @@ translated into bytes by the output direction of the port's transcoder.
 \domain{\hyper{Error-handling-mode symbol} should be a symbol whose
   name is one of {\cf ignore}, {\cf raise}, and {\cf replace}.} The
 form evaluates to the corresponding symbol.  If
-\var{error-handling-mode symbol} is not one of these identifiers,
+\hyper{error-handling-mode symbol} is not one of these identifiers,
 effect and result are implementation-dependent: The result may be an
 error-handling-mode symbol acceptable as a \var{handling-mode}
 argument to {\cf make-transcoder}.  If it is not acceptable as a
@@ -777,6 +777,15 @@ them as part of an I/O operation requested by the program.  The
 implementation is not required to check that these procedures
 otherwise behave as described.  If they do not, however, the behavior
 of the resulting port is unspecified.
+
+\begin{note}
+  Even when the \var{get-position} procedure is supplied, the
+  {\cf port-position} procedure cannot generally return a precise
+  value for a custom textual input port if data has been
+  read from the port.  Therefore, it is likely that this entry will
+  change in a future version of the report.
+\end{note}
+
 \end{entry}
 
 \subsection{Binary input}\unsection
@@ -821,7 +830,8 @@ any bytes are available, {\cf get-bytevector-n} returns the end-of-file object.
 \mainschindex{get-bytevector-n!}{\tt\obeyspaces\\
     \var{bytevector} \var{start} \var{count})}
 
-\domain{\var{Count} must be an exact, non-negative integer object, representing
+\domain{\var{Start} and \var{count} must be exact, non-negative
+  integer objects, with \var{count} representing
   the number of bytes to be read. \var{bytevector} must be a bytevector
   with at
   least $\var{start} + \var{count}$ elements.}
@@ -860,7 +870,8 @@ of file is reached, the end-of-file object is returned.
 Attempts to read all bytes until the next end of file, blocking as
 necessary. If one or more bytes are read, {\cf get-bytevector-all} returns
 a bytevector
-containing all bytes up to the next end of file.  Otherwise, {\cf
+containing all bytes up to the next end of file and updates
+\var{binary-input-port} to point just past these bytes.  Otherwise, {\cf
   get-bytevector-all} returns the end-of-file object.
 The operation may block indefinitely waiting to see if more bytes
 will become available, even if some bytes are already available.
@@ -1187,9 +1198,7 @@ should behave as specified in the description of
   The \var{write!} procedure should write up to \var{count} bytes
   from \var{bytevector} starting at index \var{start} 
   to the byte sink.
-  If \var{count} is 0, the \var{write!} procedure should
-  have the effect of passing an end-of-file object to the byte sink.
-  In any case, the \var{write!} procedure should return the number of
+  The \var{write!} procedure should return the number of
   bytes that it wrote, as an exact integer object.
 \end{itemize}
 
@@ -1228,9 +1237,7 @@ should behave as specified in the description of
   The \var{write!} procedure should write up to \var{count} characters
   from \var{string} starting at index \var{start} 
   to the character sink.
-  If \var{count} is 0, the \var{write!} procedure should
-  have the effect of passing an end-of-file object to the character sink.
-  In any case, the \var{write!} procedure should return the number of
+  The \var{write!} procedure should return the number of
   characters that it wrote, as an exact integer object.
 \end{itemize}
 
@@ -1361,6 +1368,14 @@ Each of the remaining arguments may be \schfalse{}; if any of
 those arguments is not \schfalse{}, it must be a procedure and
 should behave as specified in the description of
 {\cf make-custom-binary-input-port}.
+
+\begin{note}
+  Unless both \var{get-position} and \var{set-position!} procedures are
+  supplied, a put operation cannot precisely position the port for output
+  to a custom binary input/output port after data has been read from
+  the port.  Therefore, it is likely that this entry will
+  change in a future version of the report.
+\end{note}
 \end{entry}
 
 \begin{entry}{%
@@ -1383,6 +1398,15 @@ Each of the remaining arguments may be \schfalse{}; if any of
 those arguments is not \schfalse{}, it must be a procedure and
 should behave as specified in the description of
 {\cf make-custom-textual-input-port}.
+
+\begin{note}
+  Even when both \var{get-position} and \var{set-position!} procedures are
+  supplied, the {\cf port-position} procedure cannot generally return a
+  precise value for a custom textual input/output port, and a put operation
+  cannot precisely position the port for output, after data has
+  been read from the port. Therefore, it is likely that this entry will
+  change in a future version of the report.
+\end{note}
 \end{entry}
 
 
diff --git b/document/r6rs-app.t2p a/document/r6rs-app.t2p
index b5f93cb..50ccf6f 100644
--- b/document/r6rs-app.t2p
+++ a/document/r6rs-app.t2p
@@ -21,6 +21,14 @@
 
 \let\TIIPbrORIG\TIIPbr
 
+% make ' fit for cut-and-paste; otherwise a special Unicode character gets output
+\evalh{(set! do-rsquo
+         (let ((do-rsquo-old do-rsquo))
+           (lambda ()
+             (if (and (not *math-mode?*) (not *ligatures?*))
+   	         (emit "'")
+	         (do-rsquo-old)))))}
+
 \newcount\obeylinesstart
 
 \def\TIIPbr{\obeylinesstart=0\TIIPbrORIG}
@@ -50,9 +58,9 @@
 \let\tableofcontentsORIG=\tableofcontents
 
 \def\tableofcontents{%
-\evalh{(set! *tex-format* 'tex)}%
+\evalh{(set! *tex-format* ':tex)}%
 \tableofcontentsORIG
-\evalh{(set! *tex-format* 'latex)}}
+\evalh{(set! *tex-format* ':latex)}}
 
 % the image preamble
 
diff --git b/document/r6rs-app.tex a/document/r6rs-app.tex
index 869a41a..8b77889 100644
--- b/document/r6rs-app.tex
+++ a/document/r6rs-app.tex
@@ -1,6 +1,11 @@
  \documentclass[twoside,twocolumn]{algol60}
 %\documentclass[twoside]{algol60}
 
+% Reproducible build:
+\pdfsuppressptexinfo=-1
+\pdfinfoomitdate=1
+\pdftrailerid{}
+
 \pagestyle{headings} 
 \showboxdepth=0
 %\makeindex
@@ -11,8 +16,8 @@
 \externaldocument[lib:]{r6rs-lib}
 \endtexonly
 
-\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Non-Normative Appendices}
-\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Rationale -}
+\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Non-Normative Appendices (latest erratum: \rnrserratadate)}
+\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Non-Normative Appendices -}
 
 \begin{document}
 
@@ -36,7 +41,10 @@ $$
   A\authorsc{NTON} \authorsc{VAN} S\authorsc{TRAATEN}}
 \\
 \multicolumn{4}{c}{(\textit{Editors})} \\[1ex]
-\multicolumn{4}{c}{\bf \rnrsrevisiondate}
+\multicolumn{4}{c}{\bf\cancel \rnrsrevisiondate} \\
+\multicolumn{4}{c}{\Huge{**Unofficial version incorporating errata**}} \\
+\multicolumn{4}{c}{\url{https://standards.scheme.org/}} \\
+\multicolumn{4}{c}{\bf \rnrserratadate}
 \end{tabular}
 $$
 
@@ -146,7 +154,7 @@ forms specified in the report and the library report:
 %
 \begin{itemize}
 \item For {\cf cond} forms (see report section~\extref{report:cond}{Derived
-    conditionals}), a \hyper{cond clause} may take one of the follow
+    conditionals}), a \hyper{cond clause} may take one of the following
   forms:
 \begin{scheme}
 [\hyper{test} \hyperi{expression} \dotsfoo]
@@ -154,7 +162,7 @@ forms specified in the report and the library report:
 {}[else \hyperi{expression} \hyperii{expression} \dotsfoo]%
 \end{scheme}
 \item For {\cf case} forms (see report section~\extref{report:case}{Derived
-    conditionals}), a \hyper{case clause} may take one of the follow
+    conditionals}), a \hyper{case clause} may take one of the following
   forms:
 \begin{scheme}
 [(\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo]
@@ -199,7 +207,7 @@ forms specified in the report and the library report:
 [\hyper{formals} \hyper{body}]%
 \end{scheme}
 \item For {\cf guard} forms (see library section~\extref{lib:guard}{Exceptions}),
-a \hyper{cond clause} may take one of the follow forms:
+a \hyper{cond clause} may take one of the following forms:
 \begin{scheme}
 [\hyper{test} \hyperi{expression} \dotsfoo]
 {}[\hyper{test} => \hyper{expression}] 
@@ -281,11 +289,13 @@ performed by altering a script header from its default form.
 (import (rnrs base)
         (rnrs io ports)
         (rnrs programs))
-(put-bytes (standard-output-port)
-           (call-with-port
-               (open-file-input-port
-                 (cadr (command-line)))
-             get-bytes-all))%
+(let ((p (standard-output-port)))
+  (put-bytevector p
+                  (call-with-port
+                      (open-file-input-port
+                        (cadr (command-line)))
+                    get-bytevector-all))
+  (close-port p))%
 \end{scheme}
 
 \section{Platform considerations}
diff --git b/document/r6rs-lib.t2p a/document/r6rs-lib.t2p
index b5f93cb..50ccf6f 100644
--- b/document/r6rs-lib.t2p
+++ a/document/r6rs-lib.t2p
@@ -21,6 +21,14 @@
 
 \let\TIIPbrORIG\TIIPbr
 
+% make ' fit for cut-and-paste; otherwise a special Unicode character gets output
+\evalh{(set! do-rsquo
+         (let ((do-rsquo-old do-rsquo))
+           (lambda ()
+             (if (and (not *math-mode?*) (not *ligatures?*))
+   	         (emit "'")
+	         (do-rsquo-old)))))}
+
 \newcount\obeylinesstart
 
 \def\TIIPbr{\obeylinesstart=0\TIIPbrORIG}
@@ -50,9 +58,9 @@
 \let\tableofcontentsORIG=\tableofcontents
 
 \def\tableofcontents{%
-\evalh{(set! *tex-format* 'tex)}%
+\evalh{(set! *tex-format* ':tex)}%
 \tableofcontentsORIG
-\evalh{(set! *tex-format* 'latex)}}
+\evalh{(set! *tex-format* ':latex)}}
 
 % the image preamble
 
diff --git b/document/r6rs-lib.tex a/document/r6rs-lib.tex
index c9df235..02a46f7 100644
--- b/document/r6rs-lib.tex
+++ a/document/r6rs-lib.tex
@@ -1,6 +1,11 @@
 \documentclass[twoside,twocolumn]{algol60}
 %\documentclass[twoside]{algol60}
 
+% Reproducible build:
+\pdfsuppressptexinfo=-1
+\pdfinfoomitdate=1
+\pdftrailerid{}
+
 \pagestyle{headings} 
 \showboxdepth=0
 \makeindex
@@ -8,7 +13,7 @@
 
 \texonly\externaldocument[report:]{r6rs}\endtexonly
 
-\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Libraries}
+\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Libraries (latest erratum: \rnrserratadate)}
 \def\integerversion{6}
 
 \begin{document}
@@ -38,7 +43,10 @@ $$
   J\authorsc{ONATHAN} R\authorsc{EES}} \\
 \multicolumn{4}{c}{(\textit{Editors, Revised\itspace{}$^5$ Report on the
     Algorithmic Language Scheme})} \\
-\multicolumn{4}{c}{\bf \rnrsrevisiondate}
+\multicolumn{4}{c}{\bf\cancel \rnrsrevisiondate} \\
+\multicolumn{4}{c}{\Huge{**Unofficial version incorporating errata**}} \\
+\multicolumn{4}{c}{\url{https://standards.scheme.org/}} \\
+\multicolumn{4}{c}{\bf \rnrserratadate}
 \end{tabular}
 $$
 
@@ -46,6 +54,9 @@ $$
 
 \end{center}
 
+\chapter*{Summary}
+\medskip
+
 {\parskip 1ex
 The report gives a defining description of the standard libraries of
 the programming language Scheme.
diff --git b/document/r6rs-rationale.t2p a/document/r6rs-rationale.t2p
index b5f93cb..50ccf6f 100644
--- b/document/r6rs-rationale.t2p
+++ a/document/r6rs-rationale.t2p
@@ -21,6 +21,14 @@
 
 \let\TIIPbrORIG\TIIPbr
 
+% make ' fit for cut-and-paste; otherwise a special Unicode character gets output
+\evalh{(set! do-rsquo
+         (let ((do-rsquo-old do-rsquo))
+           (lambda ()
+             (if (and (not *math-mode?*) (not *ligatures?*))
+   	         (emit "'")
+	         (do-rsquo-old)))))}
+
 \newcount\obeylinesstart
 
 \def\TIIPbr{\obeylinesstart=0\TIIPbrORIG}
@@ -50,9 +58,9 @@
 \let\tableofcontentsORIG=\tableofcontents
 
 \def\tableofcontents{%
-\evalh{(set! *tex-format* 'tex)}%
+\evalh{(set! *tex-format* ':tex)}%
 \tableofcontentsORIG
-\evalh{(set! *tex-format* 'latex)}}
+\evalh{(set! *tex-format* ':latex)}}
 
 % the image preamble
 
diff --git b/document/r6rs-rationale.tex a/document/r6rs-rationale.tex
index 7921c0c..12c082c 100644
--- b/document/r6rs-rationale.tex
+++ a/document/r6rs-rationale.tex
@@ -1,6 +1,11 @@
 \documentclass[twoside,twocolumn]{algol60}
 %\documentclass[twoside]{algol60}
 
+% Reproducible build:
+\pdfsuppressptexinfo=-1
+\pdfinfoomitdate=1
+\pdftrailerid{}
+
 \pagestyle{headings} 
 \showboxdepth=0
 \makeindex
@@ -15,8 +20,8 @@
 \externaldocument[app:]{r6rs-app}
 \endtexonly
 
-\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Rationale}
-\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Non-Normative Appendices -}
+\def\headertitle{Revised$^{\rnrsrevision}$ Scheme Rationale (latest erratum: \rnrserratadate)}
+\def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme - Rationale -}
 
 \begin{document}
 
@@ -44,7 +49,10 @@
   J\authorsc{ONATHAN} R\authorsc{EES}} \\
 \multicolumn{4}{c}{(\textit{Editors, Revised\itspace{}$^5$ Report on the
     Algorithmic Language Scheme})} \\
-\multicolumn{4}{c}{\bf \rnrsrevisiondate}
+\multicolumn{4}{c}{\bf\cancel \rnrsrevisiondate} \\
+\multicolumn{4}{c}{\Huge{**Unofficial version incorporating errata**}} \\
+\multicolumn{4}{c}{\url{https://standards.scheme.org/}} \\
+\multicolumn{4}{c}{\bf \rnrserratadate}
 \end{tabular}
 $$
 
@@ -1538,7 +1546,10 @@ other primitive data types such as pairs.
 The goals of the exception mechanism are to help programmers share
 code which relies on exception handling, and to provide information on
 violations of specifications of procedures and syntactic forms.  This
-exception mechanism is an extension of SRFI~34~\cite{srfi34}, which
+exception mechanism is a extension of
+SRFI~34~\cite{srfi34}\footnote{There is also a small different to
+  SRFI~34, namely that {\cf guard} calls {\cf raise-continuable}
+  instead of {\cf raise} when re-raising an exception.}, which
 was primarily designed to meet the first goal.  However, it has proven
 suitable for addressing the second goal of dealing with violations as
 well.   (More on the second goal below in the discussion of the
@@ -1625,7 +1636,7 @@ flags.
 
 \section{End-of-line styles}
 
-The set of end-of-line styles recognized by the \rsixlibrary{ports}
+The set of end-of-line styles recognized by the \rsixlibrary{io ports}
 library is not closed, because end-of-line styles other than those
 listed might become commonplace in the future.
 
diff --git b/document/r6rs.t2p a/document/r6rs.t2p
index e5da0d3..e8ebe05 100644
--- b/document/r6rs.t2p
+++ a/document/r6rs.t2p
@@ -23,6 +23,14 @@
 
 \let\TIIPbrORIG\TIIPbr
 
+% make ' fit for cut-and-paste; otherwise a special Unicode character gets output
+\evalh{(set! do-rsquo
+         (let ((do-rsquo-old do-rsquo))
+           (lambda ()
+             (if (and (not *math-mode?*) (not *ligatures?*))
+   	         (emit "'")
+	         (do-rsquo-old)))))}
+
 \newcount\obeylinesstart
 
 \def\TIIPbr{\obeylinesstart=0\TIIPbrORIG}
@@ -52,9 +60,9 @@
 \let\tableofcontentsORIG=\tableofcontents
 
 \def\tableofcontents{%
-\evalh{(set! *tex-format* 'tex)}%
+\evalh{(set! *tex-format* ':tex)}%
 \tableofcontentsORIG
-\evalh{(set! *tex-format* 'latex)}}
+\evalh{(set! *tex-format* ':latex)}}
 
 % the image preamble
 
diff --git b/document/r6rs.tex a/document/r6rs.tex
index 12931bd..5b3e3f5 100644
--- b/document/r6rs.tex
+++ a/document/r6rs.tex
@@ -1,6 +1,10 @@
 \documentclass[twoside,twocolumn]{algol60}
 %\documentclass[twoside]{algol60}
 
+% Reproducible build:
+\pdfsuppressptexinfo=-1
+\pdfinfoomitdate=1
+\pdftrailerid{}
 
 \pagestyle{headings}
 \showboxdepth=0
@@ -12,7 +16,7 @@
 \externaldocument[lib:]{r6rs-lib}
 \endtexonly
 
-\def\headertitle{Revised$^{\rnrsrevision}$ Scheme}
+\def\headertitle{Revised$^{\rnrsrevision}$ Scheme (latest erratum: \rnrserratadate)}
 \def\TZPtitle{Revised^\rnrsrevision{} Report on the Algorithmic Language Scheme}
 
 \begin{document}
@@ -43,7 +47,10 @@ $$
 \multicolumn{4}{c}{
   R\authorsc{OBERT} B\authorsc{RUCE} F\authorsc{INDLER}, J\authorsc{ACOB} M\authorsc{ATTHEWS}} \\
 \multicolumn{4}{c}{(\textit{Authors, formal semantics})} \\[1ex]
-\multicolumn{4}{c}{\bf \rnrsrevisiondate}
+\multicolumn{4}{c}{\bf\cancel \rnrsrevisiondate} \\
+\multicolumn{4}{c}{\Huge{**Unofficial version incorporating errata**}} \\
+\multicolumn{4}{c}{\url{https://standards.scheme.org/}} \\
+\multicolumn{4}{c}{\bf \rnrserratadate}
 \end{tabular}
 $$
 
diff --git b/document/records.tex a/document/records.tex
index a290117..8c8dbfa 100644
--- b/document/records.tex
+++ a/document/records.tex
@@ -90,7 +90,7 @@ field is called \textit{immutable}\mainindex{immutable record
 are immutable objects.  All other record types are \textit{mutable},
 and so are their records.
 
-Each call to a record constructor returns a new record with a fresh
+Each call to a record constructor of a mutable record type returns a new record with a fresh
 location (see report section~\extref{report:storagemodel}{Storage
   model}).  Consequently, for two records \vari{obj} and \varii{obj},
 the return value of {\cf (eqv? \vari{obj} \varii{obj})}, as well as the
@@ -103,7 +103,7 @@ section~\extref{report:eqv?}{Equivalence predicates}):
   their record-type descriptors are not {\cf eqv?}), {\cf eqv?}
   returns \schfalse.
 \item If \vari{obj} and \varii{obj} are both records of the
-  same record type, and are the results of two separate calls to
+  same mutable record type, and are the results of two separate calls to
   record constructors, then {\cf eqv?} returns \schfalse.
 \item If \vari{obj} and \varii{obj} are both the result of a single call to a
   record constructor, then {\cf eqv?} returns \schtrue.
@@ -230,15 +230,13 @@ Specifies that the record type is to have parent type \hyper{parent
 record type previously defined using {\cf define-record-type}. 
 The record-type definition
 associated with \hyper{parent name} must not be sealed.
-If
-no {\cf parent} clause and no {\cf parent-rtd} (see below) clause
-is present, the record type is a base type.  
 
 {\cf (protocol \hyper{expression})}
    
 \hyper{Expression} is evaluated in the same environment as the
-{\cf define-record-type} form, and must evaluate to a protocol appropriate
-for the record type being defined.
+{\cf define-record-type} form.
+It must evaluate to a procedure, and this procedure should be
+a protocol appropriate for the record type being defined.
 
 The protocol is used to create a record-constructor descriptor as
 described below.  If no {\cf protocol} clause is specified, a
@@ -292,9 +290,15 @@ generated every time a {\cf define-record-type} form is evaluated:
 
 Specifies that the record type is to have its parent type specified by
 \hyper{parent rtd}, which should be an expression evaluating to a
-record-type descriptor, and \hyper{parent cd}, which should be an
-expression evaluating to a constructor descriptor (see below).  The
-record-type definition associated with the value of \hyper{parent rtd}
+record-type descriptor or \schfalse, and \hyper{parent cd}, which should be an
+expression evaluating to a constructor descriptor (see below) or
+\schfalse.
+
+If \hyper{parent rtd} evaluates to \schfalse, then if \hyper{parent cd}
+evaluates to a value, that value must be \schfalse.
+
+If \hyper{parent rtd} evaluates to a record-type descriptor, the
+record type
 must not be sealed.  Moreover, a record-type definition must not have
 both a {\cf parent} and a {\cf parent-rtd} clause.
 
@@ -313,18 +317,24 @@ All bindings created by {\cf define-record-type} (for the record type,
 the constructor, the predicate, the accessors, and the
 mutators) must have names that are pairwise distinct.
 
+If
+no {\cf parent} clause is present, no {\cf parent-rtd} clause
+is present, or a {\cf parent-rtd} clause is present but
+\hyper{parent rtd} evaluates to \schfalse,
+the record type is a base type.  
+
 The constructor created by a {\cf define-record-type} form is a
 procedure as follows:
 %
 \begin{itemize}
-\item If there is no {\cf parent} clause and no {\cf protocol} clause,
+\item If the record type is a base type and no {\cf protocol} clause is present,
   the constructor accepts as many arguments as there are fields, in
   the same order as they appear in the {\cf fields} clause, and
   returns a record object with the fields initialized to the
   corresponding arguments.
-\item If there is no {\cf parent} or {\cf parent-rtd} clause and a
-  {\cf protocol} clause,
-  the protocol expression must evaluate to a procedure that accepts a
+\item If the record type is a base type and a {\cf protocol} clause is present,
+  the protocol expression, if it evaluates to a value,
+  must evaluate to a procedure, and this procedure should accept a
   single argument.  The protocol procedure is called once during the
   evaluation of the {\cf define-record-type} form with a
   procedure \var{p} as its argument.  It should return a procedure,
@@ -349,8 +359,8 @@ procedure as follows:
     (p v3 v2 v1)))%
  \end{scheme}
 
-\item If there is both a {\cf parent} clause and a {\cf protocol}
-  clause, then the protocol procedure is called once with a procedure
+\item If the record type is not a base type and a {\cf protocol}
+  clause is present, then the protocol procedure is called once with a procedure
   \var{n} as its argument.  As in the previous case, the protocol
   procedure should return a procedure, which will become the
   constructor bound to \hyper{constructor name}.  However, \var{n} is
@@ -384,16 +394,17 @@ also initializes the fields of this record type to the values of {\cf
 
 \item If there is a {\cf parent} clause, but no {\cf protocol} clause,
   then the parent type must not have a
-  {\cf protocol} clause itself.  The constructor bound to
+  {\cf protocol} clause itself.
+  Similarly, if there is a {\cf parent-rtd} clause whose \hyper{parent rtd}
+  evaluates to a record-type descriptor, but no {\cf protocol} clause,
+  then the \hyper{parent cd} expression, if it evaluates to a value,
+  must evaluate to \schfalse.
+  The constructor bound to
   \hyper{constructor name} is a procedure that accepts arguments corresponding to the 
   parent types' constructor first, and then one argument for each field in the same
   order as in the {\cf fields} clause. The constructor
   returns a record object with the fields initialized to the corresponding
   arguments.
-\item If there is a {\cf parent-rtd} clause, then the constructor is
-  as with a {\cf parent} clause, except that the constructor of the
-  parent type is determined by the constructor descriptor of the {\cf
-    parent-rtd} clause.
 \end{itemize}
 
 A protocol may perform other actions consistent with the requirements
@@ -615,7 +626,7 @@ called twice with the same \var{uid} symbol, the parent
 arguments in the two calls must be {\cf eqv?}, the \var{fields}
 arguments {\cf equal?}, the \var{sealed?} arguments boolean-equivalent
 (both \schfalse{} or both true), and the \var{opaque?} arguments
-boolean-equivalent.
+boolean-equivalent if the parents are not opaque.
 If these conditions are not met, an exception with condition type
 {\cf\&assertion} is raised when the second call occurs.
 If they are met, the second call returns, without creating a new
@@ -697,7 +708,7 @@ If it is \schfalse, a default \var{protocol} procedure is supplied.
 If \var{protocol} is a procedure, it is handled analogously to the
 protocol expression in a {\cf define-record-type} form.
 
-If \var{rtd} is a base record type and \var{protocol} is a procedure,
+If \var{rtd} is a base record type
 \var{parent-constructor-descriptor} must be \schfalse.  In this case,
 \var{protocol} is called by {\cf record-constructor} with a single
 argument \var{p}.  \var{P} is a procedure that expects one argument
@@ -725,7 +736,7 @@ If \var{rtd} is an extension of another record type \var{parent-rtd}
 and \var{protocol} is a procedure, \var{parent-constructor-descriptor}
 must be a constructor descriptor of \var{parent-rtd} or \schfalse.  If
 \var{parent-constructor-descriptor} is a constructor descriptor,
-\var{protocol} it is called by {\cf record-constructor} with a single
+\var{protocol} is called by {\cf record-constructor} with a single
 argument \var{n}, which is a procedure that accepts the same number of
 arguments as the constructor of \var{parent-constructor-descriptor}
 and returns a procedure \var{p} that, when called, constructs the
@@ -783,11 +794,11 @@ the parent coming before those of the extension in the argument list.
 (In the example, $j$ is the complete number of fields of the parent
 type, and $k$ is the number of fields of \var{rtd} itself.)
 
-If \var{rtd} is an extension of another record type, and
-\var{parent-constructor-descriptor} or the \var{protocol} of
-\var{parent-constructor-descriptor} is \schfalse, \var{protocol} must
-also be \schfalse, and a default constructor descriptor as
-described above is also assumed.
+If \var{rtd} is an extension of another record type and
+\var{parent-constructor-descriptor} is \schfalse{},
+\var{parent-constructor-descriptor} is treated as if it were a
+constructor descriptor for the parent rtd of \var{rtd} with a default
+protocol.
 
 \implresp If \var{protocol} is a procedure, the implementation must
 check the restrictions on it to the extent performed by applying it as
@@ -952,8 +963,8 @@ The mutator returns \unspecifiedreturn.
 (define make-point/abs
   (record-constructor :point-cd/abs))
 
-(point-x (make-point/abs -1 -2) \lev 1
-(point-y (make-point/abs -1 -2) \lev 2
+(point-x (make-point/abs -1 -2)) \lev 1
+(point-y (make-point/abs -1 -2)) \lev 2
 
 (define :cpoint
   (make-record-type-descriptor
@@ -983,7 +994,7 @@ The mutator returns \unspecifiedreturn.
 (define (color->rgb c)
   (cons 'rgb c))
 
-(cpoint-rgb (make-cpoint -1 -3 'red) \lev (rgb . red)
+(cpoint-rgb (make-cpoint -1 -3 'red)) \lev (rgb . red)
 (point-x (make-cpoint -1 -3 'red)) \lev -1
 (point-x (make-cpoint/abs -1 -3 'red)) \lev 1%
 \end{scheme}
diff --git b/document/revision.tex a/document/revision.tex
index d4c8667..27a6ae0 100644
--- b/document/revision.tex
+++ a/document/revision.tex
@@ -1,2 +1,3 @@
 \def\rnrsrevision{6}
 \def\rnrsrevisiondate{26 September 2007}
+\def\rnrserratadate{21 July 2019}
diff --git b/document/rrs.bib a/document/rrs.bib
index a2369a3..2e66953 100644
--- b/document/rrs.bib
+++ a/document/rrs.bib
@@ -177,13 +177,13 @@
 }
 
 @Article{syntacticabstraction,
-  author = 	 {R. Kent Dybvig and Robert Hieb and Carl Bruggeman},
-  title = 	 {Syntactic Abstraction in {Scheme}},
-  journal = 	 lasc,
-  year = 	 1988,
-  volume =	 1,
-  number =	 1,
-  pages =	 {53-75}
+  author =       {R. Kent Dybvig and Robert Hieb and Carl Bruggeman},
+  title =        {Syntactic Abstraction in {Scheme}},
+  journal =      lasc,
+  year =         1992,
+  volume =       5,
+  number =       4,
+  pages =        {295-326}
 }
 
 @Book{tspl3,
diff --git b/document/semantics-commands.tex a/document/semantics-commands.tex
index 053f038..b8aa597 100644
--- b/document/semantics-commands.tex
+++ a/document/semantics-commands.tex
@@ -5,13 +5,13 @@
 \usepackage{stmaryrd}
 
 \newcounter{subfig}
-\newcommand{\subfigurestart}{\renewcommand{\thefigure}{A.\arabic{figure}\alph{subfig}}\setcounter{subfig}{1}}
+\newcommand{\subfigurestart}{\texonly\renewcommand{\thefigure}{A.\arabic{figure}\alph{subfig}}\setcounter{subfig}{1}\endtexonly}
 
 
 % needed for the second thru the nth figure
-\newcommand{\subfigureadjust}{\addtocounter{figure}{-1}\addtocounter{subfig}{1}}
+\newcommand{\subfigureadjust}{\texonly\addtocounter{figure}{-1}\addtocounter{subfig}{1}\endtexonly}
 
-\newcommand{\subfigurestop}{\renewcommand{\thefigure}{A.\arabic{figure}}}
+\newcommand{\subfigurestop}{\texonly\renewcommand{\thefigure}{A.\arabic{figure}}\endtexonly}
 
 
 \newcommand{\semanticsindex}[2]{\index{#1@{\texttt{#1} (formal semantics)}}}
@@ -58,6 +58,10 @@
 \imgdef\calRv{\ensuremath{\mathcal{R}_v}}
 \imgdef\calA{\ensuremath{\mathcal{A}}}
 \imgdef\scrO{\ensuremath{\mathscr{O}}}
+\imgdef\scrR{\ensuremath{\mathscr{R}}}
+\imgdef\scrQ{\ensuremath{\mathscr{Q}}}
+\imgdef\scrT{\ensuremath{\mathscr{T}}}
+\imgdef\scrS{\ensuremath{\mathscr{S}}}
 
 \newcommand{\semfalse}{\texttt{\#f}}
 \newcommand{\semtrue}{\texttt{\#t}}
diff --git b/document/semantics.tex a/document/semantics.tex
index b7c4fe1..302b3c8 100644
--- b/document/semantics.tex
+++ a/document/semantics.tex
@@ -1,5 +1,141 @@
 %!TEX root = r6rs.tex
 
+\newcommand{\figGrammar}{
+\texonly\addtocounter{figure}{1}\endtexonly % get the figure counter in sync with the section counter
+\subfigurestart{}
+\beginfig
+\input{r6-fig-grammar-parti.tex}
+\caption{Grammar for programs and observables}\label{fig:grammar}
+\endfig
+}
+
+\newcommand{\figEcGrammar}{
+\beginfig
+\subfigureadjust{}
+\input{r6-fig-grammar-partii.tex}
+\caption{Grammar for evaluation contexts}\label{fig:ec-grammar}
+\endfig
+\subfigurestop{}
+}
+
+\newcommand{\figQuote}{
+\beginfig
+\begin{center}
+\input{r6-fig-Quote.tex}
+
+\input{r6-fig-QtocQtoic.tex}
+\end{center}
+\caption{Quote}\label{fig:quote}
+\endfig
+}
+
+\newcommand{\figMV}{
+\beginfig
+\begin{center}
+\input{r6-fig-Multiple--values--and--call-with-values.tex}
+\end{center}
+\caption{Multiple values and call-with-values}\label{fig:Multiple--values--and--call-with-values}
+\endfig
+}
+
+\newcommand{\figExceptions}{
+\beginfig
+\begin{center}
+\input{r6-fig-Exceptions}
+\end{center}
+\caption{Exceptions}\label{fig:Exceptions}
+\endfig
+}
+
+\newcommand{\figArithmetic}{
+\beginfig
+\begin{center}
+\input{r6-fig-Arithmetic.tex}
+\input{r6-fig-Basic--syntactic--forms.tex}
+\end{center}
+\caption{Arithmetic and basic forms}\label{fig:Arithmetic}
+\endfig
+}
+
+\newcommand{\figCons}{
+\beginfig
+\begin{center}
+\input{r6-fig-Cons.tex}
+\end{center}
+\caption{Lists}\label{fig:Cons}
+\endfig
+}
+
+\newcommand{\figEqv}{
+\beginfig
+\begin{center}
+\input{r6-fig-Eqv.tex}
+\end{center}
+\caption{Eqv}\label{fig:Eqv}
+\endfig
+}
+
+\newcommand{\figApplication}{
+\subfigurestart{}
+\beginfig
+\begin{center}
+\input{r6-fig-Procedure--application.tex}
+\end{center}
+\caption{Procedures \& application}\label{fig:Procedure--application}
+\endfig
+}
+
+\newcommand{\figVarsetd}{
+\beginfig
+\subfigureadjust{}
+\begin{center}
+\input{r6-fig-Var-set!d_.tex}
+\end{center}
+\caption{Variable-assignment relation}\label{fig:varsetd}
+\endfig
+}
+
+\newcommand{\figApply}{
+\beginfig
+\subfigureadjust{}
+\begin{center}
+\input{r6-fig-Apply.tex}
+\input{r6-fig-circular_.tex}
+\end{center}
+\caption{Apply}\label{fig:Apply}
+\endfig
+\subfigurestop{}
+}
+
+\newcommand{\figCallcc}{
+\beginfig
+\begin{center}
+\input{r6-fig-Call-cc--and--dynamic-wind.tex} \\
+\input{r6-fig-TrimpRepoSt.tex}
+\end{center}
+\caption{Call/cc and dynamic wind}\label{fig:Call-cc--and--dynamic-wind}
+\endfig
+}
+
+\newcommand{\figLetrec}{
+\beginfig
+\begin{center}
+\input{r6-fig-Letrec.tex}
+\end{center}
+\caption{Letrec and letrec*}
+\label{fig:Letrec}
+\endfig
+}
+
+\newcommand{\figUnderspec}{
+\beginfig
+\begin{center}
+\input{r6-fig-Underspecification.tex}
+\end{center}
+\caption{Explicitly unspecified behavior}\label{fig:Underspecification}
+\endfig
+}
+
 This appendix presents a non-normative, formal, operational semantics for Scheme, that is based on an earlier semantics~\cite{mf:scheme-op-sem}. It does not cover the entire language. The notable missing features are the macro system, I/O, and the numerical tower. The precise list of features included is given in section~\ref{sec:semantics:grammar}.
 
 The core of the specification is a single-step term rewriting relation that indicates how an (abstract) machine behaves. In general, the report is not a complete specification, giving implementations freedom to behave differently, typically to allow optimizations. This underspecification shows up in two ways in the semantics. 
@@ -87,13 +223,7 @@ Sometimes we use equality in the side-conditions; when we do it merely
 means simple term equality, i.e., the two terms must have the
 same syntactic shape.
 
-
-\addtocounter{figure}{1} % get the figure counter in sync with the section counter
-\subfigurestart{}
-\beginfig
-\input{r6-fig-grammar-parti.tex}
-\caption{Grammar for programs and observables}\label{fig:grammar}
-\endfig
+\texonly\figGrammar\endtexonly
 
 Making the evaluation context $E$ explicit in the rule allows
 us to define relations that manipulate their context. As a simple
@@ -116,12 +246,9 @@ sophisticated ways.
 
 \section{Grammar}\label{sec:semantics:grammar}
 
-\beginfig
-\subfigureadjust{}
-\input{r6-fig-grammar-partii.tex}
-\caption{Grammar for evaluation contexts}\label{fig:ec-grammar}
-\endfig
-\subfigurestop{}
+\htmlonly\figGrammar\endhtmlonly
+
+\texonly\figEcGrammar\texonly
 
 Figure~\ref{fig:grammar} shows the grammar for the subset of the
 report this semantics models. Non-terminals are written in
@@ -178,14 +305,7 @@ rewritten into calls to the list construction functions before
 ordinary evaluation proceeds. In parallel to \nt{es}, \nt{e} represents
 expressions that have no quoted expressions.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Quote.tex}
-
-\input{r6-fig-QtocQtoic.tex}
-\end{center}
-\caption{Quote}\label{fig:quote}
-\endfig
+\texonly\figQuote\endtexonly
 
 The values ($v$) are divided into four categories:
 %
@@ -222,12 +342,9 @@ The next three set of non-terminals in figure~\ref{fig:grammar} represent pairs
 \nt{x}, and $n$ represent symbols, variables, and
 numbers respectively. The non-terminals \nt{ip}, \nt{mp}, and \nt{sym} are all assumed to all be disjoint. Additionally, the variables $x$ are assumed not to include any keywords or primitive operations, so any program variables whose names coincide with them must be renamed before the semantics can give the meaning of that program.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Multiple--values--and--call-with-values.tex}
-\end{center}
-\caption{Multiple values and call-with-values}\label{fig:Multiple--values--and--call-with-values}
-\endfig
+\htmlonly\figEcGrammar\endhtmlonly
+
+\texonly\figMV\endtexonly
 
 The set of non-terminals for evaluation contexts is shown in
 figure~\ref{fig:ec-grammar}. The \nt{P} non-terminal controls where
@@ -240,6 +357,8 @@ exceptions and \va{dynamic-wind}. The starred and circled variants,
 promoted to multiple values and where multiple values are demoted to a
 single value. The \nt{U} context is used to manage the report's underspecification of the results of \sy{set!}, \va{set-car!}, and \va{set-cdr!} (see section~\ref{sec:semantics:underspecification} for details). Finally, the \nt{S} context is where quoted expressions can be simplified. The precise use of the evaluation contexts is explained along with the relevant rules.
 
+Although it is not written in the grammar figure, variable sequences bound in the store, and in \sy{lambda}, \sy{letrec}, and \sy{letrec*} must not contain any duplicates.
+
 To convert the answers ($\calA$)  of the semantics into observable results, we use these two functions:
 \input{r6-fig-observable}
 \input{r6-fig-observable-value}
@@ -247,11 +366,13 @@ They eliminate the store, and replace complex values with simple tags that indic
 
 \section{Quote}\label{sec:semantics:quote}
 
+\htmlonly\figQuote\endhtmlonly
+
 The first reduction rules that apply to any program is the 
 rules in figure~\ref{fig:quote} that eliminate quoted expressions. 
 The first two rules erase the quote for quoted expressions that do not introduce any pairs.
 The last two rules lift quoted datums to the top of the expression so
-they are evaluated only once, and turn the datums into calls to either \va{cons} or \va{consi}, via the metafunctions $\mathscr{Q}_i$ and $\mathscr{Q}_m$.
+they are evaluated only once, and turn the datums into calls to either \va{cons} or \va{consi}, via the metafunctions $\scrQ_i$ and $\scrQ_m$.
 
 Note that the left-hand side of the \rulename{6qcons} and \rulename{6qconsi} rules are identical, meaning that if one rule applies to a term, so does the other rule. 
 Accordingly, a quoted expression may be lifted out into a sequence of \va{cons} expressions, which create mutable pairs, or into a sequence of \va{consi} expressions, which create immutable pairs (see section~\ref{sec:semantics:lists} for the rules on how that happens).
@@ -270,12 +391,7 @@ into lists before those rules apply.
 
 Although the identifier \nt{qp} does not have a subscript, the semantics of PLT Redex's ``fresh'' declaration takes special care to ensures that the \nt{qp} on the right-hand side of the rule is indeed the same as the one in the side-condition.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Exceptions}
-\end{center}
-\caption{Exceptions}\label{fig:Exceptions}
-\endfig
+\texonly\figExceptions\endtexonly
 
 \section{Multiple values}
 
@@ -326,13 +442,9 @@ need to consider multiple values in its first subexpression.
 Similarly, the rule for \sy{begin} does not need to consider the
 case of a single value as its first subexpression.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Arithmetic.tex}
-\input{r6-fig-Basic--syntactic--forms.tex}
-\end{center}
-\caption{Arithmetic and basic forms}\label{fig:Arithmetic}
-\endfig
+\texonly\figArithmetic\endtexonly
+
+\htmlonly\figMV\endhtmlonly
 
 The other two rules in
 figure~\ref{fig:Multiple--values--and--call-with-values} handle
@@ -349,15 +461,12 @@ case that the first argument to \va{call-with-values} is a value,
 but is not of the form $\texttt{(}\sy{lambda}~\texttt{()}~e\texttt{)}$, the rule
 \rulename{6cwvw} wraps it in a thunk to trigger evaluation.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Cons.tex}
-\end{center}
-\caption{Lists}\label{fig:Cons}
-\endfig
+\texonly\figCons\endtexonly
 
 \section{Exceptions}
 
+\htmlonly\figExceptions\endhtmlonly
+
 The workhorses for the exception system are $$\texttt{(}\sy{handlers}~\nt{proc}~\cdots{}~\nt{e}\texttt{)}$$ expressions and the \nt{G} and \nt{PG} evaluation contexts (shown in figure~\ref{fig:ec-grammar}). 
 The \sy{handlers} expression records the
 active exception handlers (\nt{proc} $\cdots$) in some expression (\nt{e}). The
@@ -406,12 +515,7 @@ handler. The \rulename{6xr} rule behaves similarly, except it
 raises a new exception if the handler returns. The new exception is
 created with the \sy{make-cond} special form.
 
-\beginfig
-\begin{center}
-\input{r6-fig-Eqv.tex}
-\end{center}
-\caption{Eqv}\label{fig:Eqv}
-\endfig
+\texonly\figEqv\endtexonly
 
 The \sy{make-cond} special form is a stand-in for the report's
 conditions. It does not evaluate its argument (note its absence from
@@ -428,6 +532,8 @@ incorrect arguments.
 
 \section{Arithmetic and basic forms}
 
+\htmlonly\figArithmetic\endhtmlonly
+
 This model does not include the report's arithmetic, but does include
 an idealized form in order to make experimentation with other features
 and writing test suites for the model simpler.
@@ -454,13 +560,7 @@ subexpressions. In that case, once the first expression has been fully
 simplified, the reduction rules drop its value. If there is only a
 single subexpression, the \sy{begin} itself is dropped.
 
-\subfigurestart{}
-\beginfig
-\begin{center}
-\input{r6-fig-Procedure--application.tex}
-\end{center}
-\caption{Procedures \& application}\label{fig:Procedure--application}
-\endfig
+\texonly\figApplication\endtexonly
 
 Like the \sy{begin} evaluation contexts, the \sy{begin0}
 evaluation contexts allow evaluation of the first subexpression of a
@@ -475,6 +575,8 @@ at which point the \rulename{begin01} rule fires, and removes the
 
 \section{Lists}\label{sec:semantics:lists}
 
+\htmlonly\figCons\endhtmlonly
+
 The rules in figure~\ref{fig:Cons} handle lists. The first two rules handle \va{list} by reducing it to a succession of calls to \va{cons}, followed by \va{null}.
 
 The next two rules, \rulename{6cons} and \rulename{6consi}, allocate new \va{cons} cells.
@@ -487,18 +589,14 @@ The rules \rulename{6car} and \rulename{6cdr} extract the components of a pair f
 The rules \rulename{6setcar} and \rulename{6setcdr} handle assignment of mutable pairs. 
 They replace the contents of the appropriate location in the store with the new value, and reduce to \va{unspecified}. See section~\ref{sec:semantics:underspecification} for an explanation of how \va{unspecified} reduces.
 
-\beginfig
-\subfigureadjust{}
-\begin{center}
-\input{r6-fig-Var-set!d_.tex}
-\end{center}
-\caption{Variable-assignment relation}\label{fig:varsetd}
-\endfig
+\texonly\figVarsetd\endtexonly
 
 The next four rules handle the \va{null?} predicate and the \va{pair?} predicate, and the final four rules raise exceptions when \va{car}, \va{cdr}, \va{set-car!} or \va{set-cdr!} receive non pairs.
 
 \section{Eqv}
 
+\htmlonly\figEqv\endhtmlonly
+
 The rules for \va{eqv?} are shown in figure~\ref{fig:Eqv}. The first two rules cover most of the behavior of \va{eqv?}. 
 The first says that when the two arguments to \va{eqv?} are syntactically identical, then \va{eqv?} produces \semtrue{} and the second says that when the arguments are not syntactically identical, then \va{eqv?} produces \semfalse{}. 
 The structure of \nt{v} has been carefully designed so that simple term equality corresponds closely to \va{eqv?}'s behavior. 
@@ -508,6 +606,8 @@ The side-conditions on those first two rules ensure that they do not apply when
 
 \section{Procedures and application}
 
+\htmlonly\figApplication\endhtmlonly
+
 In evaluating a procedure call, the report leaves
 unspecified the order in which arguments are evaluated. So, our reduction system allows multiple, different reductions to occur, one for each possible order of evaluation.
 
@@ -526,6 +626,8 @@ application, allowing it to be evaluated. Once one of the lifted
 expressions is evaluated, the \rulename{6appN} substitutes its value
 back into the original application.
 
+\htmlonly\figVarsetd\endhtmlonly
+
 The \rulename{6appN} rule also handles other applications whose
 arguments are finished by substituting the first argument for
 the first formal parameter in the expression. Its side-condition uses
@@ -555,15 +657,7 @@ The rule \rulename{6var} handles variable lookup in the store and \rulename{6set
 
 The next two rules \rulename{6proct} and \rulename{6procf} handle applications of \va{procedure?}, and the remaining rules cover applications of non-procedures and arity violations.
 
-\beginfig
-\subfigureadjust{}
-\begin{center}
-\input{r6-fig-Apply.tex}
-\input{r6-fig-circular_.tex}
-\end{center}
-\caption{Apply}\label{fig:Apply}
-\endfig
-\subfigurestop{}
+\figApply
 
 The rules in figure~\ref{fig:Apply} 
 cover \va{apply}. 
@@ -583,13 +677,7 @@ too few arguments to \va{apply}.
 
 \section{Call/cc and dynamic wind}
 
-\beginfig
-\begin{center}
-\input{r6-fig-Call-cc--and--dynamic-wind.tex} \\
-\input{r6-fig-TrimpRepoSt.tex}
-\end{center}
-\caption{Call/cc and dynamic wind}\label{fig:Call-cc--and--dynamic-wind}
-\endfig
+\figCallcc
 
 The specification of \va{dynamic-wind} uses 
 $\texttt{(}\sy{dw}~x~e~e~e\texttt{)}$
@@ -623,15 +711,15 @@ use in the \rulename{6throw} rule when the continuation is applied.
 That rule takes the arguments of the continuation, wraps them with a
 call to \va{values}, and puts them back into the place where the
 original call to \va{call/cc} occurred, replacing the current
-context with the context returned by the $\mathscr{T}$ metafunction.
+context with the context returned by the $\scrT$ metafunction.
 
-The $\mathscr{T}$ (for ``trim'') metafunction accepts two $D$ contexts and
+The $\scrT$ (for ``trim'') metafunction accepts two $D$ contexts and
 builds a context that matches its second argument, the destination
 context, except that additional calls to the \var{before} and
 \var{after} procedures
 from \sy{dw} expressions in the context have been added.
 
-The first clause of the $\mathscr{T}$ metafunction exploits the
+The first clause of the $\scrT$ metafunction exploits the
 $H$ context, a context that contains everything except
 \sy{dw} expressions. It ensures that shared parts of the
 \va{dynamic-wind} context are ignored, recurring deeper into the
@@ -643,29 +731,23 @@ either when there are no \sy{dw}s in the context, or when the
 metafunctions defined in figure~\ref{fig:Call-cc--and--dynamic-wind} and
 puts their results together into a \sy{begin} expression.
 
-The $\mathscr{R}$ metafunction extracts all of the \var{before}
-procedures from its argument and the $\mathscr{S}$ metafunction extracts all of the \var{after} procedures from its argument. They each construct new contexts and exploit
+The $\scrR$ metafunction extracts all of the \var{before}
+procedures from its argument and the $\scrS$ metafunction extracts all of the \var{after} procedures from its argument. They each construct new contexts and exploit
 $H$ to work through their arguments, one \sy{dw} at a time.
 In each case, the metafunctions are careful to keep the right
 \sy{dw} context around each of the procedures in case a continuation
 jump occurs during one of their evaluations. 
-Since $\mathscr{R}$,
+Since $\scrR$,
 receives the destination context, it keeps the intermediate
 parts of the context in its result.
 In contrast
-$\mathscr{S}$ discards all of the context except the \sy{dw}s,
+$\scrS$ discards all of the context except the \sy{dw}s,
 since that was the context where the call to the
 continuation occurred.
 
 \section{Letrec}
 
-\beginfig
-\begin{center}
-\input{r6-fig-Letrec.tex}
-\end{center}
-\caption{Letrec and letrec*}
-\label{fig:Letrec}
-\endfig
+\figLetrec
 
 Figre~\ref{fig:Letrec} shows the rules that handle \sy{letrec} and \sy{letrec*} and the supplementary expressions that they produce, \sy{l!} and \sy{reinit}. As a first approximation, both \va{letrec} and \va{letrec*} reduce by allocating locations in the store to hold the values of the init expressions, initializing those locations to \sy{bh} (for ``black hole''), evaluating the init expressions, and then using \va{l!} to update the locations in the store with the value of the init expressions. They also use \va{reinit} to detect when an init expression in a letrec is reentered via a continuation.
 
@@ -690,12 +772,7 @@ The \rulename{6letrec*} rule behaves similarly, but uses a \sy{begin} expression
 
 \section{Underspecification}\label{sec:semantics:underspecification}
 
-\beginfig
-\begin{center}
-\input{r6-fig-Underspecification.tex}
-\end{center}
-\caption{Explicitly unspecified behavior}\label{fig:Underspecification}
-\endfig
+\figUnderspec
 
 The rules in figure~\ref{fig:Underspecification} cover aspects of the
 semantics that are explicitly unspecified. Implementations can replace
diff --git b/document/sort.tex a/document/sort.tex
index c2a9bf7..77d0938 100644
--- b/document/sort.tex
+++ a/document/sort.tex
@@ -57,7 +57,7 @@ algorithm may be unstable.  The procedure returns \unspecifiedreturn.
 
 \begin{scheme}
 (define v (vector 3 5 2 1))
-(vector-sort! v) \ev \theunspecified
+(vector-sort! < v) \ev \theunspecified
 v \ev \sharpsign(1 2 3 5)
 \end{scheme}
 \implresp The implementation must check the restrictions
diff --git b/document/struct.tex a/document/struct.tex
index 5f2326d..cb6cdce 100644
--- b/document/struct.tex
+++ a/document/struct.tex
@@ -562,10 +562,10 @@ The following top-level program obtains the first argument from the command line
 via the {\cf command-line} procedure from the \rsixlibrary{programs}
 library (see library chapter~\extref{lib:programlibchapter}{Command-line
   access and exit values}).  It then opens the file using {\cf
-  open-file-input-port} (see library section~\extref{lib:portsiosection}),
+  open-file-input-port} (see library section~\extref{lib:portsiosection}{Port I/O}),
 yielding a \textit{port}, i.e.\ a connection to the file as a data
-source, and calls the {\cf get-bytes-all} procedure to obtain the
-contents of the file as binary data.  It then uses {\cf put-bytes} to
+source, and calls the {\cf get-bytevector-all} procedure to obtain the
+contents of the file as binary data.  It then uses {\cf put-bytevector} to
 output the contents of the file to standard output:
 %
 \begin{scheme}
@@ -573,11 +573,13 @@ output the contents of the file to standard output:
 (import (rnrs base)
         (rnrs io ports)
         (rnrs programs))
-(put-bytes (standard-output-port)
-           (call-with-port
-               (open-file-input-port
-                 (cadr (command-line)))
-             get-bytes-all))%
+(let ((p (standard-output-port)))
+  (put-bytevector p
+                  (call-with-port
+                      (open-file-input-port
+                        (cadr (command-line)))
+                    get-bytevector-all))
+  (close-port p))%
 \end{scheme}
 
 %%% Local Variables: 
diff --git b/document/syntax-case.tex a/document/syntax-case.tex
index a184f2d..46928ed 100644
--- b/document/syntax-case.tex
+++ a/document/syntax-case.tex
@@ -120,8 +120,15 @@ substitution.
 Marks applied after a substitution, i.e., appear over the substitution in
 the wrap, are not relevant and are ignored.
 
-An algebra that defines how marks and substitutions work more precisely is
-given in section~2.4 of Oscar Waddell's PhD thesis~\cite{Waddellphd}.
+An algebra that defines how marks and substitutions work more
+precisely is given in section~2.4 of Oscar Waddell's PhD
+thesis~\cite{Waddellphd}.\footnote{Note, however, that Waddell's
+  thesis describes slightly different semantics for {\cf
+    bound-identifier=?}---it specifies that for two identifiers to be
+  equal in the sense of {\cf
+    bound-identifier=?}, they must have the same marks and be equal in
+  the sense of {\cf free-identifier=?}, whereas this report requires
+  instead that they must have the same marks and have the same name.}
 
 \section{Syntax objects}
 \label{syntaxobjectssection}
@@ -505,7 +512,7 @@ p.car \ev 4
         [\_  \#'(car p)]))))
 (set! p.car 15)
 p.car           \ev 15
-p               \ev (15 5)%
+p               \ev (15 . 5)%
 \end{scheme}
 
 \section{Identifier predicates}
@@ -792,7 +799,10 @@ Scheme form, as demonstrated by the following definition of
   (lambda (x)
     (define read-file
       (lambda (fn k)
-        (let ([p (open-file-input-port fn)])
+        (let ([p (open-file-input-port fn
+                    (file-options)
+                    (buffer-mode block)
+                    (native-transcoder))])
           (let f ([x (get-datum p)])
             (if (eof-object? x)
                 (begin (close-port p) '())
@@ -1067,20 +1077,21 @@ follows.
 
 \begin{schemenoindent}
 (define-syntax identifier-syntax
-  (syntax-rules (set!)
-    [(\_ e)
-     (lambda (x)
-       (syntax-case x ()
-         [id (identifier? \#'id) \#'e]
-         [(\_ x (... ...)) \#'(e x (... ...))]))]
-    [(\_ (id exp1) ((set! var val) exp2))
-     (and (identifier? \#'id) (identifier? \#'var))
-     (make-variable-transformer
-       (lambda (x)
-         (syntax-case x (set!)
-           [(set! var val) \#'exp2]
-           [(id x (... ...)) \#'(exp1 x (... ...))]
-           [id (identifier? \#'id) \#'exp1])))]))%
+  (lambda (x)
+    (syntax-case x (set!)
+      [(\_ e)
+       \#'(lambda (x)
+           (syntax-case x ()
+             [id (identifier? \#'id) \#'e]
+             [(\_ x (... ...)) \#'(e x (... ...))]))]
+      [(\_ (id exp1) ((set! var val) exp2))
+       (and (identifier? \#'id) (identifier? \#'var))
+       \#'(make-variable-transformer
+          (lambda (x)
+            (syntax-case x (set!)
+              [(set! var val) \#'exp2]
+              [(id x (... ...)) \#'(exp1 x (... ...))]
+              [id (identifier? \#'id) \#'exp1])))])))
 \end{schemenoindent}
 \end{note}
 
@@ -1118,10 +1129,8 @@ chapter~\ref{exceptionsconditionschapter}) has the following condition types:
 %
 \begin{itemize}
 \item If \var{who} is not \schfalse{} or can be inferred, the condition has condition type
-  {\cf \&who}, with \var{who} as the value of its field.  In
-  that case, \var{who} should identify the procedure or entity that
-  detected the exception.  If it is \schfalse, the condition does not
-  have condition type {\cf \&who}.
+  {\cf \&who}, with \var{who} as the value of its field.
+  Otherwise, the condition does not have condition type {\cf \&who}.
 \item The condition has condition type {\cf \&message}, with
   \var{message} as the value of its field.
 \item The condition has condition type {\cf \&syntax} 
diff --git b/document/tex-translate.ss a/document/tex-translate.ss
index 0b90334..dce10dd 100644
--- b/document/tex-translate.ss
+++ a/document/tex-translate.ss
@@ -62,7 +62,7 @@
         (fmatch exp
                 [`(module ,_ ,_ ,body ...)
                  (for-each loop body)]
-                [`(define ,lang (language ,productions ...))
+                [`(define-language ,lang ,productions ...)
                  (print-language productions)]
                 [`(metafunction-type ,name ,type)
                  (unless (member name metafunctions-to-skip) 
@@ -524,7 +524,31 @@
       [`(error string)           (format "\\textbf{error: } \\textit{error message}")]
       [`(unknown string)           (format "\\textbf{unknown: } \\textit{description}")]
       [`(uncaught-exception v)           (format "\\textbf{uncaught exception: } \\nt{v}")]
-      [_                         (do-pretty-format p)]))
+      [_                         (do-pretty-format
+                                  (remove-unique-side-conditions
+                                   p))]))
+  
+  (define (remove-unique-side-conditions p)
+    (let loop ([p p])
+      (match p
+        [`(side-condition ,pat (unique? ,arg))
+         (remove-underscores pat)]
+        [(? list?) (map loop p)]
+        [else p])))
+  
+  (define (remove-underscores pat)
+    (let loop ([pat pat])
+      (cond
+        [(symbol? pat)
+         (let ([str (symbol->string pat)])
+           (cond
+             [(regexp-match #rx"^([^_]*)_" str)
+              =>
+              (λ (m) (string->symbol (list-ref m 1)))]
+             [else
+              pat]))]
+        [(pair? pat) (cons (loop (car pat)) (loop (cdr pat)))]
+        [else pat])))
   
   (define (show-rewritten-nt lhs str) (display (string-append lhs " " str " " TEX-NEWLINE)))
   
diff --git b/document/tex2page a/document/tex2page
new file mode 100755
index 0000000..ee400e7
--- /dev/null
+++ a/document/tex2page
@@ -0,0 +1,10646 @@
+#!/bin/sh
+":";exec mzscheme -f $0 -m -- "$@"
+
+;tex2page
+;Dorai Sitaram
+
+(require mzlib/process)
+(require mzlib/date)
+(require mzlib/trace)
+(require racket/private/more-scheme)
+
+(define *tex2page-version* "20090915") ;last change
+
+(define *tex2page-website*
+  ;for details, please see
+  "http://evalwhen.com/tex2page/index.html")
+
+;some parameters that may hinge on user preference or
+;need.  I've tried to make it all automatic, with
+;reasonable defaults, but it may need some
+;personal tending
+
+(define *operating-system*
+  ;change if you need a better OS identifier
+  (if (getenv "COMSPEC")
+      (let ((term (getenv "TERM")))
+        (if (and (string? term) (string=? term "cygwin"))
+            ':cygwin ':windows))
+      ':unix))
+
+(define *enable-write-18?*
+  ;true if you want \write18{command} to execute command
+  ;as an OS command; false if you think that is a
+  ;security risk for your situation
+  #t)
+
+(define *output-extension*
+  ;some may want ".htm" here
+  ".html")
+
+(define *ghostscript*
+  ;the name of the Ghostscript executable.  You
+  ;may need to modify for Windows
+  (case *operating-system*
+    ((:windows) (or (ormap
+                    (lambda (f)
+                      (and (file-exists? f) f))
+                    '("c:\\cygwin\\bin\\gs.exe"
+                      "g:\\cygwin\\bin\\gs.exe"
+                      "c:\\aladdin\\gs6.01\\bin\\gswin32c.exe"
+                      "d:\\aladdin\\gs6.01\\bin\\gswin32c.exe"
+                      "d:\\gs\\gs8.00\\bin\\gswin32.exe"
+                      "g:\\gs\\gs8.00\\bin\\gswin32.exe"
+                      ))
+                   "gswin32.exe"))
+    (else "gs")))
+
+(define *use-closing-p-tag?*
+  ;false if you don't want closing </p>
+  #t)
+
+(define *metapost*
+  ;don't know why, but MetaPost is called mpost in
+  ;teTeX (all Unix TeXs?) and mp in MikTeX (all
+  ;Windows TeXs?)
+  (case *operating-system*
+    ((:windows) "mp")
+    (else "mpost")))
+
+(define *tex-prog-name* "tex")
+
+;change these navbar wordings to suit the natural language of your
+;document
+
+(define *navigation-sentence-begin* "Go to ")
+(define *navigation-first-name* "first")
+(define *navigation-previous-name* "previous")
+(define *navigation-next-name* "next")
+(define *navigation-page-name* " page")
+(define *navigation-contents-name* "contents")
+(define *navigation-index-name* "index")
+(define *navigation-sentence-end* "")
+
+(define *last-modified* "Last modified")
+(define *html-conversion-by* "HTML conversion by")
+
+;
+;change stuff below at your peril!  scmxlate will transform them
+;appropriately if needed
+;
+
+(define *doctype*
+  (string-append
+    "html public "
+    "\"-//W3C//DTD HTML 4.01 Transitional//EN\" "
+    "\"http://www.w3.org/TR/html4/loose.dtd\""))
+
+(define *scheme-version*
+  (string-append "MzScheme " (version)))
+
+(define *path-separator*
+  (if (eqv? *operating-system* ':windows) #\; #\:))
+
+(define *directory-separator*
+  (if (eqv? *operating-system* ':windows) "\\" "/"))
+
+;including a \bye from the tex command line.  Unix
+;needs to escape the backslash, Windows doesn't
+
+(define *bye-tex*
+  (case *operating-system*
+    ((:windows) " \\bye")
+    (else " \\\\bye")))
+
+(define *int-corresp-to-0* (char->integer #\0))
+
+(define *verbatim-visible-space*
+  ; "<span style=\"color: red\">&middot;</span>"
+  "<span style=\"vertical-align: -0.5ex\">&#x2334;</span>" )
+
+(define *aux-file-suffix* "-Z-A")
+(define *bib-aux-file-suffix* "-Z-B")
+(define *css-file-suffix* "-Z-S.css")
+(define *eval-file-suffix* "-Z-E-")
+(define *html-node-prefix* "node_")
+(define *html-page-suffix* "-Z-H-")
+(define *img-file-suffix* "-Z-G-")
+(define *imgdef-file-suffix* "D-")
+(define *index-file-suffix* "-Z-I")
+(define *label-file-suffix* "-Z-L")
+(define *mfpic-tex-file-suffix* ".Z-M-tex")
+(define *toc-file-suffix* "-Z-C")
+
+(define *ghostscript-options*
+  " -q -dBATCH -dNOPAUSE -dNO_PAUSE -sDEVICE=ppmraw")
+
+(define *invisible-space* (list ':*invisible-space*))
+
+(define *outer-invisible-space* (list ':*outer-invisible-space*))
+
+;January is 1 in PLT, MIT, CL; 0 in others
+(define *january-number* 1)
+
+;PLT, MIT, CL give true AD; others give AD - 1900
+(define *anno-domini-at-0* 0)
+
+(define *month-names*
+  (vector "January" "February" "March" "April" "May" "June"
+    "July" "August" "September" "October" "November" "December"))
+
+(define *if-aware-ctl-seqs*
+  '("\\csname" "\\else" "\\end" "\\eval" "\\fi" "\\let"))
+
+(define *tex-logo*
+  (string-append "T" "<span style=\""
+    "position: relative; "
+    "top: 0.5ex; "
+    "margin-left: -0.1667em; "
+    "margin-right: -0.125em; "
+    "text-transform: uppercase"
+    "\">e</span>" "X"))
+
+(define *filename-delims* '())
+
+(define *scm-token-delims*
+  (list #\( #\) #\[ #\] #\{ #\} #\' #\` #\" #\; #\, #\|))
+
+(define *tex-extra-letters* '()
+  ;(list #\@)
+  )
+
+(define *return* (integer->char 13))
+(define *tab* (integer->char 9))
+(define *epoch* 1970)
+
+;
+
+;above are true globals.  Following are
+;per-document globals
+
+(define *afterassignment* #f)
+(define *afterpar* '())
+(define *afterbye* '())
+(define *aux-dir* #f)
+(define *aux-dir/* "")
+(define *aux-port* #f)
+
+(define *bib-aux-port* #f)
+(define *bibitem-num* 0)
+
+(define *color-names* '())
+(define *comment-char* #\%)
+(define *css-port* #f)
+(define *current-source-file* #f)
+(define *current-tex2page-input* #f)
+
+(define *display-justification* #f)
+(define *dotted-counters* #f)
+(define *dumping-nontex?* #f)
+
+(define *equation-number* #f)
+(define *equation-numbered?* #t)
+(define *equation-position* 0)
+(define *esc-char* #\\ )
+(define *esc-char-std* #\\ )
+(define *esc-char-verb* #\|)
+(define *eval-file-count* 0)
+(define *eval-for-tex-only?* #f)
+(define *expand-escape?* #f)
+(define *external-label-tables* #f)
+
+(define *footnote-list* '())
+(define *footnote-sym* 0)
+
+(define *global-texframe* #f)
+(define *graphics-file-extensions* '())
+
+(define *html* (current-output-port))
+(define *html-head* #f)
+(define *html-only* 0)
+(define *html-page* #f)
+(define *html-page-count* #f)
+
+(define *ignore-timestamp?* #f)
+(define *ignore-active-space?* #f)
+;(define *img-magnification* 1)
+(define *img-file-count* 0)
+(define *img-file-tally* 0)
+(define *imgdef-file-count* 0)
+(define *imgpreamble* #f)
+(define *imgpreamble-inferred* #f)
+(define *in-alltt?* #f)
+(define *in-display-math?* #f)
+(define *in-para?* #f)
+(define *in-small-caps?* #f)
+(define *includeonly-list* #f)
+(define *index-page-mention-alist* #f)
+(define *index-table* #f)
+(define *index-count* #f)
+(define *index-page* #f)
+(define *index-port* #f)
+(define *infructuous-calls-to-tex2page* #f)
+(define *input-line-no* 0)
+(define *input-streams* #f)
+(define *inputting-boilerplate?* #f)
+(define *inside-appendix?* #f)
+(define *inside-eplain-verbatim?* #f)
+
+(define *jobname* "texput")
+
+(define *label-port* #f)
+;identifier *labels* is reserved in stklos!
+(define *label-source* #f)
+(define *label-table* #f)
+(define *last-modification-time* #f)
+(define *last-page-number* #f)
+(define *latex-probability* #f)
+(define *ligatures?* #f)
+(define *loading-external-labels?* #f)
+(define *log-file* #f)
+(define *log-port* #f)
+
+(define *main-tex-file* #f)
+(define *math-delim-left* #f)
+(define *math-delim-right* #f)
+(define *math-height* #f)
+(define *math-mode?* #f)
+(define *math-needs-image?* #f)
+(define *math-script-mode?* #f)
+(define *math-roman-mode?* #f)
+(define *mfpic-file-num* #f)
+(define *mfpic-file-stem* #f)
+(define *mfpic-port* #f)
+(define *missing-eps-files* #f)
+(define *missing-pieces* #f)
+(define *mp-files* #f)
+
+(define *not-processing?* #f)
+
+(define *outer?* #f)
+(define *output-streams* #f)
+(define *outputting-external-title?* #f)
+(define *outputting-to-non-html?* #f)
+
+(define *package* #f)
+
+(define *reading-control-sequence?* #f)
+(define *recent-node-name* #f)
+(define *remember-index-number* #f)
+
+(define *scm-builtins* #f)
+(define *scm-dribbling?* #f)
+
+(define *scm-special-symbols* #f)
+(define *scm-keywords* #f)
+
+(define *scm-variables* #f)
+(define *section-counters* #f)
+(define *section-counter-dependencies* #f)
+;(define *slatex-like-comments?* #f)
+(define *slatex-math-escape* #f)
+(define *source-changed-since-last-run?* #f)
+(define *stylesheets* #f)
+(define *subjobname* *jobname*)
+
+(define *tabular-stack* '())
+(define *temp* #f)
+(define *temp-string-count* #f)
+(define *temporarily-use-utf8-for-math?* #f)
+(define *tex2page-inputs* '())
+;(define *tex2page-flag-set?* #f)
+(define *tex-env* '())
+(define *tex-format* #f)
+(define *tex-if-stack* '())
+(define *tex-like-layout?* #f)
+(define *this-package* #f)
+(define *title* #f)
+(define *toc-list* #f)
+(define *toc-page* #f)
+
+(define *unresolved-xrefs* #f)
+(define *using-bibliography?* #f)
+(define *using-chapters?* #f)
+(define *using-index?* #f)
+
+(define *verb-display?* #f)
+(define *verb-port* #f)
+(define *verb-visible-space?* #f)
+(define *verb-written-files* '())
+
+(define *write-log-max* 55)
+(define *write-log-index* 0)
+(define *write-log-possible-break?* #f)
+
+;timely stuff
+
+(define strftime-like
+  (lambda (ignore-format d)
+    (string-append
+      (date->string d #t)
+      (let ((tz (getenv "TZ")))
+        (if tz (string-append " " tz) "")))))
+
+(define seconds->human-time
+  (lambda (s)
+    (strftime-like
+     "%a, %b %e, %Y, %l:%M %p %Z"
+      (seconds->date s))))
+
+(define nreverse reverse)
+(define nconc append)
+
+(define number->roman
+  ;adapted from CLISP's format impl
+  (lambda (n upcase?)
+    (unless (and (integer? n) (>= n 0))
+      (terror 'number->roman "Missing number"))
+    ;
+    (let ((roman-digits
+            ; decimal_value, roman_char, lower_decimal_value_used_to_modify
+            '((1000 #\m 100) (500 #\d 100) (100 #\c 10) (50 #\l 10)
+              (10 #\x 1) (5 #\v 1) (1 #\i 0)))
+          (approp-case (lambda (c)
+                         (if upcase? (char-upcase c) c))))
+      (let loop ((n n) (dd roman-digits) (s '()))
+        (if (null? dd)
+            (if (null? s) "0"
+                (list->string (nreverse s)))
+            (let* ((d (car dd))
+                   (val (car d))
+                   (char (approp-case (cadr d)))
+                   (nextval (caddr d)))
+              (let loop2 ((q (quotient n val))
+                          (r (remainder n val))
+                          (s s))
+                (if (= q 0)
+                    (if (>= r (- val nextval))
+                        (loop (remainder r nextval) (cdr dd)
+                          (cons char
+                            (cons (approp-case (cadr (assv nextval dd)))
+                              s)))
+                        (loop r (cdr dd) s))
+                    (loop2 (- q 1) r (cons char s))))))))))
+
+(define string-index
+  (lambda (s c)
+    ;returns the leftmost index of s where c occurs
+    ;
+    (let ((n (string-length s)))
+      (let loop ((i 0))
+        (cond ((>= i n) #f)
+              ((char=? (string-ref s i) c) i)
+              (else (loop (+ i 1))))))))
+
+(define string-reverse-index
+  (lambda (s c)
+    ;returns the rightmost index of s where c occurs
+    ;
+    (let loop ((i (- (string-length s) 1)))
+      (cond ((< i 0) #f)
+            ((char=? (string-ref s i) c) i)
+            (else (loop (- i 1)))))))
+
+(define substring?
+  (lambda (s1 s2)
+    ;if s1 is a substring of s2, returns the index in
+    ;s2 that s1 starts at.  O/w return #f.
+    ;
+    (let* ((s1-len (string-length s1))
+           (s2-len (string-length s2))
+           (n-give-up (+ 1 (- s2-len s1-len))))
+      (let loop ((i 0))
+        (if (< i n-give-up)
+            (let loop2 ((j 0) (k i))
+              (if (< j s1-len)
+                  (if (char=? (string-ref s1 j) (string-ref s2 k))
+                      (loop2 (+ j 1) (+ k 1))
+                      (loop (+ i 1)))
+                  i))
+            #f)))))
+
+;(defstruct structname [field | (field default-value)] ...)
+;
+;creates
+;the constructor make-structname
+;the predicate structname?
+;the accessors structname.field (for each field)
+;the setters set!structname.field (for each field)
+;
+;make-structname can take {field init-value} arguments,
+;in which it case it sets field to init-value.  Otherwise,
+;it sets field to default-value, if such was provided in
+;the defstruct call
+
+(define list-position
+  (lambda (x s)
+    (let loop ((s s) (i 0))
+      (cond ((null? s) #f)
+            ((eq? (car s) x) i)
+            (else (loop (cdr s) (+ i 1)))))))
+
+(define-syntax defstruct
+  (lambda (so)
+    (datum->syntax so
+      (let ((so-d (syntax->datum so)))
+        (let ((s (cadr so-d))
+              (ff (cddr so-d)))
+          (let ((s-s (symbol->string s)) (n (length ff)))
+            (let* ((n+1 (+ n 1))
+                   (vv (make-vector n+1)))
+              (let loop ((i 1) (ff ff))
+                (if (< i n+1)
+                    (let ((f (car ff)))
+                      (vector-set! vv i (if (pair? f) (cadr f)
+                                          ;would like void here
+                                          #f))
+                      (loop (+ i 1) (cdr ff))) #f))
+              (let ((ff (map (lambda (f) (if (pair? f) (car f) f)) ff)))
+                `(begin
+                   (define ,(string->symbol (string-append "make-" s-s))
+                     (lambda fvfv
+                       (let ((st (make-vector ,n+1)) (ff ',ff))
+                         (vector-set! st 0 ',s)
+                         ,@(let loop ((i 1) (r '()))
+                             (if (>= i n+1) r
+                                 (loop (+ i 1)
+                                       (cons `(vector-set! st ,i
+                                                          ,(vector-ref vv i))
+                                             r))))
+                         (let loop ((fvfv fvfv))
+                           (unless (null? fvfv)
+                             (vector-set! st (+ (list-position (car fvfv) ff) 1)
+                                          (cadr fvfv))
+                             (loop (cddr fvfv))))
+                         st)))
+                   ,@(let loop ((i 1) (procs '()))
+                       (if (>= i n+1) procs
+                           (loop (+ i 1)
+                                 (let ((f (symbol->string
+                                          (list-ref ff (- i 1)))))
+                                   (cons
+                                     `(define ,(string->symbol
+                                                 (string-append s-s "." f))
+                                        (lambda (x) (vector-ref x ,i)))
+                                     (cons
+                                       `(define ,(string->symbol
+                                                   (string-append
+                                                "set!" s-s "." f))
+                                          (lambda (x v) (vector-set! x ,i v)))
+                                       procs))))))
+                   (define ,(string->symbol (string-append s-s "?"))
+                     (lambda (x)
+                       (and (vector? x) (eq? (vector-ref x 0) ',s)))))))))))))
+
+(defstruct table (equ eqv?) (alist '()))
+
+(define table-get
+  (lambda (tbl k . d)
+    (cond ((lassoc k (table.alist tbl) (table.equ tbl))
+           => (lambda (c) (vector-ref (cdr c) 0)))
+          ((pair? d) (car d))
+          (else #f))))
+
+(define table-put!
+  (lambda (tbl k v)
+    (let ((al (table.alist tbl)))
+      (let ((c (lassoc k al (table.equ tbl))))
+        (if c (vector-set! (cdr c) 0 v)
+            (set!table.alist tbl (cons (cons k (vector v)) al)))))))
+
+(define table-for-each
+  (lambda (tbl p)
+    (for-each
+     (lambda (c)
+       (p (car c) (vector-ref (cdr c) 0)))
+     (table.alist tbl))))
+
+(define lassoc
+  (lambda (k al equ?)
+    (let loop ((al al))
+      (if (null? al) #f
+          (let ((c (car al)))
+            (if (equ? (car c) k) c
+                (loop (cdr al))))))))
+
+(define ldelete
+  (lambda (y xx equ?)
+    (let loop ((xx xx) (r '()))
+      (if (null? xx) (nreverse r)
+          (let ((x (car xx)))
+            (loop (cdr xx)
+              (if (equ? x y) r
+                  (cons x r))))))))
+
+(defstruct counter (value 0) (within #f))
+
+(defstruct tocentry level number page label header)
+
+(define string-trim-blanks
+  (lambda (s)
+    (let ((orig-n (string-length s)))
+      (let ((i 0) (n orig-n))
+        (let loop ((k i))
+          (cond ((>= k n) (set! i n))
+                ((char-whitespace? (string-ref s k))
+                 (loop (+ k 1)))
+                (else (set! i k))))
+        (let loop ((k (- n 1)))
+          (cond ((<= k i) (set! n (+ k 1)))
+                ((char-whitespace? (string-ref s k))
+                 (loop (- k 1)))
+                (else (set! n (+ k 1)))))
+        (if (and (= i 0) (= n orig-n)) s
+            (substring s i n))))))
+
+(define char-tex-alphabetic?
+  (lambda (c)
+    (or (char-alphabetic? c)
+        (ormap (lambda (d) (char=? c d))
+          *tex-extra-letters*))))
+
+(define gen-temp-string
+  (lambda ()
+    (set! *temp-string-count* (+ *temp-string-count* 1))
+    (string-append "Temp_"
+                   (number->string *temp-string-count*))))
+
+(define file-stem-name
+  (lambda (f)
+    ;chop off f's dirname and extension
+    (let ((slash (string-reverse-index f #\/)))
+      (when slash
+        (set! f (substring f (+ slash 1) (string-length f))))
+      (let ((dot (string-reverse-index f #\.)))
+        (if dot
+            (substring f 0 dot)
+            f)))))
+
+(define file-extension
+  (lambda (f)
+    ;returns filename f's extension, if any
+    (let ((slash (string-reverse-index f #\/))
+          (dot (string-reverse-index f #\.)))
+      (if (and dot (not (= dot 0))
+               (or (not slash) (< (+ slash 1) dot)))
+          (substring f dot (string-length f))
+          #f))))
+
+(define ensure-file-deleted
+  (lambda (f)
+    (when (file-exists? f) (delete-file f))))
+
+(define write-aux
+  (lambda (e)
+    (unless *aux-port*
+      (let ((f (string-append *aux-dir/* *jobname* *aux-file-suffix* ".scm")))
+        (ensure-file-deleted f)
+        (set! *aux-port* (open-output-file f))))
+    (write e *aux-port*)
+    (newline *aux-port*)))
+
+(define write-label
+  (lambda (e)
+    (unless *label-port*
+      (let ((f (string-append *aux-dir/* *jobname* *label-file-suffix* ".scm")))
+        (ensure-file-deleted f)
+        (set! *label-port* (open-output-file f))))
+    (write e *label-port*)
+    (newline *label-port*)))
+
+(define write-bib-aux
+  (lambda (x)
+    (unless *bib-aux-port*
+      (let ((f (string-append *aux-dir/* *jobname* *bib-aux-file-suffix* ".aux")))
+        (ensure-file-deleted f)
+        (set! *bib-aux-port* (open-output-file f))))
+    (display x *bib-aux-port*)))
+
+(define write-log
+  (lambda (x)
+    (unless *log-port*
+      (set! *log-file* (string-append *aux-dir/* *jobname* ".hlog"))
+      (ensure-file-deleted *log-file*)
+      (set! *log-port* (open-output-file *log-file*)))
+    (when (and *write-log-possible-break?* (char? x)
+               (ormap (lambda (c) (char=? x c))
+                      ; #\( #\[ #\{
+                      '(#\) #\] #\} #\,)))
+      ;disallow breaks before rt-paren-like chars
+      (set! *write-log-possible-break?* #f))
+    (when (and *write-log-possible-break?*
+               (> *write-log-index* *write-log-max*))
+      ;if current line is too long, start a new one,
+      (newline *log-port*)
+      (newline)
+      (set! *write-log-possible-break?* #f)
+      (set! *write-log-index* 0))
+    (unless (and (= *write-log-index* 0)
+                 (or (eqv? x ':separation-newline)
+                     (eqv? x ':separation-space)))
+      (case x
+        ((#\newline :separation-newline)
+         (when *write-log-possible-break?*
+           (set! *write-log-possible-break?* #f))
+         (newline *log-port*) (newline)
+         (set! *write-log-index* 0))
+        ((:separation-space)
+         (set! *write-log-possible-break?* #t))
+        (else
+         (when *write-log-possible-break?*
+           (write-char #\space *log-port*)
+           (write-char #\space)
+           (set! *write-log-index* (+ *write-log-index* 1))
+           (set! *write-log-possible-break?* #f))
+         (display x *log-port*)
+         (display x)
+         (flush-output)
+         (set! *write-log-index*
+           (+ *write-log-index*
+              (cond ((char? x) 1)
+                    ((number? x) (string-length (number->string x)))
+                    ((string? x) (string-length x))
+                    (else 1)))))))))
+
+(define display-error-context-lines
+  (lambda ()
+    (let ((n (or (find-count "\\errorcontextlines") 0)))
+      (when (and ;*input-line-no*
+              *current-source-file* (> n 0))
+        (let* ((n1 (max 0 (- *input-line-no* (quotient (- n 1) 2))))
+               (nf (+ n1 n -1))
+               (ll (call-with-input-file *current-source-file*
+                     (lambda (ip)
+                       (let loop ((i 1) (ll '()))
+                         (let ((L (read-line ip)))
+                           (cond ((eof-object? L) ll)
+                                 ((< i n1) (loop (+ i 1) ll))
+                                 ((<= i nf) (loop (+ i 1)
+                                                  (cons (cons i L) ll)))
+                                 (else ll))))))))
+          (unless (null? ll)
+            (let* ((border "__________________________...")
+                   (only-1? (= (length ll) 1))
+                   (nf (caar ll))
+                   (ll (nreverse ll))
+                   (n1 (caar ll)))
+              (write-log "Likely error context: ")
+              (write-log *current-source-file*)
+              (write-log ", line")
+              (unless only-1? (write-log "s"))
+              (write-log " ")
+              (write-log n1)
+              (unless only-1?
+                (write-log "-")
+                (write-log nf))
+              (write-log ":")
+              (write-log #\newline)
+              (write-log " /")
+              (write-log border)
+              (write-log #\newline)
+              (for-each
+               (lambda (L)
+                 (write-log " | ")
+                 (write-log (cdr L))
+                 (write-log #\newline))
+               ll)
+              (write-log " |")
+              (write-log border)
+              (write-log #\newline)
+              (write-log "/")
+              )))))))
+
+(define terror
+  (lambda (where . args)
+    (write-log ':separation-newline)
+    (write-log "! ")
+    (for-each write-log args)
+    (write-log ':separation-newline)
+    (write-log "l.")
+    (write-log *input-line-no*)
+    (write-log #\space)
+    (write-log where)
+    (write-log " failed.")
+    (write-log ':separation-newline)
+    (display-error-context-lines)
+    (close-all-open-ports)
+    (output-stats)
+    ;(display "*** TeX2page fatal error! ***")
+    ;(newline)
+    (display "Type e to edit file at point of error; x to quit.")
+    (newline)
+    (display "? ")
+    (flush-output)
+    (let ((c (read-char)))
+      (when (and (not (eof-object? c))
+                 (char-ci=? c #\e))
+        (edit-offending-file)))
+    (error "TeX2page fatal error")))
+
+(define edit-offending-file
+  (lambda ()
+    (let ((bad-texedit? #f)
+          (cmd #f))
+      (cond ((getenv "TEXEDIT")
+             => (lambda (s)
+                  (cond ((substring? "%d" s)
+                         => (lambda (i)
+                              (set! s
+                                (string-append (substring s 0 i)
+                                               (number->string *input-line-no*)
+                                               (substring s (+ i 2)
+                                                          (string-length s))))))
+                        (else (set! bad-texedit? #t)))
+                  (cond ((and (not bad-texedit?)
+                              (substring? "%s" s))
+                         => (lambda (i)
+                              (set! s
+                                (string-append (substring s 0 i)
+                                               *current-source-file*
+                                               (substring s (+ i 2)
+                                                          (string-length s))))))
+                        (else (set! bad-texedit? #t)))
+                  (cond (bad-texedit?
+                          (display "Bad TEXEDIT; using EDITOR.") (newline))
+                        (else (set! cmd s))))))
+      (cond ((and (not cmd) (or (getenv "EDITOR") "vi"))
+             => (lambda (s)
+                  (set! cmd
+                    (string-append
+                      s " +" (number->string *input-line-no*)
+                      " " *current-source-file*)))))
+      (when cmd
+        (system cmd)))))
+
+(define trace-if
+  (lambda (write? . args)
+    (when write?
+      (write-log ':separation-newline)
+      (when (> *input-line-no* 0)
+        (write-log "l.")
+        (write-log *input-line-no*)
+        (write-log #\space))
+      (for-each write-log args)
+      (write-log ':separation-newline))))
+
+(define do-errmessage
+  (lambda ()
+    (write-log ':separation-newline)
+    (write-log "! ")
+    (write-log
+      (tex-string->html-string (get-group)))
+    (write-log ':separation-newline)
+    (terror "\\errmessage")))
+
+(define do-tracingall
+  (lambda ()
+    (tex-def-count "\\tracingcommands" 1 #f)
+    (tex-def-count "\\tracingmacros" 1 #f)))
+
+;Input port buffers
+
+(defstruct bport (port #f) (buffer '()))
+
+(define call-with-input-file/buffered
+  (lambda (f th)
+    (unless (file-exists? f)
+      (terror 'call-with-input-file/buffered
+        "I can't find file " f))
+    (call-with-input-file f
+      (lambda (i)
+        (fluid-let ((*current-tex2page-input* (make-bport 'port i))
+                    (*current-source-file* f)
+                    (*input-line-no* 1))
+          (th))))))
+
+(define call-with-input-string/buffered
+  (lambda (s th)
+    (fluid-let ((*current-tex2page-input*
+                  (make-bport 'buffer (string->list s)))
+                (*input-line-no* *input-line-no*))
+      (th))))
+
+;  (define call-with-input-string
+;  (lambda (s p)
+;    (let* ((i (open-input-string s))
+;           (r (p i)))
+;      (close-input-port i)
+;      r)))
+
+(define eval1 eval)
+
+;tex2page's in & out
+
+(define snoop-char
+  (lambda ()
+    (let ((c (get-char)))
+      (toss-back-char c)
+      c)))
+
+(define get-char
+  (lambda ()
+    (let ((b (bport.buffer *current-tex2page-input*)))
+      (if (null? b)
+          (let ((p (bport.port *current-tex2page-input*)))
+            (if (not p) eof
+                (let ((c (read-char p)))
+                  (cond ((eof-object? c) c)
+                        ((char=? c #\newline)
+                         (set! *input-line-no* (+ *input-line-no* 1))
+                         c)
+                        (else c)))))
+          (let ((c (car b)))
+            (set!bport.buffer *current-tex2page-input* (cdr b))
+            c)))))
+
+(define toss-back-string
+  (lambda (s)
+    (set!bport.buffer *current-tex2page-input*
+      (nconc (string->list s) (bport.buffer *current-tex2page-input*)))))
+
+(define toss-back-char
+  (lambda (c)
+    (set!bport.buffer *current-tex2page-input*
+      (cons c (bport.buffer *current-tex2page-input*)))))
+
+(define emit
+  (lambda (s)
+    (display s *html*)))
+
+(define emit-newline
+  (lambda ()
+    ;(when *verb-display?* (emit "&nbsp;"))
+    (newline *html*)))
+
+;
+
+(define invisible-space?
+  (lambda (x)
+    (or (eq? x *invisible-space*)
+        (eq? x *outer-invisible-space*))))
+
+(define outer-invisible-space?
+  (lambda (c)
+    (eq c *outer-invisible-space*)))
+
+(define check-outerness
+  (lambda (c)
+    (when (eq? c *outer-invisible-space*)
+      (set! *outer?* #t))))
+
+(define snoop-actual-char
+  (lambda ()
+    (let ((c (snoop-char)))
+      (cond ((eof-object? c) c)
+            ((invisible-space? c) (get-char)
+                                  (check-outerness c)
+             (snoop-actual-char))
+            ((char=? c *return*) (get-char)
+             (let ((c (snoop-actual-char)))
+               (if (and (not (eof-object? c)) (char=? c #\newline))
+                   c
+                   (begin (toss-back-char #\newline) #\newline))))
+            (else c)))))
+
+(define get-actual-char
+  (lambda ()
+    (let ((c (get-char)))
+      (cond ((eof-object? c) c)
+            ((invisible-space? c)
+             (check-outerness c) (get-actual-char))
+            ((char=? c *return*)
+             (let ((c (snoop-actual-char)))
+               (if (and (not (eof-object? c)) (char=? c #\newline))
+                   (get-actual-char)
+                   #\newline)))
+            (else c)))))
+
+(define get-line
+  (lambda ()
+    (let loop ((r '()))
+      (let ((c (get-actual-char)))
+        (cond ((eof-object? c)
+               (if (null? r) c (list->string (nreverse r))))
+              ((char=? c #\newline)
+               (list->string (nreverse r)))
+              ;((and (char-whitespace? c)
+              ;      (let ((c2 (snoop-actual-char)))
+              ;        (or (eof-object? c2) (char=? c2 #\newline))))
+              ; (get-actual-char)
+              ; (list->string (nreverse r)))
+              (else (loop (cons c r))))))))
+
+;tex2page
+
+;the eating of white space
+
+(define ignorespaces
+  ;this is like TeX's \ignorespaces, which
+  ;goes past at most one newline
+  (lambda ()
+    (unless (and (find-chardef #\space)
+                 (not *ignore-active-space?*))
+      (let ((newline-active? (find-chardef #\newline))
+            (newline-already-read? #f))
+        (let loop ()
+          (let ((c (snoop-char)))
+            (when (eqv? c *return*) (set! c (snoop-actual-char)))
+            (cond ((eof-object? c) #t)
+                  ((invisible-space? c)
+                   (get-char)
+                   (unless *reading-control-sequence?*
+                     (loop)))
+                  ((char=? c #\newline)
+                   (cond (newline-active? #t)
+                         (newline-already-read?
+                           (toss-back-char #\newline))
+                         (else (get-actual-char)
+                               (set! newline-already-read? #t)
+                               (loop))))
+                  ((char-whitespace? c) ;space, tab
+                   (get-actual-char) (loop))
+                  (else #t))))))))
+
+(define ignore-all-whitespace
+  (lambda ()
+    (let loop ()
+      (let ((c (snoop-actual-char)))
+        (unless (eof-object? c)
+          (when (char-whitespace? c)
+            (get-actual-char) (loop)))))))
+
+(define munch-newlines
+  (lambda ()
+    (let loop ((n 0))
+      (let ((c (snoop-actual-char)))
+        (cond ((eof-object? c) n)
+              ((char=? c #\newline) (get-actual-char) (loop (+ n 1)))
+              ((char-whitespace? c) (get-actual-char) (loop n))
+              (else n))))))
+
+(define munched-a-newline?
+  (lambda ()
+    (let loop ()
+      (let ((c (snoop-actual-char)))
+        (cond ((eof-object? c) #f)
+              ((char=? c #\newline)
+               (get-actual-char) #t)
+              ((char-whitespace? c)
+               (get-actual-char) (loop))
+              (else #f))))))
+
+(define do-xspace
+  (lambda ()
+    (let ((c (snoop-actual-char)))
+      (unless
+       (memv c '(#\space #\" #\. #\! #\, #\:
+                          #\; #\? #\/ #\' #\) #\-))
+        (emit #\space)))))
+
+(define do-relax
+  (lambda () #t))
+
+;
+
+(define get-ctl-seq
+  (lambda ()
+    ;read a tex \controlsequence
+    ;(ignorespaces)
+    (let ((bs (get-actual-char)))
+      (unless (char=? bs *esc-char*)
+        (terror 'get-ctl-seq "Missing control sequence (" bs ")")))
+    (let ((c (get-char)))
+      (cond ((eof-object? c) "\\ ")
+            ((invisible-space? c) "\\ ")
+            ((char-tex-alphabetic? c)
+             (list->string
+              (nreverse
+               (let loop ((s (list c #\\ )))
+                 (let ((c (snoop-char)))
+                   (cond ((eof-object? c) s)
+                         ((invisible-space? c) s)
+                         ((char-tex-alphabetic? c) (get-char)
+                          (loop (cons c s)))
+                         (else
+                          (unless (or ;*in-verb?*
+                                      *math-mode?*
+                                      *not-processing?*
+                                      (eq? *tex-format* ':texinfo)
+                                      )
+                            (fluid-let ((*reading-control-sequence?* #t))
+                              (ignorespaces))
+                            )
+                          s)))))))
+            (else (string #\\ c))))))
+
+(define ctl-seq?
+  (lambda (z)
+    (char=? (string-ref z 0) #\\ )))
+
+(define if-aware-ctl-seq?
+  (lambda (z)
+    (or (ormap (lambda (y) (string=? z y))
+                 *if-aware-ctl-seqs*)
+        (and (>= (string-length z) 3)
+             (char=? (string-ref z 1) #\i)
+             (char=? (string-ref z 2) #\f))
+       (let ((z-th (find-corresp-prim-thunk z)))
+          (if (string? z-th) #f
+              (ormap
+               (lambda (y)
+                 (eq? z-th (find-corresp-prim-thunk y)))
+                 *if-aware-ctl-seqs*))))))
+
+(define get-group-as-reversed-chars
+  (lambda ()
+    ;read a {TeX group}
+    (ignorespaces)
+    (let ((c (get-actual-char)))
+      (when (eof-object? c) (terror 'get-group "Runaway argument?"))
+      (unless (char=? c #\{) (terror 'get-group "Missing {"))
+       (let loop ((s (list c)) (nesting 0) (escape? #f))
+         (let ((c (get-actual-char)))
+           (when (eof-object? c) (terror 'get-group "Runaway argument?"))
+           (cond (escape?
+                  (loop (cons c s) nesting #f))
+                 ((char=? c *esc-char*)
+                  (if *expand-escape?*
+                      (let ((s1
+                              (begin (toss-back-char c)
+                                     (let ((x (fluid-let ((*not-processing?* #t))
+                                                (get-ctl-seq))))
+                                       (cond ((ormap (lambda (z) (string=? x z))
+                                                     '("\\ " "\\{" "\\}"))
+                                              (string (string-ref x 1)))
+                                             (else
+                                               (fluid-let ((*esc-char* *esc-char-std*))
+                                                 (tex-string->html-string x))))))))
+                        (loop (nconc (nreverse (string->list s1)) s)
+                              nesting #f))
+                      (loop (cons c s) nesting #t)))
+                 ((char=? c #\{)
+                  (loop (cons c s) (+ nesting 1) #f))
+                 ((char=? c #\})
+                  (if (= nesting 0) (cons c s)
+                      (loop (cons c s) (- nesting 1) #f)))
+                 (else
+                  (loop (cons c s) nesting #f))))))))
+
+(define get-group
+  (lambda ()
+    (list->string (nreverse (get-group-as-reversed-chars)))))
+
+(define get-peeled-group
+  (lambda ()
+    (string-trim-blanks
+     (ungroup (get-group)))))
+
+(define get-token-or-peeled-group
+  (lambda ()
+    (string-trim-blanks
+     (ungroup (get-token)))))
+
+(define get-grouped-environment-name-if-any
+  (lambda ()
+    ;read {environmentname}, if it's there
+    (let ((c (snoop-actual-char)))
+      (if (or (eof-object? c) (not (char=? c #\{))) #f
+          (begin (get-actual-char)
+            (let loop ((s '()))
+              (let ((c (snoop-actual-char)))
+                (cond ((or (char-alphabetic? c) (char=? c #\*))
+                       (get-actual-char)
+                       (loop (cons c s)))
+                      ((and (pair? s) (char=? c #\})) (get-actual-char)
+                       (list->string (nreverse s)))
+                      (else (for-each toss-back-char s)
+                        (toss-back-char #\{)
+                        #f)))))))))
+
+(define get-bracketed-text-if-any
+  (lambda ()
+    ;read [bracketed text], if it's there
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (if (or (eof-object? c) (not (char=? c #\[))) #f
+          (begin
+            (get-actual-char)
+            (list->string
+              (nreverse
+                (let loop ((s '()) (nesting 0) (escape? #f))
+                  (let ((c (get-actual-char)))
+                    (when (eof-object? c)
+                      (terror 'get-bracketed-text-if-any
+                        "Runaway argument?"))
+                    (cond (escape?
+                            (loop (cons c s) nesting #f))
+                          ((char=? c *esc-char*)
+                           (loop (cons c s) nesting #t))
+                          ((char=? c #\{)
+                           (loop (cons c s) (+ nesting 1) #f))
+                          ((char=? c #\})
+                           (loop (cons c s) (- nesting 1) #f))
+                          ((char=? c #\])
+                           (if (= nesting 0) s
+                               (loop (cons c s) nesting #f)))
+                          (else
+                            (loop (cons c s) nesting #f))))))))))))
+
+(define ungroup
+  (lambda (s)
+    (let* ((n (string-length s))
+           (n-1 (- n 1)))
+      (if (or (< n 2)
+              (not (char=? (string-ref s 0) #\{))
+              (not (char=? (string-ref s n-1) #\})))
+          s
+          (substring s 1 n-1)))))
+
+(define eat-alphanumeric-string
+  (lambda ()
+    (ignorespaces)
+    (let loop ()
+      (let ((c (snoop-actual-char)))
+        (when (or (char-alphabetic? c)
+                  (char-numeric? c))
+          (get-actual-char)
+          (loop))))))
+
+(define get-filename
+  (lambda (braced?)
+    ;read a filename
+    (ignorespaces)
+    (when braced?
+      (let ((c (snoop-actual-char)))
+        (if (and (char? c) (char=? c #\{))
+            (get-actual-char)
+            (set! braced? #f))))
+    (list->string
+     (nreverse
+      (let loop ((s '()))
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c) s)
+                ((and (not braced?)
+                      (or (char-whitespace? c)
+                          (and *comment-char* (char=? c *comment-char*))
+                          (ormap (lambda (d) (char=? c d)) *filename-delims*)))
+                 (unless *not-processing?* (ignorespaces))
+                 s)
+                ((and braced? (char=? c #\}))
+                 (get-actual-char) s)
+                ((and *esc-char* (char=? c *esc-char*))
+                 (let ((x (get-ctl-seq)))
+                   (if (string=? x "\\jobname")
+                       (loop (nconc (nreverse (string->list *jobname*)) s))
+                       (begin
+                        (toss-back-char *invisible-space*)
+                        (toss-back-string x)
+                        s))))
+                (else (get-actual-char)
+                      (loop (cons c s))))))))))
+
+(define get-plain-filename
+  (lambda ()
+    (get-filename #f)))
+
+(define get-filename-possibly-braced
+  (lambda ()
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (get-filename
+       (and (char? c) (char=? c #\{))))))
+
+(define get-integer
+  (lambda (base)
+    ;base = 8, 10 or 16
+    (ignorespaces)
+    (string->number
+      (list->string
+        (nreverse
+          (let loop ((s '()))
+            (let ((c (snoop-actual-char)))
+              (cond ((eof-object? c) s)
+                    ((or (char-numeric? c)
+                         (and (= base 16) (char-alphabetic? c)))
+                     (get-actual-char)
+                     (loop (cons c s)))
+                    (else (ignorespaces)
+                      s)))))) base)))
+
+(define get-real
+  (lambda ()
+    (ignorespaces)
+    (let ((minus? #f)
+          (c (snoop-actual-char)))
+      (when (char=? c #\-) (set! minus? #t))
+      (when (or minus? (char=? c #\+))
+        (get-actual-char))
+      (let ((n (string->number
+                (list->string
+                 (nreverse
+                  (let loop ((s '()))
+                    (let ((c (snoop-actual-char)))
+                      (cond ((eof-object? c) s)
+                            ((or (char-numeric? c) (char=? c #\.))
+                             (get-actual-char)
+                             (loop (cons c s)))
+                            (else (ignorespaces)
+                                  s)))))))))
+        (if minus? (- n) n)))))
+
+(define get-equal-sign
+  (lambda ()
+    (ignorespaces)
+    (when (char=? (snoop-actual-char) #\=)
+      (get-actual-char))))
+
+(define get-by
+  (lambda ()
+    (ignorespaces)
+    (when (char=? (snoop-actual-char) #\b)
+      (get-actual-char)
+      (if (char=? (snoop-actual-char) #\y)
+          (get-actual-char)
+          (toss-back-char #\b)))))
+
+(define get-to
+  (lambda ()
+    (ignorespaces)
+    (when (char=? (snoop-actual-char) #\t)
+      (get-actual-char)
+      (cond ((char=? (snoop-actual-char) #\o)
+             (get-actual-char)
+             (ignorespaces))
+            (else
+             (toss-back-char #\t))))))
+
+(define get-number-corresp-to-ctl-seq
+  (lambda (x)
+    (cond ((string=? x "\\the")
+           ;(cadr (find-count (get-ctl-seq)))
+           (get-number-corresp-to-ctl-seq (get-ctl-seq))
+           )
+          ((string=? x "\\active") 13)
+          ((string=? x "\\pageno") *html-page-count*)
+          ((string=? x "\\inputlineno") *input-line-no*)
+          ((string=? x "\\footnotenumber")
+           (get-gcount "\\footnotenumber"))
+          ((string=? x "\\figurenumber")
+           (counter.value (table-get *dotted-counters* "figure")))
+          ((string=? x "\\sectiondnumber")
+           (table-get *section-counters*
+                      (string->number
+                       (ungroup (get-token))) 0))
+          ((find-count x))
+          ((find-dimen x))
+          (else
+           (or (string->number (or (resolve-defs x) x))
+              ; (terror 'get-number-corresp-to-ctl-seq "Missing number")
+               )
+           ))))
+
+(define get-number-or-false
+  (lambda ()
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (cond ((char=? c *esc-char*)
+             (get-number-corresp-to-ctl-seq (get-ctl-seq)))
+            ((char=? c #\') (get-actual-char)
+             (get-integer 8))
+            ((char=? c #\") (get-actual-char)
+             (get-integer 16))
+            ((char=? c #\`) (get-actual-char) (ignorespaces)
+             (char->integer
+               (if (char=? (snoop-actual-char) *esc-char*)
+                   (string-ref (get-ctl-seq) 1)
+                   (get-actual-char))))
+            ((char=? c #\+) (get-actual-char)
+             (get-number-or-false))
+            ((char=? c #\-) (get-actual-char)
+             (let ((n (get-number-or-false)))
+               (and n (- n))))
+            ((char-numeric? c) (get-integer 10))
+            (else #f)))))
+
+(define get-number
+  (lambda ()
+    (or (get-number-or-false)
+        (terror 'get-number "Missing number."))))
+
+(define get-tex-char-spec
+  (lambda ()
+    (cond ((get-number-or-false)
+           => integer->char)
+          (else (terror 'get-tex-char-spec "not a char")))))
+
+(define get-url
+  (lambda ()
+    ;read a {URL}
+    (ignorespaces)
+    (let ((c (get-actual-char)))
+      (cond ((eof-object? c) (terror 'get-url "Missing {"))
+            ((not (char=? c #\{)) (terror 'get-url "Missing {")))
+      (string-trim-blanks
+       (list->string
+        (nreverse
+         (let loop ((nesting 0) (s '()))
+           (let ((c (get-actual-char)))
+             (cond ((eof-object? c)
+                    (terror 'get-url "Missing }"))
+                   ((and *comment-char* (char=? c *comment-char*))
+                    (let ((c1 (snoop-actual-char)))
+                      (loop nesting
+                            (if (and (char? c1) (char-whitespace? c1))
+                                (begin (ignore-all-whitespace) s)
+                                (cons c s)))))
+                   ((char=? c #\{)
+                    (loop (+ nesting 1) (cons c s)))
+                   ((char=? c #\})
+                    (if (= nesting 0) s
+                        (loop (- nesting 1) (cons c s))))
+                   (else (loop nesting (cons c s))))))))))))
+
+(define get-csv
+  ;csv == comma-separated value
+  (lambda ()
+    (ignorespaces)
+    (let ((rev-lbl
+            (let loop ((s '()) (nesting 0))
+              (let ((c (get-actual-char)))
+                (cond ((eof-object? c)
+                       (terror 'get-csv
+                         "Runaway argument of \\cite, "
+                         "\\nocite, \\expandhtmlindex?")
+                       s)
+                      ((and (char=? c #\,) (= nesting 0))
+                       s)
+                      ((char=? c #\{)
+                       (loop (cons c s)
+                         (+ nesting 1)))
+                      ((char=? c #\})
+                       (if (= nesting 0)
+                           (begin (toss-back-char c) s)
+                           (loop (cons c s)
+                             (- nesting 1))))
+                      (else
+                        (loop (cons c s) nesting)))))))
+      (if (null? rev-lbl) #f
+          (list->string (nreverse rev-lbl))))))
+
+;procs for reading TeX tokens.  Token isn't really the
+;right name.  It's more like a TeX sexpr (texpr?),
+;ie, anything that is treated as a single item by
+;a macro looking for an arg
+
+(define get-raw-token
+  (lambda ()
+    ;gets a raw char (incl space, brace, %) or a ctl seq
+    (let ((c (snoop-actual-char)))
+      (cond ((eof-object? c) c)
+            ((char=? c *esc-char*)
+             (fluid-let ((*not-processing?* #t))
+               (get-ctl-seq)))
+            ;((and *comment-char* (char=? c *comment-char*))
+            ; (eat-till-eol) (get-raw-token))
+            (else (string (get-actual-char)))))))
+
+;(trace get-raw-token)
+
+(define get-raw-token/is
+  (lambda ()
+    ;like above, but ignore space
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (cond ((eof-object? c) c)
+            ((char=? c *esc-char*) (get-ctl-seq))
+            ((and *comment-char* (char=? c *comment-char*))
+             (eat-till-eol) (get-raw-token/is))
+            (else (string (get-actual-char)))))))
+
+;(trace get-raw-token/is)
+
+(define get-token
+  (lambda ()
+    ;like above, but treats groups as a single entity
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (cond ((eof-object? c) c)
+            ((char=? c *esc-char*) (get-ctl-seq))
+            ((char=? c #\{) (get-group))
+            ((and *comment-char* (char=? c *comment-char*))
+             (eat-till-eol) (get-token))
+            (else (string (get-actual-char)))))))
+
+(define eat-word
+  (lambda (word)
+    (ignorespaces)
+    (let ((n (string-length word)))
+      (let loop ((i 0) (r '()))
+        (if (>= i n) #t
+            (let ((c (snoop-actual-char)))
+              (cond ((char=? c (string-ref word i))
+                     (get-actual-char) (loop (+ i 1) (cons c r)))
+                    (else
+                     (for-each toss-back-char r)
+                     #f))))))))
+
+(define eat-skip-fluff
+  (lambda (full?)
+    (let ((go-ahead? #t))
+      (cond (full? (get-equal-sign))
+            ((ormap eat-word '("plus" "minus")) #t)
+            (else (set! go-ahead? #f)))
+      (when go-ahead?
+        (fluid-let ((*not-processing?* #t))
+          (let loop ((first? full?))
+            (ignorespaces)
+            (let ((c (snoop-actual-char)))
+              (cond ((eof-object? c) 'done)
+                    ((and (char=? c *esc-char*) first?)
+                     (get-ctl-seq))
+                    ((or (char-numeric? c) (char=? c #\.))
+                     (get-real) (loop first?))
+                    ((or (char=? c #\') (char=? c #\" ))
+                     (get-number) (loop first?))
+                    ((ormap eat-word '("+" "-"))
+                     (loop first?))
+                    ((ormap eat-word
+                            '("bp" "cc" "cm" "dd" "em" "ex" "filll"
+                              "fill" "fil" "in" "minus" "mm"
+                              "pc" "plus" "pt" "sp" "true"))
+                     (loop #f))
+                    (else 'done)))))))))
+
+(define eat-dimen
+  (lambda ()
+    (eat-skip-fluff #t)))
+
+(define eat-integer
+  (lambda ()
+    (fluid-let ((*not-processing?* #t))
+      (ignorespaces)
+      (get-equal-sign)
+      (get-number))))
+
+(define scm-get-token
+  (lambda ()
+    (list->string
+      (nreverse
+        (let loop ((s '()) (esc? #f))
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c) s)
+                  (esc? (get-actual-char)
+                    (loop (cons c s) #f))
+                  ((char=? c #\\ ) (get-actual-char)
+                   (loop (cons c s) #t))
+                  ((or (char-whitespace? c) (memv c *scm-token-delims*))
+                   s)
+                  (else (get-actual-char) (loop (cons c s) #f)))))))))
+
+;
+
+(define emit-html-char
+  (lambda (c)
+    ;display the html equiv of char c
+    (unless (eof-object? c)
+      (cond ((char=? c #\newline) (emit-newline))
+            (*outputting-to-non-html?* (emit c))
+            (else
+             (case c
+               ((#\<) (emit "&lt;"))
+               ((#\>) (emit "&gt;"))
+               ((#\") (emit "&quot;"))
+               ((#\&) (emit "&amp;"))
+               (else (emit c))))))))
+
+(define emit-html-string
+  (lambda (s)
+    (let ((n (string-length s)))
+      (let loop ((i 0))
+        (unless (>= i n)
+          (emit-html-char (string-ref s i))
+          (loop (+ i 1)))))))
+
+(define member/string-ci=?
+  (lambda (s ss)
+    (ormap (lambda (x)
+             (string-ci=? x s))
+      ss)))
+
+;Groups
+
+(defstruct texframe
+  (definitions (make-table 'equ string=?))
+  (chardefinitions (make-table))
+  (counts (make-table 'equ string=?))
+  (toks (make-table 'equ string=?))
+  (dimens (make-table 'equ string=?))
+  (postludes '())
+  (aftergroups '()))
+
+(define *primitive-texframe* (make-texframe))
+(define *math-primitive-texframe* (make-texframe))
+
+(define bgroup
+  (lambda ()
+    (set! *tex-env* (cons (make-texframe) *tex-env*))
+    (when (and *in-display-math?* (not *math-script-mode?*))
+      (bgroup-math-hook))))
+
+(define bgroup-math-hook
+  (lambda ()
+    (let ((old-html *html*)
+          (old-math-delim-left *math-delim-left*)
+          (old-math-delim-right *math-delim-right*)
+          (old-math-height *math-height*))
+      (set! *html* (open-output-string))
+      (set! *math-delim-left* #f)
+      (set! *math-delim-right* #f)
+      (set! *math-height* 0)
+      (set! *tabular-stack* (cons ':mathbox *tabular-stack*))
+      (add-postlude-to-top-frame
+       (lambda ()
+         (let ((res
+                (string-append
+                 "<table><tr><td align=center>"
+                 (get-output-string *html*)
+                 "</td></tr></table>")))
+           (when (or *math-delim-left* *math-delim-right*)
+             (when (and (or (member *math-delim-left* '(:lbrace :rbrace))
+                            (member *math-delim-right* '(:lbrace :rbrace)))
+                        (evenp *math-height*))
+               (set! *math-height* (+ *math-height* 1)))
+             (set! res
+                   (string-append
+                    "<table><tr><td>"
+                    (tex-math-delim-string *math-delim-left*)
+                    "</td><td>"
+                    res
+                    "</td><td>"
+                    (tex-math-delim-string *math-delim-right*)
+                    "</td></tr></table>")))
+           (set! *html* old-html)
+           (set!  *math-delim-left* old-math-delim-left)
+           (set! *math-delim-right* old-math-delim-right)
+           (set! *math-height* (+ old-math-height *math-height*))
+           (pop-tabular-stack ':mathbox)
+           (unless *math-script-mode?*
+             (emit "</td><td>"))
+           ;(when (> *math-height* 0) (emit "<small>")) ;not quite
+           (emit res)
+           ;(when (> *math-height* 0) (emit "</small>"))
+           (unless *math-script-mode?*
+             (emit "</td><td>"))))))))
+
+(define do-math-left
+  (lambda ()
+    (ignorespaces)
+    (when (and *in-display-math?* (not *math-script-mode?*))
+      (let ((s (get-token)))
+        (bgroup)
+        (cond ((string=? s "(") (set! *math-delim-left* ':lparen))
+              ((string=? s "[") (set! *math-delim-left* ':lbrack))
+              ((string=? s "\\{") (set! *math-delim-left* ':lbrace))
+              (else (terror 'do-math-left)))))))
+
+(define do-math-right
+  (lambda ()
+    (ignorespaces)
+    (when (and *in-display-math?* (not *math-script-mode?*))
+      (let ((s (get-token)))
+        (cond ((string=? s ")") (set! *math-delim-right* ':rparen))
+              ((string=? s "]") (set! *math-delim-right* ':rbrack))
+              ((string=? s "\\}") (set! *math-delim-right* ':rbrace))
+              (else (terror 'do-math-right)))
+        (egroup)))))
+
+(define egroup
+  (lambda ()
+    (when (null? *tex-env*) (terror 'egroup "Too many }'s"))
+    (perform-postludes)
+    (perform-aftergroups)
+    (set! *tex-env* (cdr *tex-env*))))
+
+(define perform-postludes
+  (lambda ()
+    (for-each
+     (lambda (p) (p))
+     (texframe.postludes (top-texframe)))))
+
+(define perform-aftergroups
+  (lambda ()
+    (let ((ags (texframe.aftergroups (top-texframe))))
+      (unless (null? ags)
+        (toss-back-char *invisible-space*))
+      (for-each
+        (lambda (ag) (ag)) ags))))
+
+(define perform-afterassignment
+  (lambda ()
+    (let ((z *afterassignment*))
+      (when z
+        (set! *afterassignment* #f)
+        (do-tex-ctl-seq z)))))
+
+(define add-postlude-to-top-frame
+  (lambda (p)
+    (let ((fr (if (null? *tex-env*) *global-texframe* (car *tex-env*))))
+      (set!texframe.postludes
+       fr
+       (cons p (texframe.postludes fr))))))
+
+(define add-aftergroup-to-top-frame
+  (lambda (ag)
+    (let ((fr (if (null? *tex-env*) *global-texframe* (car *tex-env*))))
+      (set!texframe.aftergroups
+       fr
+       (cons ag (texframe.aftergroups fr))))))
+
+(define top-texframe
+  (lambda ()
+    (if (null? *tex-env*) *global-texframe* (car *tex-env*))))
+
+;
+
+(defstruct tdef
+  (argpat '()) (expansion "") (optarg #f)
+  (thunk #f) (prim #f) (defer #f))
+
+(defstruct cdef
+  (argpat #f) (expansion #f) (optarg #f) (active #f))
+
+(define kopy-tdef
+  (lambda (lft rt)
+    (set!tdef.argpat lft (tdef.argpat rt))
+    (set!tdef.expansion lft (tdef.expansion rt))
+    (set!tdef.optarg lft (tdef.optarg rt))
+    (set!tdef.thunk lft (tdef.thunk rt))
+    (set!tdef.prim lft (tdef.prim rt))
+    (set!tdef.defer lft (tdef.defer rt))))
+
+(define kopy-cdef
+  (lambda (lft rt)
+    (set!cdef.argpat lft (cdef.argpat rt))
+    (set!cdef.expansion lft (cdef.expansion rt))
+    (set!cdef.optarg lft (cdef.optarg rt))
+    (set!cdef.active lft (cdef.active rt))))
+
+(define cleanse-tdef
+  (lambda (d)
+    (set!tdef.argpat d '())
+    (set!tdef.expansion d "")
+    (set!tdef.optarg d #f)
+    (set!tdef.thunk d #f)
+    (set!tdef.prim d #f)
+    (set!tdef.defer d #f)))
+
+(define tex-def
+  (lambda (name argpat expansion optarg thunk prim defer frame)
+    (unless frame (set! frame (top-texframe)))
+    (let* ((frame-defs (texframe.definitions frame))
+           (d (or (table-get frame-defs name)
+                  (let ((d (make-tdef)))
+                    (table-put! frame-defs name
+                                d)
+                    d))))
+      (set!tdef.argpat d argpat)
+      (set!tdef.expansion d expansion)
+      (set!tdef.optarg d optarg)
+      (set!tdef.thunk d thunk)
+      (set!tdef.prim d prim)
+      (set!tdef.defer d defer))
+    (perform-afterassignment)))
+
+(define tex-def-prim
+  (lambda (prim thunk)
+    (tex-def prim '() #f #f thunk prim #f *primitive-texframe*)))
+
+(define tex-def-0arg
+  (lambda (cs expn)
+    (tex-def cs '() expn #f #f #f #f #f)))
+
+(define find-def-0arg
+  (lambda (cs)
+    (cond ((find-def cs) => tdef.expansion)
+          (else #f))))
+
+(define tex-gdef-0arg
+  (lambda (cs expn)
+    ;is cs in prim field really necessary?
+    (tex-def cs '() expn #f #f cs #f *global-texframe*)))
+
+(define tex-def-prim-0arg
+  (lambda (cs expn)
+    ;is cs in prim field really necessary?
+    (tex-def cs '() expn #f #f cs #f *primitive-texframe*)))
+
+(define get-0arg-expn
+  (lambda (cs)
+    (cond ((find-def cs) => tdef.expansion)
+          (else "0"))))
+
+(define tex2page-flag-value
+  (lambda (cs)
+    (string-ref (get-0arg-expn cs) 0)))
+
+(define tex2page-flag-boolean
+  (lambda (cs)
+    (not (memv (string-ref (get-0arg-expn cs) 0)
+               '(#\0 #\f #\F #\n #\N)))))
+
+(define tex-let
+  (lambda (lft rt frame)
+    (unless frame (set! frame (top-texframe)))
+    (let* ((frame-defs (texframe.definitions frame))
+           (lft-def
+             (or (table-get frame-defs lft)
+                 (let ((lft-def (make-tdef)))
+                   (table-put! frame-defs lft lft-def)
+                   lft-def))))
+      (cond ((find-def rt)
+             => (lambda (rt-def)
+                  (kopy-tdef lft-def rt-def)))
+            (else
+              (cleanse-tdef lft-def)
+              (set!tdef.defer lft-def rt))))))
+
+(define tex-let-prim
+  (lambda (lft rt)
+    (tex-let lft rt *primitive-texframe*)))
+
+;(trace tex-let)
+
+(define tex-def-thunk
+  (lambda (name thunk frame)
+    (unless (inside-false-world?)
+      (tex-def name '() #f #f thunk name #f frame))))
+
+(define tex-def-count
+  (lambda (name num g?)
+    (let ((frame (if g? *global-texframe* (top-texframe))))
+      (table-put! (texframe.counts frame) name num))
+    (perform-afterassignment)))
+
+(define tex-def-toks
+  (lambda (name tokens g?)
+    (let ((frame (if g? *global-texframe* (top-texframe))))
+      (table-put! (texframe.toks frame) name tokens))))
+
+(define tex-def-dimen
+  (lambda (name len g?)
+    (let ((frame (if g? *global-texframe* (top-texframe))))
+      (table-put! (texframe.dimens frame) name len)
+    (perform-afterassignment))))
+
+;char defs
+
+(define tex-def-char
+  (lambda (char argpat expansion frame)
+    ;are we using argpat?
+    (unless frame (set! frame (top-texframe)))
+    (let ((d (ensure-cdef char frame)))
+      (set!cdef.argpat d argpat)
+      (set!cdef.expansion d expansion)
+      ;(set!cdef.active d #t)
+      )
+    (perform-afterassignment)))
+
+(define ensure-cdef
+  (lambda (c f)
+    (let ((f-chardefs (texframe.chardefinitions f)))
+      (or (table-get f-chardefs c)
+          (let ((d (make-cdef)))
+            (table-put! f-chardefs c d)
+            d)))))
+
+(define find-chardef
+  (lambda (c)
+    (let ((x (or (ormap (lambda (f)
+                          (table-get (texframe.chardefinitions f) c))
+                        *tex-env*)
+                 (table-get (texframe.chardefinitions
+                           *global-texframe*) c)
+                 (table-get (texframe.chardefinitions
+                           *primitive-texframe*) c))))
+      (and x (cdef.active x) x))))
+
+(define find-chardef-in-top-frame
+  (lambda (c)
+    (let ((x (if (null? *tex-env*)
+                 (or (table-get  (texframe.chardefinitions *global-texframe*) c)
+                     (table-get (texframe.chardefinitions *primitive-texframe*) c))
+               (table-get (texframe.chardefinitions (car *tex-env*)) c))))
+      (and x (cdef.active x) x))))
+
+(define do-defcsactive
+  (lambda (g?)
+    (ignorespaces)
+    (let* ((cs (get-ctl-seq))
+           (c (string-ref cs 1))
+           (argpat (get-def-arguments c))
+           (rhs (ungroup (get-group)))
+           (f (and g? *global-texframe*)))
+      (activate-cdef c)
+      (tex-def-char c argpat rhs f))))
+
+(define activate-cdef
+  (lambda (c)
+    (let ((y (cond ((find-chardef-in-top-frame c)
+                    => (lambda (y)
+                         (set!cdef.active y #t)
+                         y))
+                   (else
+                     (let* ((d (find-chardef c))
+                            (y (ensure-cdef c (top-texframe))))
+                       (when d (kopy-cdef y d))
+                       (set!cdef.active y #t)
+                       y)))))
+      (add-postlude-to-top-frame
+        (lambda ()
+          (set!cdef.active y #f))))))
+
+(define deactivate-cdef
+  (lambda (c)
+    (cond ((find-chardef-in-top-frame c)
+           ;if c is active in current group,
+           ;deactivate it
+           => (lambda (y) (set!cdef.active y #f)))
+          ((find-chardef c)
+           ;if c is active in an enclosing group,
+           ;create a shadowing unactive def for
+           ;it in the current group
+           => (lambda (y)
+                (let ((d (ensure-cdef c (top-texframe))))
+                  (kopy-cdef d y)
+                  (set!cdef.active d #f)))))))
+
+(define do-undefcsactive
+  (lambda ()
+    (ignorespaces)
+    (deactivate-cdef
+     (string-ref (get-ctl-seq) 1))))
+
+(define do-catcode
+  (lambda ()
+    (let* ((c (get-tex-char-spec))
+           (val (begin (get-equal-sign) (get-number))))
+      (set-catcode c val))))
+
+(define set-catcode
+  (lambda (c val)
+    (unless (= val 13) (deactivate-cdef c))
+    (unless (= val 11)
+      (set! *tex-extra-letters* (ldelete c *tex-extra-letters* char=?)))
+    (case val
+      ((0) (set! *esc-char* 0))
+      ((11) (set! *tex-extra-letters* (cons c *tex-extra-letters*)))
+      ((13) (activate-cdef c))
+      )
+    ))
+
+;
+
+(define do-global
+  (lambda ()
+    (ignorespaces)
+    (let ((next (get-ctl-seq)))
+      (cond ((string=? next "\\def")
+             (do-def #t #f))
+            ((string=? next "\\edef")
+             (do-def #t #t))
+            ((string=? next "\\let")
+             (do-let #t))
+            ;tex can't do this, so shouldn't t2p
+            ;((string=? next "\\defcsactive")
+            ; (do-defcsactive #t))
+            ((string=? next "\\newcount")
+             (do-newcount #t))
+            ((string=? next "\\newtoks")
+             (do-newtoks #t))
+            ((string=? next "\\newdimen")
+             (do-newdimen #t))
+            ((string=? next "\\advance")
+             (do-advance #t))
+            ((string=? next "\\multiply")
+             (do-multiply #t))
+            ((string=? next "\\divide")
+             (do-divide #t))
+            ((string=? next "\\read")
+             (do-read #t))
+            ((ormap (lambda (z) (string=? next z))
+               '("\\imgdef" "\\gifdef"))
+             (make-reusable-img #t))
+            ((find-count next)
+             (do-count= next #t))
+            ((find-toks next)
+             (do-toks= next #t))
+            (else
+              (toss-back-string next))))))
+
+;Headings
+
+(define do-externaltitle
+  (lambda ()
+    (write-aux
+      `(!preferred-title
+         ,(tex-string->html-string (get-group))))))
+
+(define tex2page-string
+  (lambda (s)
+    (call-with-input-string/buffered s
+      (lambda ()
+          (generate-html)))))
+
+(define make-external-title
+  (lambda (title)
+    (fluid-let ((*outputting-external-title?* #t))
+      (bgroup)
+      (let ((s (tex-string->html-string
+		 (string-append
+		   ;"\\def\\\\{}"
+		   "\\let\\\\\\ignorespaces"
+		   "\\def\\resizebox#1#2#3{}"
+		   "\\let\\thanks\\TIIPgobblegroup"
+		   "\\let\\urlh\\TIIPgobblegroup "
+		   title))))
+	(egroup)
+	s))))
+
+(define output-external-title
+  (lambda ()
+    (fluid-let ((*outputting-external-title?* #t))
+      (emit "<title>") (emit-newline)
+      (emit (or *title* *jobname*))
+      (emit-newline)
+      (emit "</title>") (emit-newline))))
+
+(define output-title
+  (lambda (title)
+    (emit "<h1 class=title>")
+    (bgroup)
+    (tex2page-string
+     (string-append
+      ;"\\def\\\\{\\break\\ignorespaces}"
+      "\\let\\\\\\break "
+      title))
+    (egroup)
+    (emit "</h1>")
+    (emit-newline)))
+
+(define do-subject
+  (lambda ()
+    (tex-gdef-0arg "\\TZPtitleused" "1")
+    (do-end-para)
+    (let ((title (get-group)))
+      (unless *title* (flag-missing-piece ':document-title))
+      (write-aux `(!default-title ,(make-external-title title)))
+      (output-title title)
+      ;(do-para)
+      )))
+
+(define do-latex-title
+  (lambda ()
+    (let ((title (get-group)))
+      (unless *title* (flag-missing-piece ':document-title))
+      (write-aux `(!default-title ,(make-external-title title)))
+      (toss-back-string title)
+      (toss-back-string "\\def\\TIIPtitle"))))
+
+(define do-title
+  (lambda ()
+    ((if (eqv? *tex-format* ':latex)
+         do-latex-title
+         do-subject))))
+
+(define do-author
+  (lambda ()
+    (toss-back-string "\\def\\TIIPauthor")))
+
+(define do-date
+  (lambda ()
+    (toss-back-string "\\def\\TIIPdate")))
+
+(define do-today
+  (lambda ()
+    (let ((m (get-gcount "\\month")))
+      (if (= m 0) (emit "[today]")
+          (begin
+            (emit (vector-ref *month-names* (- m 1)))
+            (emit " ")
+            (emit (get-gcount "\\day"))
+            (emit ", ")
+            (emit (get-gcount "\\year")))))))
+
+;
+
+(define add-afterpar
+  (lambda (ap)
+    (set! *afterpar*
+      (cons ap *afterpar*))))
+
+(define do-end-para
+  (lambda ()
+    (when *in-para?*
+      (when *use-closing-p-tag?* (emit "</p>"))
+      (unless (null? *afterpar*)
+        (for-each (lambda (ap) (ap))
+                  (nreverse *afterpar*))
+        (set! *afterpar* '()))
+      (emit-newline)
+      (set! *in-para?* #f))))
+
+(define do-para
+  (lambda ()
+    (do-end-para)
+    (let ((in-table? (and (not (null? *tabular-stack*))
+                          (memv (car *tabular-stack*) '(:block)))))
+      ;(when *in-para?* (when *use-closing-p-tag?* (emit "</p>")))
+      ;(emit-newline)
+      (when in-table?
+        (emit "</td></tr><tr><td>")
+        (emit-newline))
+      (emit "<p>")
+      (set! *in-para?* #t)
+      ;too many bogus <p>s generated right now for this
+      ;to work.  Plus, is it too expensive?
+      ;(tex2page-string (get-toks "\\everypar"))
+      )))
+
+(define do-noindent
+  (lambda ()
+    (do-end-para)
+    (emit-newline)
+    (emit "<p class=noindent>")
+    (set! *in-para?* #t)))
+
+(define do-para-nopadding
+  (lambda ()
+    (do-end-para)
+    (emit-newline)
+    (emit "<p class=nopadding>")
+    (set! *in-para?* #t)))
+
+(define do-maketitle
+  (lambda ()
+    (do-end-para)
+    (bgroup)
+    (tex2page-string
+     (string-append
+      "\\let\\\\\\break"
+      "\\let\\and\\break"
+      "\\let\\thanks\\symfootnote"))
+    (output-title "\\TIIPtitle")
+    (do-para)
+    (do-end-para)
+    (emit "<div align=center>")
+    (emit-newline)
+    (tex2page-string "\\TIIPauthor")
+    (do-para)
+    (tex2page-string "\\TIIPdate")
+    (do-end-para)
+    (emit "</div>")
+    (emit-newline)
+    (egroup)
+    (do-para)))
+
+(define do-inputcss
+  (lambda ()
+    (ignorespaces)
+    (let ((f (get-filename-possibly-braced)))
+      (when (null? *stylesheets*)
+        (flag-missing-piece ':stylesheets))
+      (write-aux `(!stylesheet ,f)))))
+
+(define do-csname
+  (lambda ()
+    (ignorespaces)
+    (let loop ((r '()))
+      (let ((c (snoop-actual-char)))
+        (cond ((char=? c *esc-char*)
+               (let ((x (get-ctl-seq)))
+                 (cond ((string=? x "\\endcsname")
+                        ;(toss-back-char *invisible-space*)
+                        (toss-back-char #\})
+                        (for-each toss-back-string r)
+                        (toss-back-char *esc-char*)
+                        (toss-back-char #\{)
+                        (toss-back-string "TIIPcsname")
+                        (toss-back-char *esc-char*)
+                        )
+                       (else
+                         (loop (cons (expand-ctl-seq-into-string x)
+                                     r))
+                         ))))
+              (else (get-actual-char)
+                (loop (cons (string c) r))))))))
+
+(define do-saved-csname
+  (lambda ()
+    (let ((x (get-peeled-group)))
+      (do-tex-ctl-seq x))))
+
+(define do-cssblock
+  (lambda ()
+    (fluid-let ((*dumping-nontex?* #t))
+      (dump-till-end-env "cssblock" *css-port*))))
+
+(define link-stylesheets
+  (lambda ()
+    (emit "<link rel=\"stylesheet\" type=\"text/css\" href=\"")
+    (emit *jobname*) (emit *css-file-suffix*)
+    (emit "\" title=default>") (emit-newline)
+    (for-each
+     (lambda (css)
+       (emit "<link rel=\"stylesheet\" type=\"text/css\" href=\"")
+       (emit css)
+       (emit "\" title=default>") (emit-newline))
+     *stylesheets*)))
+
+;sections
+
+(define increment-section-counter
+  (lambda (seclvl unnumbered?)
+    (unless unnumbered?
+      ;increment the counter for seclvl.
+      ;if counter not set, init it to 1
+      (table-put! *section-counters* seclvl
+        (+ 1 (table-get *section-counters* seclvl 0))))
+    ;zero the counters of all section levels below
+    ;current level -- except 0, which doesn't change
+    ;even when -1 changes
+    (table-for-each *section-counters*
+      (lambda (k v)
+        (when (and (> k seclvl) (> k 0))
+            (table-put! *section-counters* k 0))))
+    ;zero footnote counter if new chapter
+    (when (= seclvl 0)
+      (set-gcount! "\\footnotenumber" 0))
+    ;zero all the theorem-counters that hang off of
+    ;this section level
+    (for-each
+      (lambda (counter-name)
+        (set!counter.value
+          (table-get *dotted-counters* counter-name)
+          0))
+      (table-get *section-counter-dependencies* seclvl '()))))
+
+(define section-counter-value
+  (lambda (seclvl)
+    (if (= seclvl -1)
+        (number->roman (table-get *section-counters* -1) #t)
+        (let ((i (if *using-chapters?* 0 1)))
+          (let ((outermost-secnum
+                  (let ((n (table-get *section-counters* i 0)))
+                    (if *inside-appendix?*
+                        (string (integer->char (+ (char->integer #\A) -1
+                                                  n)))
+                        (number->string n)))))
+            (let loop ((i (+ i 1)) (r outermost-secnum))
+              (if (> i seclvl) r
+                  (loop (+ i 1)
+                    (string-append r "."
+                      (number->string
+                        (table-get *section-counters* i 0)))))))))))
+
+(define section-ctl-seq?
+  (lambda (s)
+    (cond ((string=? s "\\sectiond")
+           (string->number (ungroup (get-token))))
+          ((string=? s "\\part")
+           -1)
+          ((string=? s "\\chapter")
+           (!using-chapters)
+           (write-aux `(!using-chapters))
+           (when (and (eqv? *tex-format* ':latex)
+                    (< (get-gcount "\\secnumdepth") -1))
+               (set-gcount! "\\secnumdepth" 2))
+           0)
+          (else
+            (let ((n (string-length s)))
+              (cond ((< n 8) #f)
+                    ((and (>= n 10)
+                          (string=? (substring s (- n 9) n) "paragraph"))
+                     (let ((n-9 (- n 9)))
+                       (let loop ((i 1) (i+3 4) (k 4))
+                         (cond ((> i+3 n-9) k)
+                               ((string=? (substring s i i+3) "sub")
+                                (loop i+3 (+ i+3 3) (+ k 1)))
+                               (else #f)))))
+                    ((string=? (substring s (- n 7) n) "section")
+                     (let ((n-7 (- n 7)))
+                       (let loop ((i 1) (i+3 4) (k 1))
+                         (cond ((> i+3 n-7) k)
+                               ((string=? (substring s i i+3) "sub")
+                                (loop i+3 (+ i+3 3) (+ k 1)))
+                               (else #f)))))
+                    (else #f)))))))
+
+(define do-heading
+  (lambda (seclvl)
+    (let* ((starred? (cond ((char=? (snoop-actual-char) #\*)
+                            (get-actual-char) #t)
+                           (else #f)))
+           (too-deep? (let ((secnumdepth (get-gcount "\\secnumdepth")))
+                        (cond ((< secnumdepth -1) #f)
+                              ((> seclvl secnumdepth) #t)
+                              (else #f))))
+           (unnumbered? (or starred? too-deep?))
+           (header (fluid-let ((*tabular-stack* (list ':header)))
+                     (tex-string->html-string (get-group)))))
+      (when (<= seclvl 0) (do-eject))
+      (increment-section-counter seclvl unnumbered?)
+      (let ((lbl-val (if unnumbered? #f
+                         (section-counter-value seclvl))))
+        (do-heading-aux seclvl starred? unnumbered? #f lbl-val header)))))
+
+(define do-heading-aux
+  (lambda (seclvl starred? unnumbered? chapname lbl-val header)
+    (unless lbl-val (set! lbl-val "IGNORE"))
+    (let* ((htmlnum (max 1 (min 6 (if *using-chapters?*
+                                      (+ seclvl 1) seclvl))))
+           (lbl (string-append *html-node-prefix*
+                               (case seclvl
+                                 ((-1) "part") ((0) "chap") (else "sec"))
+                               "_"
+                               (if unnumbered? (gen-temp-string) lbl-val))))
+      (unless #f ;unnumbered?
+        (tex-def-0arg "\\TIIPcurrentnodename" lbl)
+        (tex-def-0arg "\\@currentlabel" lbl-val)
+        )
+      (do-end-para)
+      (emit-anchor lbl)
+      (emit-newline)
+      (ignore-all-whitespace)
+      (emit "<h")
+      (emit htmlnum)
+      (case seclvl
+        ((-1) (emit " class=part align=center"))
+        ((0) (emit " class=chapter"))
+        (else (emit " class=section")))
+      (emit ">")
+      (let ((write-to-toc? ;kludge?
+              (and *toc-page*
+                   (not (and (eqv? *tex-format* ':latex)
+                             (string=? header "Contents"))))))
+        (case seclvl
+          ((-1)
+           (emit "<div class=partheading>")
+           (if unnumbered? (emit-nbsp 1)
+               (begin
+                 (when write-to-toc?
+                   (emit-page-node-link-start *toc-page*
+                                              (string-append
+                                                *html-node-prefix*
+                                                "toc_" lbl)))
+                 (tex2page-string (or chapname "\\partname"))
+                 (emit " ")
+                 (emit lbl-val)
+                 (when write-to-toc? (emit-link-stop))))
+           (emit "</div><br>")
+           (emit-newline))
+          ((0)
+           (emit-newline)
+           (emit "<div class=chapterheading>")
+           (if unnumbered? (emit-nbsp 1)
+               (begin
+                 (when write-to-toc?
+                   (emit-page-node-link-start
+                     *toc-page* (string-append *html-node-prefix*
+                                               "toc_" lbl)))
+                 (tex2page-string
+                   (or chapname
+                       (if *inside-appendix?*
+                           "\\appendixname" "\\chaptername")))
+                 (emit " ")
+                 (emit lbl-val)
+                 (when write-to-toc? (emit-link-stop))))
+           (emit "</div><br>")
+           (emit-newline)))
+        (when write-to-toc?
+          (emit-page-node-link-start
+            *toc-page* (string-append
+                         *html-node-prefix*
+                         "toc_" lbl)))
+        (unless (or (<= seclvl 0) unnumbered?)
+          (emit lbl-val)
+          (emit-nbsp 2))
+        ;(fluid-let ((*tabular-stack* (list ':header)))
+        ;  (tex2page-string header))
+        (emit header)
+        (when write-to-toc? (emit-link-stop))
+        (emit "</h")
+        (emit htmlnum)
+        (emit ">")
+        (emit-newline)
+        (do-para)
+        ;
+        (let ((tocdepth (get-gcount "\\tocdepth")))
+          (when (and write-to-toc?
+                     (not (and (eqv? *tex-format* ':latex) starred?))
+                     (or (< tocdepth -1)
+                         (<= seclvl tocdepth)))
+            (write-aux
+              `(!toc-entry
+                 ,(if (= seclvl -1) -1
+                      (if *using-chapters?* seclvl (- seclvl 1)))
+                 ,lbl-val
+                 ,*html-page-count* ,lbl ,header))))
+        )
+      (when *recent-node-name*
+        (do-label-aux *recent-node-name*)
+        (set! *recent-node-name* #f))
+      ;(if (= seclvl -1) (do-eject))
+      )))
+
+(define section-type-to-depth
+  (lambda (sectype)
+    (cond ((string->number sectype))
+          ((string=? sectype "chapter") 0)
+          ((string=? sectype "section") 1)
+          ((string=? sectype "subsection") 2)
+          ((string=? sectype "subsubsection") 3)
+          ((string=? sectype "paragraph") 4)
+          ((string=? sectype "subparagraph") 5)
+          (else 3) ;?
+          )))
+
+(define do-write-to-toc-aux
+  (lambda (seclvl secnum sectitle)
+    (let ((node-name (string-append *html-node-prefix* "sec_"
+                                    (if (string=? secnum "")
+                                        (gen-temp-string) secnum))))
+      (tex-def-0arg "\\TIIPcurrentnodename" node-name)
+      (tex-def-0arg "\\@currentlabel" secnum)
+      (emit-anchor node-name) (emit-newline)
+      (write-aux
+        `(!toc-entry
+           ,seclvl
+           ,secnum
+           ,*html-page-count*
+           ,node-name
+           ,sectitle)))))
+
+(define do-writenumberedcontentsline
+  (lambda ()
+    (let ((toc (get-peeled-group)))
+      (unless (string=? toc "toc")
+        (terror 'do-writenumberedcontentsline "only #1=toc supported"))
+      (do-writenumberedtocline))))
+
+(define do-writenumberedtocline
+  (lambda ()
+    (let* ((seclvl (section-type-to-depth (get-peeled-group)))
+           (secnum (tex-string->html-string (get-group)))
+           (sectitle (tex-string->html-string (get-group))))
+      (do-write-to-toc-aux seclvl secnum sectitle))))
+
+(define do-addcontentsline
+  (lambda ()
+    (let* ((toc (get-peeled-group)))
+      (unless (string=? toc "toc")
+        (terror 'do-addcontentsline "only #1=toc supported"))
+      (let* ((seclvl (section-type-to-depth (get-peeled-group)))
+             (sectitle (tex-string->html-string (get-group))))
+        (write-aux
+          `(!toc-entry
+             ,(if (= seclvl -1) -1
+                  (if *using-chapters?* seclvl (- seclvl 1)))
+             ,(find-def-0arg "\\@currentlabel") ;?
+             ,*html-page-count*
+             ,(find-def-0arg "\\TIIPcurrentnodename")
+             ,sectitle))))))
+
+(define do-documentclass
+  (lambda ()
+    (probably-latex)
+    (get-bracketed-text-if-any)
+    (let ((x (get-peeled-group)))
+      (when (ormap (lambda (z) (string=? x z))
+              '("report" "book"))
+        (!using-chapters)
+        (write-aux `(!using-chapters))))))
+
+(define get-till-par
+  (lambda ()
+    (let loop ((r '()) (newline? #f))
+      (let ((c (get-actual-char)))
+        (cond ((or (eof-object? c)
+                   (and newline? (char=? c #\newline)))
+               (list->string (nreverse r)))
+              (newline?
+                ;c can't be #\newline
+                (if (char-whitespace? c) (loop r #t)
+                    (loop (cons c (cons #\space r)) #f)))
+              ((char=? c #\newline) (loop r #t))
+              (else (loop (cons c r) #f)))))))
+
+(define do-beginsection
+  (lambda ()
+    (do-para)
+    (ignorespaces)
+    (let ((header (let ((*tabular-stack* (list ':header)))
+                    (tex-string->html-string (get-till-par)))))
+      (write-aux `(!default-title ,header))
+      (emit-newline)
+      (emit "<h1 class=beginsection>")
+      (bgroup)
+      (if (string=? header "")
+          (emit-nbsp 1)
+          (emit header))
+      (egroup)
+      (emit "</h1>")
+      (do-noindent)
+;      (do-heading-aux 2
+;                      #f
+;                      #t #f #f header)
+      )))
+
+(define do-beginchapter
+  (lambda ()
+    (if (or (> *html-page-count* 0)
+            (tex2page-flag-boolean "\\TZPtitleused"))
+        (do-eject)
+      (do-para))
+    (ignorespaces)
+    (let* ((chapno (tex-string->html-string
+                     (get-till-char #\space)))
+           (header (begin (ignorespaces)
+                          (let ((*tabular-stack* (list ':header)))
+                            (tex-string->html-string
+                             (get-till-par))))))
+      (write-aux `(!default-title ,header))
+      (emit-newline)
+      (tex-def-count "\\footnotenumber" 0 #t)
+      (do-write-to-toc-aux 1 chapno header)
+      (emit "<h1 class=beginchapter>")
+      (bgroup)
+      (unless (string=? chapno "")
+        (emit chapno)
+        (emit-nbsp 2))
+      (if (string=? header "") (emit-nbsp 1)
+        (emit header))
+      (egroup)
+      (emit "</h1>")
+      (do-noindent))))
+
+(define do-appendix
+  (lambda ()
+    (unless *inside-appendix?*
+      (set! *inside-appendix?* #t)
+      (table-put! *section-counters*
+        (if *using-chapters?* 0 1) 0))))
+
+;HTML's approximation of the TeX box
+
+(define do-table-plain
+  (lambda ()
+    (do-end-para)
+    (emit "<table width=100%><tr><td>")))
+
+(define do-end-table-plain
+  (lambda ()
+    (do-end-para)
+    (emit "</td></tr></table>")
+    ))
+
+;tables & figures
+
+(define do-table/figure
+  (lambda (type)
+    (do-end-para)
+    (bgroup)
+    (when (and (eqv? type ':figure) (char=? (snoop-actual-char) #\*))
+      (get-actual-char))
+    (set! *tabular-stack* (cons type *tabular-stack*))
+    (get-bracketed-text-if-any)
+    (let ((tbl-tag (string-append *html-node-prefix*
+                                  (if (eqv? type ':table) "tbl_" "fig_")
+                                  (gen-temp-string))))
+      (tex-def-0arg "\\TIIPcurrentnodename" tbl-tag)
+      (emit-anchor tbl-tag) (emit-newline)
+      ;(emit "<hr>")
+      (emit "<div class=")
+      (emit type)
+      (emit " align=")
+      (emit *display-justification*)
+      (emit "><table width=100%><tr><td align=")
+      (emit *display-justification*)
+      (emit ">")
+      ;(do-table-plain)
+      )))
+
+(define pop-tabular-stack
+  (lambda (type)
+    (if (null? *tabular-stack*)
+        (terror 'pop-tabular-stack
+               "Bad environment closer: "
+               type)
+        (set! *tabular-stack* (cdr *tabular-stack*)))))
+
+(define do-end-table/figure
+  (lambda (type)
+    (when (and (eqv? type ':figure)
+               (char=? (snoop-actual-char) #\*))
+      (get-actual-char))
+    (do-end-para)
+    (emit "</td></tr>")
+    (emit "</table>")
+    (emit "</div>")
+    ;(emit "<hr>")
+    (pop-tabular-stack type)
+    (egroup)
+    (do-para)))
+
+(define bump-dotted-counter
+  (lambda (name)
+    (let* ((counter (table-get *dotted-counters* name))
+           (new-value (+ 1 (counter.value counter))))
+      (set!counter.value counter new-value)
+      (let ((num (string-append
+                 (cond ((counter.within counter)
+                        => (lambda (sec-num)
+                             (string-append
+                              (section-counter-value sec-num)
+                              ".")))
+                       (else ""))
+                 (number->string new-value))))
+       (tex-def-0arg "\\@currentlabel" num)
+        num))))
+
+(define do-caption
+  (lambda ()
+    (do-end-para)
+    (let* ((i-fig (list-position ':figure *tabular-stack*))
+           (i-tbl (list-position ':table *tabular-stack*))
+           (type (cond ((and (not i-fig) (not i-tbl))
+                        (terror 'do-caption "Mislaid \\caption"))
+                       ((not i-fig) ':table)
+                       ((not i-tbl) ':figure)
+                       ((< i-fig i-tbl) ':figure)
+                       ((< i-tbl i-fig) ':table)
+                       (else (terror 'do-caption "cant happen"))))
+           (counter-name (if (eqv? type ':table) "table" "figure"))
+           (caption-title (if (eqv? type ':table) "\\tablename" "\\figurename"))
+           (num (bump-dotted-counter counter-name)))
+      (get-bracketed-text-if-any)
+      (emit "</td></tr>")
+      (emit-newline)
+      (emit "<tr><td align=")
+      (emit *display-justification*)
+      (emit "><b>")
+      (tex2page-string caption-title)
+      (emit " ")
+      (emit num)
+      (emit ":</b>")
+      (emit-nbsp 2)
+      (tex2page-string (get-group))
+      (emit "</td></tr>")
+      (emit-newline)
+      (emit "<tr><td>"))))
+
+(define do-marginpar
+  (lambda ()
+    (get-bracketed-text-if-any)
+    (emit "<table align=left border=2><tr><td>")
+    (tex2page-string (get-group))
+    (emit "</td></tr></table>")))
+
+(define do-minipage
+  (lambda ()
+    (get-bracketed-text-if-any)
+    (get-group)
+    (let ((in-table? (and (not (null? *tabular-stack*))
+                          (memv (car *tabular-stack*) '(:block :figure :table)))))
+      (if in-table? (emit "</td><td>")
+          (begin (do-para) (do-end-para)))
+      (emit "<div align=left>")
+      (set! *tabular-stack* (cons ':minipage *tabular-stack*)))))
+
+(define do-endminipage
+  (lambda ()
+    (pop-tabular-stack ':minipage)
+    (let ((in-table? (and (not (null? *tabular-stack*))
+                          (memv (car *tabular-stack*) '(:block :figure :table)))))
+      (emit "</div>")
+      (if in-table? (emit "</td><td>") (do-para)))))
+
+(define do-tabbing
+  (lambda ()
+    (set! *tabular-stack*
+      (cons ':tabbing *tabular-stack*))
+    (do-para)))
+
+(define do-end-tabbing
+  (lambda ()
+    (pop-tabular-stack ':tabbing)
+    (do-para)))
+
+(define do-equation
+  (lambda (type)
+    (cond ((and (tex2page-flag-boolean "\\TZPmathimage")
+                (not *temporarily-use-utf8-for-math?*))
+           (do-latex-env-as-image
+             (case type
+               ((:equation) "equation")
+               ((:align) "align")
+               (else "eqnarray"))
+            ':display))
+          (else
+           (do-end-para)
+           (bgroup)
+           (when (eqv? type ':align) (set! type ':eqnarray));?
+           (when (and (eqv? type ':eqnarray) (eat-star))
+             (set! type ':eqnarray*))
+           (set! *tabular-stack* (cons type *tabular-stack*))
+           (set! *math-mode?* #t)
+           (set! *in-display-math?* #t)
+           (let ((eqn-tag (string-append *html-node-prefix* "eqn_"
+                                         (gen-temp-string))))
+             (tex-def-0arg "\\TIIPcurrentnodename" eqn-tag)
+             (emit-anchor eqn-tag) (emit-newline)
+             (unless (eqv? type ':eqnarray*)
+               (set! *equation-number* (bump-dotted-counter "equation")))
+             (emit "<div align=")
+             (emit *display-justification*)
+             (emit "><table width=100%>") (emit-newline)
+             (emit "<tr><td align=")
+             (emit (if (eqv? type ':equation) "center" "right"))
+             (emit ">")
+             )))))
+
+(define do-end-equation
+  (lambda ()
+    (do-end-para)
+    (emit "</td>")
+    (unless (or (and (not (null? *tabular-stack*))
+                     (eqv? (car *tabular-stack*) ':eqnarray*))
+                (not *equation-numbered?*))
+      (emit "<td>(")
+      (emit *equation-number*)
+      (emit ")</td>"))
+    (emit "</tr>")
+    (emit-newline)
+    (emit "</table></div>")
+    (pop-tabular-stack ':equation)
+    (set! *math-mode?* #f)
+    (set! *in-display-math?* #f)
+    (egroup)
+    (set! *equation-numbered?* #t)
+    (set! *equation-position* 0)
+    (do-para)))
+
+(define do-integral
+  (lambda ()
+    (if (or (not *in-display-math?*) *math-script-mode?*)
+        (emit "&int;")
+      (let ((affixes-already-read '()))
+        (emit "<span style=\"font-size: 200%; position: relative; top: .25ex;\">&int;</span>")
+        (let loop ((i 2))
+          (unless (= i 0)
+            (ignorespaces)
+            (let ((c (snoop-actual-char)))
+              (when (and (memv c '(#\_ #\^))
+                         (not (memv c affixes-already-read)))
+                (set! affixes-already-read (cons c affixes-already-read))
+                (get-actual-char)
+                (when (= i 0)
+                  (emit (kern ".16667em")))
+                (fluid-let ((*math-script-mode?* #t))
+                (let ( (s  (get-token)))
+                  (emit "<span style=\"font-size: 85%; position: relative; ")
+                  (emit (case c
+                          ((#\_)  "top: 2.5ex; ")
+                          ((#\^) "bottom: 3ex; ")))
+                  (emit "\">")
+                  (tex2page-string s)
+                  (emit "</span>")))))
+            (loop (- i 1))))))))
+
+(define do-nonumber
+  (lambda ()
+    (set! *equation-numbered?* #f)))
+
+(define indent-n-levels
+  (lambda (n)
+    (let loop ((i -1))
+      (unless (>= i n)
+        (emit-nbsp 1)
+        (emit " ")
+        (emit-nbsp 1)
+        (emit " ")
+        (loop (+ i 1))))))
+
+(define do-toc
+  (lambda ()
+    (fluid-let ((*subjobname* (string-append *jobname* *toc-file-suffix*))
+                (*img-file-count* 0)
+                (*imgdef-file-count* 0))
+      (when (eqv? *tex-format* ':latex)
+        (tex2page-string
+         (if *using-chapters?*
+             "\\chapter*{\\contentsname}" "\\section*{\\contentsname}")))
+      (emit-anchor (string-append *html-node-prefix* "toc_start"))
+      (!toc-page *html-page-count*)
+      (write-aux `(!toc-page ,*html-page-count*))
+      (cond ((null? *toc-list*)
+             (flag-missing-piece ':toc)
+             (non-fatal-error "Table of contents not generated; rerun TeX2page"))
+            (else
+              (do-noindent)
+             (let ((tocdepth (get-gcount "\\tocdepth")))
+               (for-each
+                (lambda (x)
+                  (let* ((lvl (tocentry.level x))
+                         (secnum (tocentry.number x))
+                         (seclabel (tocentry.label x))
+                         (subentries?
+                          (or (= lvl -1) ;always bold parts
+                              (and (= lvl 0)
+                                   (or (< tocdepth -1)
+                                       (and *using-chapters?*
+                                            (> tocdepth 0))
+                                       (and (not *using-chapters?*)
+                                            (> tocdepth 1)))))))
+                    (when subentries?
+		     (if *tex-like-layout?*
+			 (do-bigskip ':medskip)
+			 (do-para))
+                      (do-noindent)
+                      (emit "<b>")
+                      (emit-newline))
+                    (indent-n-levels lvl)
+                    (emit-anchor (string-append *html-node-prefix* "toc_" seclabel))
+                    (emit-page-node-link-start
+                     (tocentry.page x)
+                     seclabel)
+                    ;(when (= lvl -1) (emit "Part "))
+                    (unless (or (string=? secnum "") (string=? secnum "IGNORE"))
+                      (emit secnum)
+                      ;(tex2page-string secnum)
+                      ;(emit #\.)
+                      (emit-nbsp 2))
+                    (fluid-let ((*tabular-stack* (list ':header)))
+                      ;tex2page-string
+                      (emit (tocentry.header x)))
+                    (emit-link-stop)
+                    (when subentries?
+                      (emit "</b>"))
+                    (emit "<br>")
+                    (emit-newline)))
+                *toc-list*))))
+      (emit-anchor (string-append *html-node-prefix* "toc_end")))))
+
+(defstruct footnotev mark text tag caller)
+
+(define do-numbered-footnote
+  (lambda ()
+    (do-footnote-aux #f)))
+
+(define do-symfootnote
+  (lambda ()
+    (set! *footnote-sym* (+ *footnote-sym* 1))
+    (do-footnote-aux
+      (number->footnote-symbol *footnote-sym*)
+      )))
+
+(define tex-string->html-string
+  (lambda (ts)
+    (let ((tmp-port (open-output-string)))
+      (fluid-let ((*html* tmp-port))
+        (tex2page-string ts))
+      (get-output-string tmp-port))))
+
+(define number->footnote-symbol
+  (let ((symlist #f))
+    (lambda (n)
+      (unless symlist
+        (set! symlist
+          (fluid-let ((*temporarily-use-utf8-for-math?* #t ))
+            (map tex-string->html-string
+                 '("*" "\\dag" "\\ddag" "\\S" "\\P"
+                   "$\\Vert$" "**" "\\dag\\dag" "\\ddag\\ddag")))))
+      (list-ref symlist
+                (modulo (- n 1) 9)))))
+
+(define do-plain-footnote
+  (lambda ()
+    (do-footnote-aux
+      (fluid-let ((*temporarily-use-utf8-for-math?* #t))
+        (tex-string->html-string
+          (get-token))))))
+
+(define do-footnote
+  (lambda ()
+    ((if (eqv? *tex-format* ':latex)
+        do-numbered-footnote
+        do-plain-footnote))))
+
+(define do-footnote-aux
+  (lambda (fnmark)
+    (let* ((fnno #f)
+           (fnlabel (gen-temp-string))
+           (fntag (string-append *html-node-prefix* "footnote_" fnlabel))
+           (fncalltag (string-append *html-node-prefix*
+                                     "call_footnote_" fnlabel)))
+      (unless fnmark
+        (set! fnno (+ (get-gcount "\\footnotenumber") 1))
+        (set-gcount! "\\footnotenumber" fnno)
+        ;fnmark should really be $^fnno$ but we will use this
+        ;kludge because for numbered footnotes it is nicer on
+        ;most browsers to push the <a href> inside the <sup>
+        (set! fnmark (number->string fnno)))
+      (emit-anchor fncalltag)
+      (when fnno (emit "<sup><small>"))
+      (emit-page-node-link-start #f fntag)
+      (emit fnmark)
+      (emit-link-stop)
+      (when fnno (emit "</small></sup>"))
+      (do-vfootnote-aux fnmark fncalltag fntag))))
+
+(define do-vfootnote
+  (lambda ()
+    (do-vfootnote-aux
+      (fluid-let ((*temporarily-use-utf8-for-math?* #t))
+        (tex-string->html-string (get-token)))
+      #f ;no footnote call tag
+      #f ;no footnote tag
+      )))
+
+(define do-vfootnote-aux
+  (lambda (fnmark fncalltag fntag)
+    (ignorespaces) ;needed?
+    (unless (char=? (get-actual-char) #\{)
+      (terror 'do-vfootnote-aux "Missing {"))
+    (bgroup)
+    (let ((old-html *html*)
+          (fn-tmp-port (open-output-string)))
+      (set! *html* fn-tmp-port)
+      (when fncalltag
+        (tex-def-0arg "\\TIIPcurrentnodename" fntag)
+        (tex-def-0arg "\\@currentlabel" fnmark))
+      (add-aftergroup-to-top-frame
+        (lambda ()
+          ;(close-output-port *html*)
+          (set! *footnote-list*
+            (cons (make-footnotev
+                    'mark fnmark
+                    'text (get-output-string fn-tmp-port)
+                    'tag fntag
+                    'caller fncalltag)
+                  *footnote-list*))
+          (set! *html* old-html))))))
+
+(define output-footnotes
+  (lambda ()
+    (let ((n (length *footnote-list*)))
+      (unless (= n 0)
+        ;(do-end-para)
+        (emit "<div class=footnoterule><hr></div>")
+        (do-para) (do-end-para)
+        (emit "<div class=footnote>")
+        (let loop ((i (- n 1)))
+          (unless (< i 0)
+            (let* ((fv (list-ref *footnote-list* i))
+                   (fnmark (footnotev.mark fv))
+                   (fnno (string->number fnmark))
+                   (fncalltag (footnotev.caller fv)))
+              (do-para)
+              (when fncalltag
+                (emit-anchor (footnotev.tag fv))
+                (when fnno (emit "<sup><small>"))
+                (emit-page-node-link-start #f fncalltag))
+              (emit fnmark)
+              (when fncalltag
+                (emit-link-stop)
+                (when fnno (emit "</small></sup>")))
+              (emit " ")
+              (emit (footnotev.text fv))
+              (do-end-para)
+              (loop (- i 1)))))
+        (emit "</div>")
+        (emit-newline)
+        ))))
+
+;
+
+(define rgb.dec->hex
+  (let ((f (lambda (x)
+             (let* ((n (inexact->exact (round (* 1.0 x))))
+                    (s (number->string n 16)))
+               (if (< n 16) (string-append "0" s) s)))))
+    (lambda (r g b)
+      (string-append (f r) (f g) (f b)))))
+
+(define rgb.frac->hex
+  (lambda (r g b)
+    (rgb.dec->hex (* r 255) (* g 255) (* b 255))))
+
+(define cmyk->rgb
+  ;from Dan Luecking's mfpic/metapost/grafbase.mp
+  (let ((f (lambda (x k)
+              (- 1 (min (max (+ x k) 0) 1)))))
+    (lambda (c m y k)
+      (rgb.frac->hex (f c k) (f m k) (f y k)))))
+
+(define do-color
+  (lambda ()
+    (let ((model (get-bracketed-text-if-any)))
+      (do-switch
+       (cond ((not model) ':colornamed)
+             ((string=? model "rgb") ':rgb)
+             ((string=? model "RGB") ':rgb255)
+             ((string=? model "cmyk") ':cmyk)
+             ((string=? model "gray") ':gray)
+             (else ':colornamed))))))
+
+(define do-definecolor
+  (lambda ()
+    (let* ((name (get-peeled-group))
+           (model (get-peeled-group))
+           (spec (get-peeled-group)))
+      (bgroup)
+      (set! *color-names*
+        (cons (cons name
+                    (if (string=? model "named")
+                        (let ((c (lassoc name *color-names* string=?)))
+                          (if c (cdr c)
+                              (terror 'do-definecolor
+                                      "Color name " name " not defined")))
+                        (let ((rgb #f))
+                          (call-with-input-string
+                            (tex-string->html-string
+                              (string-append "\\defcsactive\\,{ }" spec))
+                            (lambda (i)
+                              (cond ((string=? model "cmyk")
+                                     (let* ((c (read i)) (m (read i))
+                                                         (y (read i)) (k (read i)))
+                                       (cmyk->rgb c m y k)))
+                                    ((string=? model "rgb")
+                                     (let* ((r (read i)) (g (read i))
+                                                         (b (read i)))
+                                       (rgb.frac->hex r g b)))
+                                    ((string=? model "RGB")
+                                     (let* ((r (read i)) (g (read i))
+                                                         (b (read i)))
+                                       (rgb.dec->hex r g b)))
+                                    ((string=? model "gray")
+                                     (cmyk->rgb 0 0 0 (read i)))
+                                    (else
+                                      (terror 'do-definecolor
+                                              "Unknown color model"))))))))
+              *color-names*))
+      (egroup))))
+
+;Groups
+
+(define do-switch
+  (lambda (sw)
+    ;(ignorespaces)
+    (unless *outputting-external-title?*
+      (add-postlude-to-top-frame
+       (case sw
+         ((:rm)
+          (when *math-mode?*
+            (let ((old-math-roman-mode? *math-roman-mode?*))
+              (set! *math-roman-mode?* #t)
+              (lambda ()
+                (set! *math-roman-mode?* old-math-roman-mode?)))))
+         ((:em)
+          (emit "<em>")
+          (lambda () (emit "</em>")))
+         ((:it :itshape)
+          (emit "<i>")
+          (lambda () (emit "</i>")))
+         ((:bf :strong)
+          (emit "<strong>")
+          (lambda () (emit "</strong>")))
+         ((:sl)
+          (emit "<span style=\"font-style: oblique\">")
+          (lambda () (emit "</span>")))
+         ((:sf)
+          (emit "<span style=\"font-family: sans-serif\">")
+          (lambda () (emit "</span>")))
+         ((:tt)
+          (let ((old-ligatures? *ligatures?*))
+            (set! *ligatures?* #f)
+            (emit "<tt>")
+            (lambda () (emit "</tt>")
+              (set! *ligatures?* old-ligatures?))))
+         ((:sc :scshape)
+          (let ((old-in-small-caps? *in-small-caps?*))
+            (set! *in-small-caps?* #t)
+            (lambda ()
+              (set! *in-small-caps?* old-in-small-caps?))))
+         ;((ormap (lambda (z) (string=? sw z))
+         ;        '("\\sevenrm" "\\small" "\\scriptsize"))
+         ; (emit "<small>")
+         ; (lambda () (emit "</small>")))
+         ((:span)
+          (emit "<span ")
+          (emit (get-peeled-group))
+          (emit ">")
+          (lambda () (emit "</span>")))
+         ((:div)
+          (emit "<div ")
+          (emit (get-peeled-group))
+          (emit ">")
+          (lambda () (emit "</div>")))
+         ((:tiny)
+          (emit "<span class=tiny>")
+          (lambda () (emit "</span>")))
+         ((:scriptsize)
+          (emit "<span class=scriptsize>")
+          (lambda () (emit "</span>")))
+         ((:footnotesize :fiverm)
+          (emit "<span class=footnotesize>")
+          (lambda () (emit "</span>")))
+         ((:small :sevenrm)
+          (emit "<span class=small>")
+          (lambda () (emit "</span>")))
+         ((:normalsize)
+          (emit "<span class=normalsize>")
+          (lambda () (emit "</span>")))
+         ((:large)
+          (emit "<span class=large>")
+          (lambda () (emit "</span>")))
+         ((:large-cap)
+          (emit "<span class=largecap>")
+          (lambda () (emit "</span>")))
+         ((:large-up)
+          (emit "<span class=largeup>")
+          (lambda () (emit "</span>")))
+         ((:huge)
+          (emit "<span class=huge>")
+          (lambda () (emit "</span>")))
+         ((:huge-cap)
+          (emit "<span class=hugecap>")
+          (lambda () (emit "</span>")))
+         ((:cmyk)
+          (bgroup)
+          (call-with-input-string
+            (tex-string->html-string
+              (string-append "\\defcsactive\\,{ }" (get-token)))
+            (lambda (i)
+              (let* ((c (read i)) (m (read i)) (y (read i)) (k (read i)))
+                (ignorespaces)
+                (emit "<span style=\"color: #")
+                (emit (cmyk->rgb c m y k))
+                (emit "\">"))))
+          (egroup)
+          (lambda () (emit "</span>")))
+         ((:rgb)
+          (bgroup)
+          (call-with-input-string
+            (tex-string->html-string
+              (string-append "\\defcsactive\\,{ }" (get-token)))
+            (lambda (i)
+              (let* ((r (read i)) (g (read i)) (b (read i)))
+                (ignorespaces)
+                (emit "<span style=\"color: #")
+                (emit (rgb.frac->hex r g b))
+                (emit "\">"))))
+          (egroup)
+          (lambda () (emit "</span>")))
+         ((:rgb255)
+          (bgroup)
+          (call-with-input-string
+            (tex-string->html-string
+              (string-append "\\defcsactive\\,{ }" (get-token)))
+            (lambda (i)
+              (let* ((r (read i)) (g (read i)) (b (read i)))
+                (ignorespaces)
+                (emit "<span style=\"color: #")
+                (emit (rgb.dec->hex r g b))
+                (emit "\">"))))
+          (egroup)
+          (lambda () (emit "</span>")))
+         ((:gray)
+          (call-with-input-string
+            (tex-string->html-string (get-token))
+            (lambda (i)
+              (let ((g (read i)))
+                (ignorespaces)
+                (emit "<span style=\"color: #")
+                (emit (cmyk->rgb 0 0 0 (- 1 g)))
+                (emit "\">"))))
+          (lambda () (emit "</span>")))
+         ((:colornamed)
+          (let* ((name (get-peeled-group))
+                 (c (lassoc name *color-names* string=?)))
+            (ignorespaces)
+            (emit "<span style=\"color: ")
+            (emit (if c (begin (emit #\#) (cdr c)) name))
+            (emit "\">")
+            (lambda () (emit "</span>"))))
+         ((:bgcolor)
+          (emit "<span style=\"background-color: ")
+          (let ((color (ungroup (get-group))))
+            (when (string->number color 16) (emit "#"))
+            (emit color)
+            (emit "\">")
+            (lambda () (emit "</span>"))))
+         ((:strike)
+          (emit "<strike>")
+          (lambda () (emit "</strike>")))
+         ((:narrower)
+          (emit "<blockquote>")
+          (lambda ()
+            (emit "</blockquote>")))
+         ((:raggedleft)
+          (do-end-para)
+          (emit "<div align=right>")
+          (lambda ()
+            (do-end-para)
+            (emit "</div>") (do-para)))
+         (else
+           (emit "<span class=")
+           (emit sw)
+           (emit ">")
+           (lambda ()
+             (emit "</span>"))
+           ;(terror 'do-switch "Unknown switch " sw)
+           ))))))
+
+(define do-obeylines
+  (lambda ()
+    ;(do-para)
+    (when (eqv? (snoop-actual-char) #\newline) (get-actual-char))
+    (activate-cdef #\newline)
+    (tex-def-char #\newline '() "\\TIIPpar" #f)
+    ;(add-postlude-to-top-frame do-para)
+    ))
+
+(define do-obeyspaces
+  (lambda ()
+    (activate-cdef #\space)
+    (tex-def-char #\space '() "\\TIIPnbsp" #f)))
+
+(define do-obeywhitespace
+  (lambda ()
+    (do-obeylines)
+    (do-obeyspaces)))
+
+(define do-block
+  (lambda (z)
+    (do-end-para)
+    (emit "<div ")
+    (emit (case z
+            ((:flushleft) "align=left")
+            ((:flushright) "align=right")
+            (else "align=center")))
+    (emit ">")
+    (set! *tabular-stack* (cons ':block *tabular-stack*))
+    (emit "<table><tr><td>")
+    (bgroup)
+    (emit-newline)))
+
+(define do-end-block
+  (lambda ()
+    (do-end-para)
+    (egroup)
+    (emit "</td></tr></table></div>")
+    ;(do-para)
+    (pop-tabular-stack ':block)
+    (emit-newline)))
+
+(define do-function
+  (lambda (fn)
+    (fluid-let ((*math-mode?* *math-mode?*))
+      (cond (*outputting-external-title?* #f)
+            ((string=? fn "\\emph") (emit "<em>"))
+            ((string=? fn "\\leftline") (do-end-para) (emit "<div align=left>"))
+            ((string=? fn "\\centerline") (do-end-para) (emit "<div align=center>&nbsp;"))
+            ((string=? fn "\\rightline") (do-end-para) (emit "<div align=right>&nbsp;"))
+            ((string=? fn "\\underline") (emit "<u>"))
+            ((string=? fn "\\textbf")
+             (set! *math-mode?* #f)
+             (emit "<b>"))
+            ((ormap (lambda (z) (string=? fn z))
+                    '("\\textit" "\\textsl"))
+             (set! *math-mode?* #f)
+             (emit "<i>"))
+            ((string=? fn "\\textrm")
+             (set! *math-mode?* #f))
+            ((string=? fn "\\texttt")
+             (set! *math-mode?* #f)
+             (emit "<tt>"))
+            (else (terror 'do-function "Unknown function " fn)))
+      (bgroup)
+      (tex2page-string (get-token))
+      (egroup)
+      (cond (*outputting-external-title?* #f)
+            ((string=? fn "\\emph") (emit "</em>"))
+            ((string=? fn "\\rightline")
+             (emit "</div>") (emit-newline)
+             )
+            ((ormap (lambda (z) (string=? fn z))
+                    '("\\leftline" "\\centerline"))
+             (do-end-para)
+             (emit "&nbsp;</div>")
+             (emit-newline)
+             )
+            ((string=? fn "\\underline") (emit "</u>"))
+            ((string=? fn "\\textbf") (emit "</b>"))
+            ((ormap (lambda (z) (string=? fn z))
+                    '("\\textsl" "\\textit"))
+             (emit "</i>"))
+            ;\textrm does nothing
+            ((string=? fn "\\texttt") (emit "</tt>"))))))
+
+(define do-discretionary
+  (lambda ()
+    (tex2page-string (get-group))
+    (get-group)
+    (get-group)))
+
+(define do-aftergroup
+  (lambda ()
+    (ignorespaces)
+    (let ((z (get-ctl-seq)))
+      (add-aftergroup-to-top-frame
+       (lambda ()
+         (toss-back-string z))))))
+
+(define do-afterassignment
+  (lambda ()
+    (ignorespaces)
+    (let ((z (get-ctl-seq)))
+      (set! *afterassignment* z))))
+
+(define do-space
+  (lambda ()
+    (emit #\space)))
+
+(define do-tab
+  (lambda ()
+    (emit-nbsp 8)))
+
+(define emit-nbsp
+  (lambda (n)
+    (let loop ((n n))
+      (unless (<= n 0)
+        (emit "&nbsp;") (loop (- n 1))))))
+
+(define scaled-point-equivalent-of
+  (lambda (unit)
+    (case unit
+      ((:sp) 1)
+      ((:pt) 65536)
+      ((:bp) (* (/ 72) (scaled-point-equivalent-of ':in)))
+      ((:cc) (* 12 (scaled-point-equivalent-of ':dd)))
+      ((:dd) (* (/ 1238 1157) (scaled-point-equivalent-of ':pt)))
+      ((:em) (* 10 (scaled-point-equivalent-of ':pt))) ;kludge
+      ((:ex) (* 4.5 (scaled-point-equivalent-of ':pt))) ; kludge
+      ((:in) (* 72.27 (scaled-point-equivalent-of ':pt)))
+      ((:mm) (* .1 (scaled-point-equivalent-of ':cm)))
+      ((:cm) (* (/ 2.54) (scaled-point-equivalent-of ':in)))
+      ((:pc) (* 12 (scaled-point-equivalent-of ':pt))))))
+
+(define tex-length
+  (lambda (num unit)
+    (* num (scaled-point-equivalent-of unit))))
+
+(define sp-to-ems
+  (lambda (sp)
+    (/ sp 65536 10.0)))
+
+(define sp-to-pixels
+  (lambda (sp)
+    (inexact->exact
+     (floor
+      (/ sp 65536.0)))))
+
+(define get-scaled-points
+  (lambda ()
+    (let ((n (or (get-real) 1)))
+      (ignorespaces)
+      (* n
+         (if (char=? (snoop-actual-char) *esc-char*)
+             (let ((x (get-ctl-seq)))
+               (get-dimen x)
+               )
+             (let loop ()
+               (cond ((eat-word "bp") (tex-length 1 ':bp))
+                     ((eat-word "cc") (tex-length 1 ':cc))
+                     ((eat-word "cm") (tex-length 1 ':cm))
+                     ((eat-word "dd") (tex-length 1 ':dd))
+                     ((eat-word "em") (tex-length 1 ':em))
+                     ((eat-word "ex") (tex-length 1 ':ex))
+                     ((eat-word "in") (tex-length 1 ':in))
+                     ((eat-word "mm") (tex-length 1 ':mm))
+                     ((eat-word "pc") (tex-length 1 ':pc))
+                     ((eat-word "pt") (tex-length 1 ':pt))
+                     ((eat-word "sp") 1)
+                     ((eat-word "true") (loop))
+                     (else 1))))))))
+
+(define get-points
+  (lambda ()
+    (/ (get-scaled-points) 65536.0)))
+
+(define get-pixels
+  (lambda ()
+    ;assume 1 pxl = 1pt
+    (inexact->exact
+      (floor (get-points)))))
+
+(define do-font
+  (lambda ()
+    (get-ctl-seq)
+    (get-equal-sign)
+    (eat-alphanumeric-string)
+    (cond ((eat-word "at") (eat-dimen))
+          ((eat-word "scaled") (get-number)))))
+
+(define do-hskip
+  (lambda ()
+    (let ((n (get-pixels)))
+      (emit "<span style=\"margin-left: ")
+      (emit n)
+      (emit "pt\">&#x200c;</span>"))))
+
+(define do-vskip
+  (lambda ()
+    (let ((x (get-points)))
+      (eat-skip-fluff #f)
+      ;(emit-newline)
+      (emit "<div style=\"height: ")
+      (emit x)
+      (emit "pt\"></div>")
+      (emit-newline)
+      (emit "<p style=\"margin-top: 0pt; margin-bottom: 0pt\">")
+      (set! *in-para?* #t)
+      )))
+
+(define do-newline
+  (lambda ()
+    (when (>= (munch-newlines) 1)
+      (do-para))
+    (emit-newline)))
+
+(define do-br
+  (lambda ()
+    (if (or (find-chardef #\space)
+            (not (= (the-count "\\TIIPobeylinestrictly") 0)))
+        (emit "<br>")
+        (unless (eqv? (snoop-actual-char) #\newline)
+          (emit "<br>")))
+    (emit-newline)))
+
+(define do-sup
+  (lambda ()
+    (emit "<sup>")
+    (fluid-let ((*math-script-mode?* #t))
+      (tex2page-string (get-token)))
+    (emit "</sup>")))
+
+(define do-sub
+  (lambda ()
+    (emit "<sub>")
+    (fluid-let ((*math-script-mode?* #t))
+      (tex2page-string (get-token)))
+    (emit "</sub>")))
+
+(define do-hyphen
+  (lambda ()
+    (cond (*math-mode?*
+            (emit (if *math-roman-mode?* "-" "&minus;")))
+          ((not *ligatures?*) (emit #\-))
+          (else (let ((c (snoop-actual-char)))
+                  (if (and (char? c) (char=? c #\-))
+                      (begin (get-actual-char) (do-ndash))
+                      (emit #\-)))))))
+
+(define do-excl
+  (lambda ()
+    (if (or *math-mode?* (not *ligatures?*))
+        (emit #\!)
+        (let ((c (snoop-actual-char)))
+          (if (and (char? c) (char=? c #\`))
+              (begin (get-actual-char) (emit "&iexcl;"))
+             (emit #\!))))))
+
+(define do-quest
+  (lambda ()
+    (if (or *math-mode?* (not *ligatures?*))
+        (emit #\?)
+        (let ((c (snoop-actual-char)))
+          (if (and (char? c) (char=? c #\`))
+              (begin (get-actual-char) (emit "&iquest;"))
+              (emit #\?))))))
+
+(define do-ndash
+  (lambda ()
+    (emit
+      (let ((c (snoop-actual-char)))
+        (if (and (char? c) (char=? c #\-))
+            (begin (get-actual-char) "&mdash;")
+            "&ndash;")))))
+
+(define do-lsquo
+  (lambda ()
+    (emit
+      (if (not *ligatures?*) "&lsquo;"
+          (let ((c (snoop-actual-char)))
+            (if (and (char? c) (char=? c #\`))
+                (begin (get-actual-char) "&ldquo;")
+                "&lsquo;"))))))
+
+(define do-rsquo
+  (lambda ()
+    (emit
+      (cond (*math-mode?*
+              (let ((c (snoop-actual-char)))
+                (if (and (char? c) (char=? c #\'))
+                    (begin (get-actual-char) "&Prime;")
+                    "&prime;")))
+            ((not *ligatures?*) "&rsquo;")
+            (else
+              (let ((c (snoop-actual-char)))
+                (if (and (char? c) (char=? c #\'))
+                    (begin (get-actual-char) "&rdquo;")
+                    "&rsquo;")))))))
+
+;cross-references
+
+(defstruct label (src #f) page name value)
+
+(define get-label
+  (lambda ()
+    (let loop ((lbl (get-peeled-group)))
+      (let ((i (or (string-index lbl #\space)
+                   (string-index lbl *tab*)
+                   (string-index lbl #\newline))))
+        (if (not i) lbl
+            (let loop ((s (string->list lbl)) (r '())
+                       (ws? #f))
+              (if (null? s) (list->string (nreverse r))
+                  (let ((c (car s)))
+                    (loop (cdr s)
+                          (if (char-whitespace? c)
+                              (if ws? r (cons #\space r))
+                              (cons c r))
+                          (char-whitespace? c))))))))))
+
+(define emit-anchor
+  (lambda (lbl)
+    (emit "<a name=\"")
+    (emit lbl)
+    (emit "\"></a>")))
+
+(define emit-link-start
+  (lambda (link)
+    (emit "<a href=\"")
+    (emit link)
+    (emit "\">")))
+
+(define emit-ext-page-node-link-start
+  (lambda (extfile pageno node)
+    (emit "<a href=\"")
+    (unless (and (not extfile)
+                 (or (not pageno) (= *html-page-count* pageno)))
+      (emit (or extfile *jobname*))
+      (unless (= pageno 0)
+        (emit *html-page-suffix*)
+        (emit pageno))
+      (emit *output-extension*))
+    (when node
+      (emit "#")
+      (emit node))
+    (emit "\">")))
+
+(define emit-page-node-link-start
+  (lambda (pageno node)
+    (emit-ext-page-node-link-start
+     #f pageno node)))
+
+(define emit-link-stop
+  (lambda ()
+    (emit "</a>")))
+
+(define do-anchor-for-potential-label
+  (lambda ()
+    (let ((node-name (string-append *html-node-prefix*
+                                    "anchor_"
+                                    (gen-temp-string))))
+      (tex-def-0arg "\\TIIPcurrentnodename" node-name)
+      (emit-anchor node-name))))
+
+(define do-label
+  (lambda ()
+    (do-label-aux (get-label))))
+
+(define do-node
+  (lambda ()
+    (set! *recent-node-name* (get-peeled-group))))
+
+(define do-label-aux
+  (lambda (label)
+    (let ((name (find-def-0arg "\\TIIPcurrentnodename"))
+          (value (find-def-0arg "\\@currentlabel")))
+      (set! value (tex-string->html-string value))
+      (!label label *html-page-count* name value)
+      (write-label
+        `(!label ,label ,*html-page-count*
+           ,name ,value)))))
+
+(define do-inputexternallabels
+  (lambda ()
+    (let* ((f (get-filename-possibly-braced))
+           (fq-f (if (fully-qualified-pathname? f) f
+                     (string-append *aux-dir/* f)))
+           (ext-label-file (string-append fq-f
+                             *label-file-suffix* ".scm"))
+           (ext-label-table (table-get *external-label-tables* f)))
+      (unless ext-label-table
+        (set! ext-label-table (make-table 'equ string=?))
+        (table-put! *external-label-tables* f ext-label-table))
+      (when (file-exists? ext-label-file)
+        (fluid-let ((*label-source* fq-f)
+                    (*label-table* ext-label-table))
+          (load-tex2page-data-file ext-label-file))))))
+
+(define do-includeexternallabels
+  (lambda ()
+    (let ((jobname (get-filename-possibly-braced)))
+      ;(unless (fully-qualified-pathname? jobname)
+      ;  (set! jobname (string-append *aux-dir/* jobname)))
+      (let ((ext-label-file (string-append
+                             (if (fully-qualified-pathname? jobname)
+                                 jobname
+                                 (string-append *aux-dir/* jobname))
+                             *label-file-suffix* ".scm")))
+        (when (file-exists? ext-label-file)
+          (fluid-let ((*label-source* jobname))
+            (load-tex2page-data-file ext-label-file)))))))
+
+(define do-tag
+  (lambda ()
+    (let ((tag-name (get-peeled-group)))
+      (do-tag-aux tag-name
+                  (get-group)))))
+
+(define do-definexref
+  (lambda ()
+    (let* ((tag (get-peeled-group))
+           (value (get-group))
+           (class (get-token)))
+      (do-tag-aux tag value))))
+
+(define do-xrdef
+  (lambda ()
+    (let ((tag (get-peeled-group)))
+      (do-tag-aux tag (number->string *html-page-count*)))))
+
+(define do-tag-aux
+  (lambda (tag-name tag-val)
+    (let ((node-name (string-append *html-node-prefix* "tag_"
+                                    (gen-temp-string))))
+      (tex-def-0arg "\\TIIPcurrentnodename" node-name)
+      (tex-def-0arg "\\@currentlabel" tag-val)
+      (emit-anchor node-name)
+      (do-label-aux tag-name))))
+
+(define do-htmlpagelabel
+  (lambda ()
+    (let ((label (get-peeled-group)))
+      (!label label *html-page-count* #f #f)
+      (write-label `(!label ,label ,*html-page-count* #f #f)))))
+
+(define do-ref
+  (lambda ()
+    (do-ref-aux (get-label) #f #f)))
+
+(define do-refexternal
+  (lambda ()
+    (let ((ext-file (get-peeled-group)))
+      (do-ref-aux (get-label) ext-file #f))))
+
+(define do-ref-aux
+  (lambda (label ext-file link-text)
+    (let* ((label-ref (label-bound? label ext-file))
+           (label-text
+            (cond (link-text (tex-string->html-string link-text))
+                  (label-ref (label.value label-ref))
+                  (else #f))))
+      (cond (label-ref (emit-ext-page-node-link-start
+                        (or ext-file (label.src label-ref))
+                        (label.page label-ref)
+                        (label.name label-ref))
+                       (emit label-text)
+                       (emit-link-stop))
+            (else (non-fatal-error label))))))
+
+(define maybe-label-page
+  (lambda (this-label-src this-label-pageno)
+    (if (and (not this-label-src) (= *html-page-count* this-label-pageno))
+        "" ;"#"
+        (string-append
+          (or this-label-src *jobname*)
+          (if (= this-label-pageno 0) ""
+              (string-append *html-page-suffix*
+                (number->string this-label-pageno)))
+         *output-extension*))))
+
+(define do-htmlref
+  (lambda ()
+    (let* ((text (get-group))
+           (lbl (get-peeled-group)))
+      (do-ref-aux lbl #f text))))
+
+(define do-htmlrefexternal
+  (lambda ()
+    (let* ((text (get-group))
+           (extf (get-peeled-group))
+           (lbl (get-peeled-group)))
+      (do-ref-aux lbl extf text))))
+
+(define do-hyperref
+  (lambda ()
+    (let* ((text (get-group))
+           (lbl (begin (get-group) (get-group) (get-peeled-group))))
+      (do-ref-aux lbl #f text))))
+
+(define do-hypertarget
+  (lambda ()
+    (let ((lbl (get-peeled-group)))
+      (do-tag-aux lbl "hypertarget"))))
+
+(define do-hyperlink
+  (lambda ()
+    (emit-link-start (fully-qualify-url (string-append "#" (get-peeled-group))))
+    (tex2page-string (get-token))
+    (emit-link-stop)))
+
+(define label-bound?
+  (lambda (label . ext-file)
+    (let* ((ext-file (if (pair? ext-file) (car ext-file) #f))
+           (label-table (if ext-file
+                            (table-get *external-label-tables* ext-file)
+                            *label-table*)))
+      (or (and label-table (table-get label-table label))
+          (begin
+           (flag-unresolved-xref
+            (if ext-file
+                (string-append "{" ext-file " -> " label "}")
+                label))
+           #f)))))
+
+(define flag-unresolved-xref
+  (lambda (xr)
+    (unless (member xr *unresolved-xrefs*)
+      (set! *unresolved-xrefs* (cons xr *unresolved-xrefs*))
+      ;(trace-if #t "Undefined label " xr)
+      )))
+
+(define flag-missing-piece
+  (lambda (mp)
+    (unless (member mp *missing-pieces*)
+      (set! *missing-pieces* (cons mp *missing-pieces*)))))
+
+(define show-unresolved-xrefs-and-missing-pieces
+  (lambda ()
+    (unless (and (null? *unresolved-xrefs*)
+                 (null? *missing-pieces*))
+      (show-unresolved-xrefs)
+      (show-missing-pieces)
+      (write-log ':separation-newline)
+      (write-log "Rerun: tex2page ")
+      (write-log *main-tex-file*)
+      (write-log ':separation-newline)
+      (write-log "If problem persists, check for ")
+      (write-log "missing \\label's and \\bibitem's"))))
+
+(define show-unresolved-xrefs
+  (lambda ()
+    (unless (null? *unresolved-xrefs*)
+      (write-log ':separation-newline)
+      (write-log "Unresolved cross-reference")
+      (when (> (length *unresolved-xrefs*) 1) (write-log "s"))
+      (write-log ": ")
+      (set! *unresolved-xrefs* (nreverse *unresolved-xrefs*))
+      (write-log (car *unresolved-xrefs*))
+      (for-each (lambda (x) (write-log #\,) (write-log ':separation-space)
+                  (write-log x))
+        (cdr *unresolved-xrefs*))
+      (write-log ':separation-newline))))
+
+(define show-missing-pieces
+  (lambda ()
+    (unless (null? *missing-pieces*)
+      (write-log ':separation-newline)
+      (when (memv ':document-title *missing-pieces*)
+        (write-log "Document title not determined")
+        (write-log ':separation-newline))
+      (when (memv ':last-page *missing-pieces*)
+        (write-log "Last page not determined")
+        (write-log ':separation-newline))
+      (when (memv ':last-modification-time *missing-pieces*)
+        (write-log "Last modification time not determined")
+        (write-log ':separation-newline))
+      (when (memv ':stylesheets *missing-pieces*)
+        (write-log "Style sheets not determined")
+        (write-log ':separation-newline))
+      (when (memv ':html-head *missing-pieces*)
+        (write-log "HTML header info not determined")
+        (write-log ':separation-newline))
+      (when (memv ':toc *missing-pieces*)
+        (write-log "Table of contents not determined")
+        (write-log ':separation-newline))
+      (cond ((memv ':fresh-index *missing-pieces*)
+             (write-log "Index not refreshed")
+             (write-log ':separation-newline))
+            ((memv ':index *missing-pieces*)
+             (write-log "Index not included")
+             (write-log ':separation-newline)))
+      (cond ((memv ':fresh-bibliography *missing-pieces*)
+             (write-log "Bibliography not refreshed")
+             (write-log ':separation-newline))
+            ((memv ':bibliography *missing-pieces*)
+             (write-log "Bibliography not included")
+             (write-log ':separation-newline)))
+      (when (memv ':metapost *missing-pieces*)
+        (write-log "MetaPost output not included")
+        (write-log ':separation-newline))
+;      (when (memv 'mfpic *missing-pieces*)
+;        (write-log "MFpic output not included")
+;        (write-log ':separation-newline))
+      )))
+
+(define do-pageref
+  (lambda ()
+    (let ((label-ref (label-bound? (get-peeled-group))))
+      (if label-ref
+          (let ((pageno (label.page label-ref)))
+            (emit-ext-page-node-link-start
+             (label.src label-ref) pageno #f)
+            (emit pageno)
+            (emit-link-stop))
+          (non-fatal-error "***")))))
+
+(define do-htmlpageref
+  (lambda ()
+    (let ((label (get-peeled-group)))
+      (let ((label-ref (label-bound? label)))
+        (emit "\"")
+        (if label-ref
+            (emit (maybe-label-page (label.src label-ref)
+                                    (label.page label-ref)))
+            ;above needs trailing # ?
+            (emit *log-file*))
+        (emit "\"")))))
+
+;URLs
+
+(define fully-qualify-url
+  (lambda (url)
+    (let ((n (string-length url)))
+      (cond  ((and (> n 0) (char=? (string-ref url 0) #\#))
+              (let* ((label (substring url 1 n))
+                     (label-ref (label-bound? label)))
+                (if label-ref
+                    (string-append
+                      (maybe-label-page (label.src label-ref)
+                                       (label.page label-ref))
+                     "#"
+                     (label.name label-ref))
+                    url)))
+            ((fully-qualified-url? url) url)
+            (else (ensure-url-reachable url)
+              url)))))
+
+(define do-url
+  (lambda ()
+    (let ((url (get-url)))
+      (emit-link-start (fully-qualify-url url))
+      (emit url)
+      (emit-link-stop))))
+
+(define do-mailto
+  (lambda ()
+    (let ((addr (get-url)))
+      (emit-link-start (string-append "mailto:" addr))
+      (emit addr)
+      (emit-link-stop))))
+
+(define do-urlh
+  (lambda ()
+    (emit-link-start (fully-qualify-url (get-url)))
+    (bgroup)
+    (tex2page-string
+     (string-append "\\def\\\\{\\egroup\\endinput}"
+                    (get-token)))
+    (egroup)
+    (emit-link-stop)))
+
+(define do-urlhd
+  (lambda ()
+    (do-urlh)
+    (get-token) ;throw away description meant for DVI
+    ))
+
+(define do-urlp
+  (lambda ()
+    (let ((link-text (get-token)))
+      (emit-link-start (fully-qualify-url (get-url)))
+      (tex2page-string link-text)
+      (emit-link-stop))))
+
+(define do-hlstart
+  (lambda ()
+    (let* ((cat (get-peeled-group))
+           (options (get-token))
+           (url (get-url)))
+      (when (string=? cat "url")
+        (emit-link-start (fully-qualify-url url))
+        (bgroup)
+        (tex-let "\\hlend" "\\TIIPhlend" #f))
+      (ignorespaces))))
+
+(define do-hlend
+  (lambda ()
+    (egroup)
+    (emit-link-stop)))
+
+(define do-htmladdimg
+  (lambda ()
+    (let* ((align-info (get-bracketed-text-if-any))
+           (url (fully-qualify-url (get-url))))
+      (emit "<img src=\"")
+      (emit url)
+      (emit "\" border=\"0\" ")
+      (when align-info
+        (tex2page-string align-info))
+      (emit " alt=\"[")
+      (emit url)
+      (emit "]\">"))))
+
+(define do-pdfximage
+  (lambda ()
+    (let ((height #f) (width #f) (depth #f))
+      (let loop ()
+        (cond ((eat-word "height") (set! height (get-pixels)) (loop))
+              ((eat-word "width") (set! width (get-pixels)) (loop))
+              ((eat-word "depth") (set! depth (get-pixels)) (loop))
+              (else #f)))
+      (emit "<img")
+      (when height
+        (emit " height=") (emit height))
+      (when width
+        (emit " width=") (emit width))
+      (emit " src=\"")
+      (emit (fully-qualify-url (get-filename-possibly-braced)))
+      ;(emit (fully-qualify-url (get-filename-possibly-braced)))
+      (emit "\">")
+      (ignorespaces) (get-ctl-seq) ; \pdfrefximage
+      (ignorespaces) (get-ctl-seq) ; \pdflastximage
+      )))
+
+;bibliography
+
+(define do-cite
+  (lambda ()
+    (let ((extra-text (get-bracketed-text-if-any)))
+      (emit "[")
+      (ignorespaces)
+      (unless (char=? (get-actual-char) #\{)
+        (terror 'do-cite "Missing {"))
+      (let ((first-key? #t))
+        (let loop ()
+          (cond ((get-csv)
+                 => (lambda (key)
+                      (if first-key? (set! first-key? #f)
+                          (begin (emit ",") (emit-nbsp 1)))
+                      (write-bib-aux "\\citation{")
+                      (write-bib-aux key)
+                      (write-bib-aux "}")
+                      (write-bib-aux #\newline)
+                      (do-ref-aux (string-append "cite{" key "}")
+                                  #f #f)
+                      (loop)))
+                (extra-text
+                  (emit ",")
+                  (emit-nbsp 1)
+                  (tex2page-string extra-text))))
+        (unless (char=? (get-actual-char) #\})
+          (terror 'do-cite "Missing }"))
+        (when first-key? (terror 'do-cite "Empty \\cite")))
+      (emit "]"))))
+
+(define do-nocite
+  (lambda ()
+    (ignorespaces)
+    (unless (char=? (get-actual-char) #\{) (terror 'do-cite "Missing {"))
+    (let loop ()
+      (cond ((get-csv)
+             => (lambda (key)
+                  (write-bib-aux "\\citation{")
+                  (write-bib-aux key)
+                  (write-bib-aux "}")
+                  (write-bib-aux #\newline)
+                  (loop)))))
+    (unless (char=? (get-actual-char) #\})
+      (terror 'do-nocite "Missing }"))
+    ))
+
+(define do-bibliographystyle
+  (lambda ()
+    (let ((s (ungroup (get-token))))
+      (write-bib-aux "\\bibstyle{")
+      (write-bib-aux s)
+      (write-bib-aux "}")
+      (write-bib-aux #\newline))))
+
+(define do-bibliography
+  (lambda ()
+    (set! *using-bibliography?* #t)
+    (let ((bibdata (ungroup (get-token)))
+          (bbl-file (string-append *aux-dir/* *jobname*
+                                   *bib-aux-file-suffix* ".bbl")))
+      (write-bib-aux "\\bibdata{")
+      (write-bib-aux bibdata)
+      (write-bib-aux "}")
+      (write-bib-aux #\newline)
+      ;(write-aux `(!using-external-program "bibtex"))
+      (cond ((file-exists? bbl-file) (set! *bibitem-num* 0)
+             (tex2page-file bbl-file)
+             (emit-newline))
+            (else
+             (flag-missing-piece ':bibliography)
+             (non-fatal-error
+              "Bibliography not generated; rerun TeX2page"))))))
+
+(define do-thebibliography
+  (lambda ()
+    (get-group)
+    (when (eqv? *tex-format* ':latex)
+      (tex2page-string
+        (if *using-chapters?*
+            "\\chapter*{\\bibname}" "\\section*{\\refname}")))
+    (bgroup)
+    (set! *bibitem-num* 0)
+    (tex2page-string "\\let\\em\\it")
+    (tex2page-string "\\def\\newblock{ }")
+    ;(tex2page-string "\\def\\providecommand#1#2{}")
+    (do-end-para)
+    (emit "<table>")
+    (emit-newline)))
+
+(define do-bibitem
+  (lambda ()
+    (let ((bibmark (get-bracketed-text-if-any)))
+      (do-end-para)
+      (unless (= *bibitem-num* 0)
+        (emit "</td></tr>")
+        (emit-newline))
+      (set! *bibitem-num* (+ *bibitem-num* 1))
+      (emit "<tr><td align=right valign=top>")
+      (let* ((bibitem-num-s (number->string *bibitem-num*))
+             (key (string-append "cite{" (get-peeled-group) "}"))
+             (node-name (string-append *html-node-prefix* "bib_"
+                                       bibitem-num-s)))
+        ;wrap key with cite{...} so key can be used
+        ;as a regular label also (for something else)
+        (tex-def-0arg "\\TIIPcurrentnodename" node-name)
+        (unless bibmark
+          (set! bibmark bibitem-num-s))
+        (tex-def-0arg "\\@currentlabel" bibmark)
+        (emit-anchor node-name)
+        (emit "[")
+        (tex2page-string bibmark)
+        (emit "]")
+        (emit-nbsp 2)
+        (do-label-aux key)
+        (emit "</td><td valign=top>")
+        ))))
+
+;index
+
+(define display-index-entry
+  ;like display, but sub space for newline
+  (lambda (s o)
+    (for-each
+      (lambda (c)
+        (display
+          (if (or ;(char=? c *return*)
+                (char=? c #\newline))
+              #\space
+              c)
+          o))
+      (string->list s))))
+
+(define do-index
+  (lambda ()
+    (let ((idx-entry (ungroup (get-group))))
+      (ignorespaces) ;?
+      (unless (substring? "|)" idx-entry)
+        (set! *index-count* (+ *index-count* 2))
+        ;
+        ;increment by 2 rather than 1, effectively disabling
+        ;makeindex from creating ranges, which are meaningless for
+        ;HTML.  Actually, makeindex called with the -r option prevents
+        ;ranging but who remembers these things?
+        ;
+        (!index *index-count* *html-page-count*)
+        (write-aux
+          `(!index ,*index-count* ,*html-page-count*))
+        ;(set! *index-table*
+        ;      (cons (cons *index-count* *html-page-count*) *index-table*))
+        (let ((tag (string-append *html-node-prefix* "idx_"
+                                  (number->string *index-count*))))
+          (emit-anchor tag)
+          (unless *index-port*
+            (let ((idx-file (string-append *aux-dir/* *jobname*
+                                           *index-file-suffix* ".idx")))
+              (ensure-file-deleted idx-file)
+              (set! *index-port* (open-output-file idx-file))))
+          (display "\\indexentry{" *index-port*)
+          (cond ((substring? "|see{" idx-entry)
+                 (display-index-entry idx-entry *index-port*))
+                ((substring? "|seealso{" idx-entry)
+                 (display-index-entry idx-entry *index-port*))
+                ((substring? "|(" idx-entry)
+                 => (lambda (i)
+                      (display-index-entry (substring idx-entry 0 i)
+                                           *index-port*)
+                      (display "|expandhtmlindex" *index-port*)))
+                (else (display-index-entry idx-entry *index-port*)
+                      (display "|expandhtmlindex" *index-port*)))
+          (display "}{" *index-port*)
+          (display *index-count* *index-port*)
+          (display "}" *index-port*)
+          (newline *index-port*))))))
+
+(define do-inputindex
+  (lambda (insert-heading?)
+    (set! *using-index?* #t)
+    (when insert-heading?
+      (tex2page-string
+       (if *using-chapters?*
+           "\\chapter*{\\indexname}" "\\section*{\\indexname}"))
+      (emit-newline))
+    (emit-anchor (string-append *html-node-prefix* "index_start"))
+    (!index-page *html-page-count*)
+    (write-aux `(!index-page ,*html-page-count*))
+    (let ((ind-file (string-append *aux-dir/* *jobname*
+                                   *index-file-suffix* ".ind")))
+      ;(write-aux `(!using-external-program "makeindex"))
+      (cond ((file-exists? ind-file)
+             (tex2page-file ind-file))
+            (else
+             (flag-missing-piece ':index)
+             (non-fatal-error "Index not generated; rerun TeX2page"))))))
+
+(define do-theindex
+  (lambda ()
+    (bgroup)
+    (tex2page-string "\\let\\endtheindex\\egroup")
+    (tex2page-string "\\let\\indexspace\\medskip")
+    (tex2page-string "\\let\\item\\indexitem")
+    (tex2page-string "\\let\\subitem\\indexsubitem")
+    (tex2page-string "\\let\\subsubitem\\indexsubsubitem")
+    (tex2page-string "\\let\\(\\expandhtmlindex")))
+
+(define expand-html-index
+  (lambda ()
+    (let* ((s (get-peeled-group))
+           (n (string->number s))
+           (pageno (table-get *index-table* n)))
+      (emit-page-node-link-start
+        pageno (string-append *html-node-prefix* "idx_" s))
+      (emit pageno)
+      (cond ((table-get *index-page-mention-alist* pageno)
+             => (lambda (c)
+                  (let ((n (+ 1 c)))
+                    (emit (number->roman n #f))
+                    (table-put! *index-page-mention-alist* pageno n))))
+            (else
+              (table-put! *index-page-mention-alist* pageno 1)))
+      (emit-link-stop))))
+
+(define do-see-also
+  (lambda ()
+    (let* ((other-entry (get-group))
+           (discard (get-group)))
+      (emit "<em>see also</em> ")
+      (tex2page-string other-entry))))
+
+(define do-indexitem
+  (lambda (indent)
+    (set! *index-page-mention-alist* (make-table))
+    (emit "<br>") (emit-newline)
+    (emit-nbsp (* indent 4))))
+
+;item
+
+(define do-description-item
+  (lambda ()
+    (do-end-para)
+    (emit "</dd><dt>")
+    (let ((thing (get-bracketed-text-if-any)))
+      (when thing
+        (set! thing (string-trim-blanks thing))
+        (unless (string=? thing "")
+          (bgroup)
+          (emit "<b>")
+          (tex2page-string thing)
+          (emit "</b>")
+          ;(emit-nbsp 2)
+          (egroup)
+          )))
+    (emit "</dt><dd>")))
+
+(define do-regular-item
+  (lambda ()
+    (do-end-para)
+    (emit "<li>")
+    (do-para)
+    (let ((thing (get-bracketed-text-if-any)))
+      (when thing
+        (emit "<b>")
+        (bgroup)
+        (tex2page-string thing)
+        (egroup)
+        (emit "</b>")
+        (emit-nbsp 2)))))
+
+(define do-plain-item
+  (lambda (n)
+    (let ((parindent (sp-to-pixels (find-dimen "\\parindent"))))
+      (do-end-para)
+      (emit "<table><tr><td width=")
+      (emit parindent)
+      (emit " valign=top align=right>")
+      (let loop ((n n))
+        (unless (<= n 1)
+          (emit "</td><td width=")
+          (emit parindent)
+          (emit " valign=top align=right>")
+          (loop (- n 1))))
+      (tex2page-string (get-group))
+      (emit-nbsp 2)
+      (emit "</td><td>")
+      (do-noindent)
+      (add-afterpar (lambda () (emit "</td></tr></table>"))))))
+
+(define do-textindent
+  (lambda ()
+    (let ((parindent (sp-to-pixels (find-dimen "\\parindent"))))
+      (do-indent)
+      (emit "<span style=\"margin-left: ")
+      (emit parindent)
+      (emit "pt\">&zwnj;</span>")
+      (emit "<span style=\"position: relative\">&zwnj;")
+      (emit "<span style=\"position: absolute; left: -")
+      (emit parindent)
+      (emit "pt\">")
+      (tex2page-string (get-group))
+      (ignorespaces)
+      (emit-nbsp 2)
+      (emit "</span></span>"))))
+
+(define do-item
+  (lambda ()
+    (let ((a #f))
+      (unless (null? *tabular-stack*)
+        (set! a (car *tabular-stack*)))
+      (case a
+        ((:description) (do-description-item))
+        ((:itemize :enumerate) (do-regular-item))
+        (else (do-plain-item 1))))))
+
+;vert space
+
+(define do-bigskip
+  (lambda (type)
+    (do-end-para)
+    (emit "<div class=")
+    (emit (case type
+            ((:medskip) "medskip")
+            ((:bigskip) "bigskip")
+            (else "smallskip")))
+    (emit "></div>")
+    (emit-newline)
+    (emit "<p style=\"margin-top: 0pt; margin-bottom: 0pt\">")
+    (set! *in-para?* #t)
+    (emit-newline)))
+
+(define do-hspace
+  (lambda ()
+    (ignorespaces)
+    (when (eqv? (snoop-actual-char) #\*) (get-actual-char))
+    (get-group)
+    (emit-nbsp 3)))
+
+(define do-vspace
+  (lambda ()
+    (ignorespaces)
+    (when (eqv? (snoop-actual-char) #\*) (get-actual-char))
+    (get-group)
+    (do-bigskip ':vspace)))
+
+(define do-htmlmathstyle
+  (lambda ()
+    (call-with-input-string/buffered
+     (ungroup (get-group))
+     (lambda ()
+       (let loop ()
+         (ignore-all-whitespace)
+         (let ((c (snoop-actual-char)))
+           (unless (eof-object? c)
+             (case (string->symbol (scm-get-token))
+               ((image display-image)
+                (tex-def-0arg "\\TZPmathimage" "1"))
+               ((no-image no-display-image)
+                (tex-def-0arg "\\TZPmathimage" "0")))
+             (loop))))))))
+
+;
+
+(define do-htmldoctype
+  (lambda ()
+    (let ((d (get-peeled-group)))
+      (when (string=? d "")
+        (set! d 'none))
+      (write-aux `(!doctype ,d)))))
+
+;timestamp
+
+(define do-htmlcolophon
+  (lambda ()
+    (call-with-input-string/buffered
+      (ungroup (get-group))
+      (lambda ()
+        (let loop ()
+          (ignore-all-whitespace)
+          (let ((c (snoop-actual-char)))
+            (unless (eof-object? c)
+              (let ((directive (string->symbol (scm-get-token))))
+                (!colophon directive)
+                (write-aux `(!colophon ,directive))
+                (loop)))))))))
+
+(define output-colophon
+  (lambda ()
+    (let ((colophon-mentions-last-mod-time?
+            (tex2page-flag-boolean "\\TZPcolophontimestamp"))
+          (colophon-mentions-tex2page?
+            (tex2page-flag-boolean "\\TZPcolophoncredit"))
+          (colophon-links-to-tex2page-website?
+            (tex2page-flag-boolean "\\TZPcolophonweblink")))
+      (when (or colophon-mentions-last-mod-time?
+                colophon-mentions-tex2page?)
+        ;(do-para)
+        (do-end-para)
+        (emit "<div align=right class=colophon>")
+        ;(emit-newline)
+        (when (and colophon-mentions-last-mod-time?
+                   *last-modification-time*
+                   (> *last-modification-time* 0))
+          (tex2page-string *last-modified*) (emit ": ")
+          (emit (seconds->human-time *last-modification-time*))
+          (emit "<br>") ;(emit-newline)
+          )
+        (when colophon-mentions-tex2page?
+          (emit "<div align=right class=advertisement>")
+          ;(emit-newline)
+          (tex2page-string *html-conversion-by*)
+          (emit " ")
+          (when colophon-links-to-tex2page-website?
+            (emit-link-start
+              "http://evalwhen.com/tex2page/index.html"))
+          (emit *tex-logo*) (emit "2page ")
+          (emit *tex2page-version*)
+          (when colophon-links-to-tex2page-website?
+            (emit-link-stop))
+          (emit "</div>")
+          ;(emit-newline)
+          )
+        (emit "</div>")
+        (emit-newline)))))
+
+; html pages
+
+(define point-to-adjacent-pages
+  (lambda ()
+    (let* ((last-page-not-determined? (< *last-page-number* 0))
+           (prev-page (cond ((= *html-page-count* 0) #f)
+                            ((= *html-page-count* 1)
+                             (string-append *jobname*
+                                            *output-extension*))
+                            (else (string-append
+                                    *jobname*
+                                    *html-page-suffix*
+                                    (number->string (- *html-page-count* 1))
+                                    *output-extension*))))
+           (next-page (cond ((= *html-page-count* *last-page-number*) #f)
+                            (else (string-append
+                                    *jobname*
+                                    *html-page-suffix*
+                                    (number->string (+ *html-page-count* 1))
+                                    *output-extension*)))))
+      (unless (= *last-page-number* 0)
+        (when prev-page (emit-link-start prev-page))
+        (emit "&lt;&middot;&middot;&middot;Prev ")
+        (when prev-page (emit-link-stop))
+        (emit "||")
+        (when next-page (emit-link-start next-page))
+        (emit " Next&middot;&middot;&middot;&gt;")
+        (when next-page (emit-link-stop))))))
+
+(define output-head-or-foot-line
+  (lambda (head-or-foot)
+    (emit "<div align=right class=navigation>")
+    (cond ((or *tex-like-layout?*
+               (and (eq? head-or-foot ':foot)
+                    (tex2page-flag-boolean "\\TZPtexlayout")))
+           (bgroup)
+           (tex-let "\\folio" "\\TIIPfolio" #f)
+           (tex2page-string
+             (if (eq? head-or-foot ':head)
+                 "\\the\\headline"
+                 "\\the\\footline"))
+           (egroup))
+          (else (output-navigation-bar head-or-foot)))
+    (emit "</div>")
+    (emit-newline)))
+
+(define output-navigation-bar
+  (lambda (head-or-foot)
+    ;(do-end-para)
+    (let* ((first-page? (= *html-page-count* 0))
+           (last-page-not-determined? (< *last-page-number* 0))
+           (last-page? (= *html-page-count* *last-page-number*))
+           (toc-page? (and *toc-page* (= *html-page-count* *toc-page*)))
+           (index-page? (and *index-page* (= *html-page-count* *index-page*)))
+           (first-page (string-append *jobname*
+                                      *output-extension*))
+           (prev-page (cond (first-page? #f)
+                            ((= *html-page-count* 1) first-page)
+                            (else (string-append
+                                    *jobname*
+                                    *html-page-suffix*
+                                    (number->string (- *html-page-count* 1))
+                                    *output-extension*))))
+           (next-page (cond (last-page? #f)
+                            (else (string-append
+                                    *jobname*
+                                    *html-page-suffix*
+                                    (number->string (+ *html-page-count* 1))
+                                    *output-extension*)))))
+      (unless (and first-page?
+                   (or last-page?
+                       (and (eq? head-or-foot ':head)
+                            last-page-not-determined?)))
+        (emit "[")
+        (emit *navigation-sentence-begin*)
+        ;
+        (emit "<span")
+        (when first-page? (emit " class=disable"))
+        (emit ">")
+        (unless first-page?  (emit-link-start first-page))
+        (emit *navigation-first-name*)
+        (unless first-page? (emit-link-stop))
+        (emit ", ")
+        ;
+        (unless first-page?  (emit-link-start prev-page))
+        (emit *navigation-previous-name*)
+        (unless first-page? (emit-link-stop))
+        ;(emit ", ")
+        (emit "</span>")
+        ;
+        (emit "<span")
+        (when last-page? (emit " class=disable"))
+        (emit ">")
+        (when first-page? (emit "<span class=disable>"))
+        (emit ", ")
+        (when first-page? (emit "</span>"))
+        (unless last-page?  (emit-link-start next-page))
+        (emit *navigation-next-name*)
+        (unless last-page? (emit-link-stop))
+        (emit "</span>")
+        ;
+        (emit *navigation-page-name*)
+        ;
+        (when (or *toc-page* *index-page*)
+          (emit "<span")
+          (when (or (and toc-page? (not *index-page*) (not index-page?))
+                    (and index-page? (not *toc-page*) (not toc-page?)))
+            (emit " class=disable"))
+          (emit ">; ")
+          (emit-nbsp 2)
+          (emit "</span>")
+          ;
+          (when *toc-page*
+            (emit "<span")
+            (when toc-page? (emit " class=disable"))
+            (emit ">")
+            (unless toc-page?
+              (emit-page-node-link-start
+                *toc-page* (string-append *html-node-prefix* "toc_start")))
+            (emit *navigation-contents-name*)
+            (unless toc-page? (emit-link-stop))
+            (emit "</span>"))
+          ;
+          (when *index-page*
+            (emit "<span")
+            (when index-page? (emit " class=disable"))
+            (emit ">")
+            (emit "<span")
+            (unless (and *toc-page* (not toc-page?))
+              (emit " class=disable"))
+            (emit ">")
+            (when *toc-page*
+              (emit "; ")
+              (emit-nbsp 2))
+            (emit "</span>")
+            (unless index-page?
+              (emit-page-node-link-start
+                *index-page*
+                (string-append *html-node-prefix* "index_start")))
+            (emit *navigation-index-name*)
+            (unless index-page? (emit-link-stop))
+            (emit "</span>")))
+        (emit *navigation-sentence-end*)
+        (emit "]")))))
+
+(define do-eject
+  (lambda ()
+
+    ;kludge: don't start a new page if \eject is the
+    ;last thing in the main file.  This is mostly
+    ;to placate story.tex, which although horrid as an
+    ;example file, happens to be viewed as canonical by
+    ;everyone looking at TeX
+
+    (unless (and (eof-object? (snoop-actual-char))
+                 (eqv? *current-source-file* *main-tex-file*))
+      ;
+      (unless (> *last-page-number* 0) ;???
+        (flag-missing-piece ':last-modification-time))
+      (do-end-page)
+      ;
+      (set! *html-page-count* (+ *html-page-count* 1))
+      (set! *html-page*
+        (string-append *aux-dir/*
+          *jobname* *html-page-suffix*
+          (number->string *html-page-count*)
+                       *output-extension*))
+      (ensure-file-deleted *html-page*)
+      (set! *html* (open-output-file *html-page*))
+      (do-start))))
+
+(define output-html-preamble
+  (lambda ()
+    (when (string? *doctype*)
+      (emit "<!doctype ")
+      (emit *doctype*)
+      (emit ">")
+      (emit-newline))
+    (emit "<html>") (emit-newline)
+    (emit "<!--") (emit-newline)
+    (emit-newline)
+    (emit "Generated from ")
+    (emit *main-tex-file*)
+    (emit " by tex2page, ")
+    (emit "v ") (emit *tex2page-version*) (emit-newline)
+    (emit "(running on ")
+    (emit *scheme-version*) (emit ", ")
+    (emit *operating-system*) (emit "), ") (emit-newline)
+    (emit "(c) Dorai Sitaram, ") (emit-newline)
+    (emit *tex2page-website*) (emit-newline)
+    (emit-newline)
+    (emit "-->")
+    (emit-newline)
+    (emit "<head>") (emit-newline)
+    (emit "<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">")
+    (emit-newline)
+    (output-external-title)
+    (link-stylesheets)
+    (emit "<meta name=robots content=\"index,follow\">")
+    (emit-newline)
+    (for-each emit *html-head*)
+    (emit "</head>") (emit-newline)
+    (emit "<body>") (emit-newline)
+    (emit "<div id=")
+    (emit (if (and (= *html-page-count* 0) *title*)
+              "slidetitle"
+              "slidecontent"))
+    (emit ">") (emit-newline)
+    ))
+
+(define output-html-postamble
+  (lambda ()
+    (do-end-para)
+    (emit "</div>") (emit-newline)
+    (emit "</body>") (emit-newline)
+    (emit "</html>") (emit-newline)))
+
+(define do-start
+  (lambda ()
+    (set! *footnote-list* '())
+    (output-html-preamble)
+    (output-head-or-foot-line ':head)
+    (do-para)))
+
+(define do-end-page
+  (lambda ()
+    (do-end-para)
+    (output-footnotes)
+    (do-bigskip ':smallskip)
+    (output-head-or-foot-line ':foot)
+    (do-para)
+    (let ((colophon-on-last-page? (tex2page-flag-boolean "\\TZPcolophonlastpage")))
+      (when (or (and (not colophon-on-last-page?)
+                     (= *html-page-count* 0))
+                (and colophon-on-last-page?
+                     (= *html-page-count* *last-page-number*)))
+        (output-colophon)))
+    (output-html-postamble)
+    (write-log #\[)
+    (write-log *html-page-count*)
+    (write-log #\])
+    (write-log ':separation-space)
+    (close-output-port *html*)))
+
+(define close-all-open-ports
+  (lambda ()
+    (when *aux-port* (close-output-port *aux-port*))
+    (when *css-port* (close-output-port *css-port*))
+    (when *index-port* (close-output-port *index-port*))
+    (when *label-port* (close-output-port *label-port*))
+    (when *bib-aux-port* (close-output-port *bib-aux-port*))
+    (when *verb-port* (close-output-port *verb-port*))
+    (table-for-each *input-streams*
+                    (lambda (k v)
+                      (unless (eq? v ':free)
+                      (close-input-port v))))
+    (table-for-each *output-streams*
+                    (lambda (k v)
+                      (unless (eq? v ':free)
+                      (close-output-port v))))))
+
+(define output-stats
+  (lambda ()
+    (write-log ':separation-newline)
+    (cond (*main-tex-file*
+           (let ((num-pages (+ *html-page-count* 1)))
+             (write-log "Output written on ")
+             (write-log *aux-dir/*)
+             (write-log *jobname*)
+             (write-log *output-extension*)
+             ;(write-log (string-append *aux-dir/* *jobname* *output-extension*))
+             ;(set! *write-log-index* 0)
+             (when (> num-pages 1)
+               (write-log ", ..."))
+             (write-log " (")
+             (write-log num-pages)
+             (write-log " page")
+             (unless (= num-pages 1)
+               (write-log #\s)))
+           ;
+           (when (> *img-file-tally* 0)
+             (write-log ", ")
+             (write-log *img-file-tally*)
+             (write-log " image")
+             (unless (= *img-file-tally* 1)
+               (write-log #\s)))
+           ;
+           (write-log ")."))
+          (else
+           (write-log "No pages of output.")))
+    ;(write-log ':separation-newline)
+    (write-log #\newline)
+    (when *log-port* (close-output-port *log-port*))
+    (display "Transcript written on ")
+    (display *log-file*)
+    (display ".")
+    (newline)))
+
+(define do-bye
+  (lambda ()
+    (note-down-tex2page-flags)
+    (unless (null? *tex-if-stack*)
+      (let ((n (length *tex-if-stack*)))
+        (trace-if #t "(\\end occurred when " n " \\if"
+                  (if (> n 1) "s were" " was") " incomplete)")
+        ;(trace-if #t "Found " n " incomplete \\if"
+        ;          (if (> n 1) "s" ""))
+        ))
+    (unless (null? *tex-env*)
+      (trace-if #t "\\end occurred inside a group at level "
+                (length *tex-env*)))
+    (perform-postludes)
+    ;(perform-aftergroups)
+    (unless (or (>= *last-page-number* 0)
+                (= *html-page-count* 0))
+      (flag-missing-piece ':last-page))
+    (!last-page-number *html-page-count*)
+    ;(set! *last-page-number* *html-page-count*)
+    ;(when (> *last-page-number* 1)
+    (write-aux `(!last-page-number ,*last-page-number*))
+    ;)
+    (do-end-page)
+    (when *last-modification-time*
+      (write-aux `(!last-modification-time ,*last-modification-time* ,*epoch*)))
+    (for-each
+      (lambda (th) (th))
+      *afterbye*)
+    ;(note-down-tex2page-flags)
+    (close-all-open-ports)
+    (call-external-programs-if-necessary)
+    (show-unresolved-xrefs-and-missing-pieces)
+    ;(output-stats)
+    ))
+
+(define note-down-tex2page-flags
+  (lambda ()
+    (write-aux `(!head-line ,(get-toks "\\headline")))
+    (write-aux `(!foot-line ,(get-toks "\\footline")))
+    (cond ((find-def "\\TZPtitle")
+           => (lambda (d)
+                (write-aux
+                  `(!preferred-title
+                     ,(tex-string->html-string (tdef.expansion d)))))))
+    (cond ((find-def "\\TZPredirect")
+           => (lambda (d)
+                (write-aux
+                  `(!html-head ,(string-append
+                                  "<meta http-equiv=\"refresh\" content=\"0;"
+                                  (tdef.expansion d) "\">"))))))
+    (when (tex2page-flag-boolean "\\TZPslides")
+      (tex2page-file (actual-tex-filename "t2pslides" #f)))
+    (when (tex2page-flag-boolean "\\TZPtexlayout")
+      (write-aux `(!tex-like-layout))
+      (newline *css-port*)
+      (display "body { margin-top: " *css-port*)
+      (display (sp-to-ems (+ (tex-length .5 ':in) ;1in is too much!
+                             (find-dimen "\\voffset"))) *css-port*)
+      (display "em; }" *css-port*)
+      (newline *css-port*)
+      (display "body { margin-left: " *css-port*)
+      (display (sp-to-ems (+ (tex-length .8 ':in)
+                             (find-dimen "\\hoffset"))) *css-port*)
+      (display "em; }" *css-port*)
+      (newline *css-port*)
+      (unless (tex2page-flag-boolean "\\TZPraggedright")
+        (display "body { text-align: justify; }" *css-port*)
+        (newline *css-port*))
+      (display "p { margin-bottom: 0pt; }" *css-port*)
+      (newline *css-port*)
+      (display "p { text-indent: " *css-port*)
+      (display (sp-to-pixels (find-dimen "\\parindent")) *css-port*)
+      (display "pt; }" *css-port*)
+      (newline *css-port*)
+      (display "p { margin-top: " *css-port*)
+      (display (sp-to-pixels (find-dimen "\\parskip")) *css-port*)
+      (display "pt; }" *css-port*)
+      (newline *css-port*)
+      (display ".mathdisplay { margin-top: " *css-port*)
+      (display (sp-to-pixels (find-dimen "\\abovedisplayskip")) *css-port*)
+      (display "pt; margin-bottom: " *css-port*)
+      (display (sp-to-pixels (find-dimen "\\belowdisplayskip")) *css-port*)
+      (display "pt; }" *css-port*)
+      (newline *css-port*)
+      (display "body { max-width: " *css-port*)
+      (display (sp-to-pixels (find-dimen "\\hsize")) *css-port*)
+      (display "pt; }" *css-port*)
+      (newline *css-port*)
+      (display ".navigation { color: black; font-style: normal; }" *css-port*)
+      (newline *css-port*)
+      )))
+
+(define insert-missing-end
+  (lambda ()
+    (write-log ':separation-newline)
+    (write-log "! Missing \\end inserted.")
+    (write-log ':separation-newline)))
+
+;diacritics
+
+(define do-diacritic
+  (let ((top-diacritics
+         '(:grave :acute :circumflex :umlaut :tilde :macron :breve
+           :hacek :hungarianumlaut :ring)))
+    (lambda (diac)
+      (let ((x (get-token-or-peeled-group)))
+        (cond ((and (string=? x "\\i") (member diac top-diacritics))
+               (emit "i"))
+              ((and (string=? x "\\j") (member diac top-diacritics))
+               (emit "j"))
+              (else (tex2page-string x))))
+      (emit
+       (case diac
+         ((:grave) "&#x300;")
+         ((:acute) "&#x301;")
+         ((:circumflex) "&#x302;")
+         ((:umlaut) "&#x308;")
+         ((:tilde) "&#x303;")
+         ((:macron) "&#x304;")
+         ((:dot) "&#x307;")
+         ((:breve) "&#x306;")
+         ((:hacek) "&#x30c;")
+         ((:hungarianumlaut) "&#x30b;")
+         ((:cedilla) "&#x327;")
+         ((:dotunder) "&#x323;")
+         ((:barunder) "&#x331;")
+         ((:tieafter) "&#x361;")
+         ((:ring) "&#x30a;")
+         ((:ogonek) "&#x328;")
+         (else (terror 'do-diacritic
+                       diac " is not a valid diacritic")))))))
+
+;Math
+
+(define do-mathdg
+  (lambda ()
+    (fluid-let ((*math-mode?* #t) (*in-display-math?* #t)
+                (*tabular-stack* '()) (*ligatures?* #f))
+      (do-end-para)
+      (emit "<div align=")
+      (emit *display-justification*)
+      (emit "><table><tr><td>")
+      (tex2page-string (get-group))
+      (emit "</td></tr></table></div>")
+      (do-para))))
+
+(define do-mathg
+  (lambda ()
+    (fluid-let ((*math-mode?* #t) (*in-display-math?* #f)
+                (*tabular-stack* '()) (*ligatures?* #f))
+      (tex2page-string (get-group)))))
+
+(define dump-tex-preamble
+  (lambda (o)
+    (case *tex-format*
+      ((:latex)
+       (display "\\documentclass{" o)
+       (display (if *using-chapters?* "report" "article") o)
+       (display "}" o) (newline o)
+       (display *imgpreamble* o) (newline o)
+       (display "\\ifx\\bmatrix\\UNDEFINED" o)
+       (display "\\usepackage{amsmath}\\fi" o) (newline o)
+       (when (memv ':includegraphics *imgpreamble-inferred*)
+         (display "\\ifx\\includegraphics\\UNDEFINED" o)
+         (display "\\usepackage{graphicx}\\fi" o)
+         (newline o))
+       (when (memv ':epsfbox *imgpreamble-inferred*)
+         (display "\\ifx\\epsfbox\\UNDEFINED" o)
+         (display "\\usepackage{epsfig}\\fi" o)
+         (newline o))
+       (display "\\thispagestyle{empty}" o) (newline o)
+       (display "\\begin{document}" o) (newline o))
+      (else
+       (display *imgpreamble* o) (newline o)
+       (when (memv ':includegraphics *imgpreamble-inferred*)
+         (display "\\ifx\\resetatcatcode\\UNDEFINED" o)
+         (display "\\input miniltx \\fi" o)
+         (newline o)
+         (display "\\ifx\\includegraphics\\UNDEFINED" o)
+         (display "\\input graphicx.sty \\fi" o)
+         (newline o))
+       (when (memv ':epsfbox *imgpreamble-inferred*)
+         (display "\\ifx\\epsfbox\\UNDEFINED" o)
+         (display "\\ifx\\pdfoutput\\UNDEFINED\\input epsf \\else" o)
+         (display "\\input supp-pdf " o)
+         (display "\\def\\epsfbox#1{\\convertMPtoPDF{#1}{1}{1}}\\fi" o)
+         (newline o))
+       (display "\\nopagenumbers" o) (newline o)))))
+
+(define dump-tex-postamble
+  (lambda (o)
+    (case *tex-format*
+      ((:latex)
+       (display "\\end{document}" o) (newline o))
+      (else
+        (display "\\bye" o) (newline o)))))
+
+(define skipping-img-file
+  (lambda ()
+    (set! *img-file-count* (+ *img-file-count* 1))))
+
+(define next-html-image-file-stem
+  (lambda ()
+    (set! *img-file-count* (+ *img-file-count* 1))
+    (string-append *subjobname* *img-file-suffix*
+                   (number->string *img-file-count*))))
+
+(define call-with-html-image-port
+  (lambda (p . alt)
+    (let* ((alt (if (null? alt) #f (car alt)))
+           (img-file-stem (next-html-image-file-stem))
+           (aux-tex-file (string-append img-file-stem ".tex")))
+      (ensure-file-deleted aux-tex-file)
+      (call-with-output-file aux-tex-file
+        (lambda (o)
+          (dump-tex-preamble o)
+          (p o)
+          (dump-tex-postamble o)))
+      (tex-to-img img-file-stem)
+      (source-img-file img-file-stem alt))))
+
+(define do-math-fragment
+  (lambda (s display-p)
+    (when display-p
+      (emit "<div class=mathdisplay align=")
+      (emit *display-justification*)
+      (emit ">")
+      (emit "<table><tr><td>"))
+    (let ((old-math-mode-p *math-mode?*)
+          (old-in-display-math-p *in-display-math?*)
+          (old-tabular-stack *tabular-stack*))
+      (set! *math-mode?* #t)
+      (set! *in-display-math?* display-p)
+      (set! *tabular-stack* '())
+      (bgroup)
+      (toss-back-char #\})
+      (toss-back-string s)
+      (add-aftergroup-to-top-frame
+       (lambda ()
+         (set! *math-mode?* old-math-mode-p)
+         (set! *in-display-math?* old-in-display-math-p)
+         (set! *tabular-stack* old-tabular-stack)
+         (when display-p
+           (emit "</td></tr></table>")
+           (emit "</div>")
+           (do-noindent)))))))
+
+(define do-display-math
+  (lambda (tex-string)
+    (do-end-para)
+    (if (and (tex2page-flag-boolean "\\TZPmathimage")
+             (not *temporarily-use-utf8-for-math?*))
+        (begin
+         (emit "<div class=mathdisplay align=")
+         (emit *display-justification*)
+         (emit ">")
+         (call-with-html-image-port
+          (lambda (o) (display "$$" o) (display tex-string o) (display "$$" o))
+          tex-string)
+         (emit "</div>")
+         (do-noindent))
+      (do-math-fragment tex-string ':display))))
+
+(define tex-math-delim-string
+  (lambda (type)
+    (let ((top #f) (mid #f) (bot #f) (ext #f))
+      (case type
+        ((:lparen) (set! top "&#x239b;")
+                   (set! bot "&#x239d;")
+                   (set! ext "&#x239c;")
+                   (set! mid ext))
+        ((:lbrack) (set! top "&#x23a1;")
+                   (set! bot "&#x23a3;")
+                   (set! ext "&#x23a2;")
+                   (set! mid ext))
+        ((:lbrace) (set! top "&#x23a7;")
+                   (set! mid "&#x23a8;")
+                   (set! bot "&#x23a9;")
+                   (set! ext "&#x23aa;"))
+        ((:lvert) (set! ext "&#x239c;")
+                  (set! top ext)
+                  (set! mid ext)
+                  (set! bot ext))
+        ((:rparen) (set! top "&#x239e;")
+                   (set! bot "&#x23a0;")
+                   (set! ext "&#x239f;")
+                   (set! mid ext))
+        ((:rbrack) (set! top "&#x23a4;")
+                   (set! bot "&#x23a6;")
+                   (set! ext "&#x23a5;")
+                   (set! mid ext))
+        ((:rbrace) (set! top "&#x23ab;")
+                   (set! mid "&#x23ac;")
+                   (set! bot "&#x23ad;")
+                   (set! ext "&#x23ae;"))
+        ((:rvert) (set! ext "&#x239f;")
+                  (set! top ext)
+                  (set! mid ext)
+                  (set! bot ext))
+        (else (terror 'tex-math-delim-string "bad delim" type)))
+      (string-append
+       "<table cellpadding=0 cellspacing=0><tr><td>" top "</td></tr>"
+       (cond ((odd? *math-height*)
+              (string-append
+               (let loop ((r "") (i (/ (- *math-height* 1) 2)))
+                 (if (<= i 0) r
+                   (loop (string-append r
+                                        "<tr><td>"
+                                        ext
+                                        "</td></tr>") (- i 1))))
+               "<tr><td>"
+               mid
+               "</td></tr>"
+               (let loop ((r "") (i (/ (- *math-height* 1) 2)))
+                 (if (<= i 0) r
+                   (loop (string-append r
+                                        "<tr><td>"
+                                        ext
+                                        "</td></tr>") (- i 1))))))
+             (else
+              (let loop ((r "") (i *math-height*))
+                (if (<= i 0) r
+                  (loop (string-append r
+                                       "<tr><td>"
+                                       ext
+                                       "</td></tr>") (- i 1))))))
+       "<tr><td>" bot "</td></tr></table>"))))
+
+(define tex-math-string-to-html-string
+  (lambda (s)
+    (let ((tmp-port (open-output-string)))
+      (fluid-let ((*html* tmp-port))
+        (call-with-input-string/buffered ""
+          (lambda ()
+            (do-math-fragment s #f)
+            (generate-html))))
+      (get-output-string tmp-port))))
+
+(define do-intext-math
+  (lambda (tex-string)
+    (fluid-let ((*math-needs-image?* #f))
+      (let ((html-string (tex-math-string-to-html-string tex-string)))
+        (if (and (tex2page-flag-boolean "\\TZPmathimage")
+                 *math-needs-image?*
+                 (not *temporarily-use-utf8-for-math?*))
+            (call-with-html-image-port
+             (lambda (o) (display #\$ o) (display tex-string o) (display #\$ o))
+             tex-string)
+          (emit html-string))))))
+
+(define do-mathp
+  (lambda ()
+      (call-with-html-image-port
+        (lambda (o)
+          (display #\$ o)
+          (display (get-group) o)
+          (display #\$ o)))))
+
+(define do-latex-intext-math
+  (lambda ()
+    (do-intext-math
+      (let ((o (open-output-string)))
+        (dump-till-ctl-seq "\\)" o)
+        (get-output-string o)))))
+
+(define do-latex-display-math
+  (lambda ()
+    (do-display-math
+      (let ((o (open-output-string)))
+        (dump-till-ctl-seq "\\]" o)
+        (get-output-string o)))))
+
+(define do-math
+  (lambda ()
+    (let ((display? #f))
+      (when (eqv? (snoop-actual-char) #\$)
+        (set! display? #t) (get-actual-char))
+      (let ((o (open-output-string)))
+        (dump-till-char #\$ o)
+        (when display?
+          (let ((c (get-actual-char)))
+            (when (or (eof-object? c) (not (char=? c #\$)))
+              (terror 'do-math "Display math should end with $$."))))
+        ((if display?
+             do-display-math
+             do-intext-math)
+         (get-output-string o))))))
+
+(define dump-till-char
+  (lambda (d o)
+    (let loop ((nesting 0) (escape? #f))
+      (let ((c (get-actual-char)))
+        (cond ((eof-object? c)
+               (terror 'dump-till-char "Missing " d "."))
+              ((and (char=? c d) (= nesting 0)) #t)
+              (else (display c o)
+                (cond (escape? (loop nesting #f))
+                      ((char=? c #\{) (loop (+ nesting 1) #f))
+                      ((char=? c #\}) (loop (- nesting 1) #f))
+                      ((char=? c #\\ ) (loop nesting #t))
+                      (else (loop nesting #f)))))))))
+
+(define dump-till-ctl-seq
+  (lambda (cs o)
+    (fluid-let ((*not-processing?* #t))
+      (let loop ((nesting 0))
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c) (terror 'dump-till-ctl-seq))
+                ((char=? c *esc-char*)
+                 (let ((x (get-ctl-seq)))
+                   (if (string=? x cs) #t
+                       (begin (display x o)
+                         (loop nesting)))))
+                (else (display (get-actual-char) o)
+                  (cond ((char=? c #\{) (loop (+ nesting 1)))
+                        ((char=? c #\}) (loop (- nesting 1)))
+                        (else (loop nesting))))))))))
+
+(define dump-till-end-env
+  (lambda (env o)
+    (let* ((endenv (string-append "\\end" env))
+           (endenv-prim (find-corresp-prim endenv))
+           (endenv-prim-th (find-corresp-prim-thunk endenv)))
+      (fluid-let ((*not-processing?* #t))
+        (let loop ((brace-nesting 0) (env-nesting 0))
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c) (terror 'dump-till-end-env env))
+                  ((char=? c *esc-char*)
+                   (let ((x (get-ctl-seq)))
+                     (cond ((string=? (find-corresp-prim x) endenv-prim) #t)
+                           ((string=? x "\\begin") (display x o)
+                            (let ((g (get-grouped-environment-name-if-any)))
+                              (when g
+                                (display #\{ o) (display g o) (display #\} o))
+                              (loop brace-nesting
+                                (if (and g (string=? g env)) (+ env-nesting 1)
+                                    env-nesting))))
+                           ((string=? x "\\end")
+                            (let ((g (get-grouped-environment-name-if-any)))
+                              (unless
+                                (and g (or *dumping-nontex?* (= env-nesting 0))
+                                     (let ((endg (string-append "\\end" g)))
+                                       (or (string=? (find-corresp-prim endg)
+                                                     endenv-prim)
+                                           (eqv? (find-corresp-prim-thunk endg)
+                                                 endenv-prim-th))))
+                                (display x o)
+                                (when g
+                                  (display #\{ o) (display g o)
+                                  (display #\} o))
+                                (loop brace-nesting
+                                      (if (and g (string=? g env))
+                                          (- env-nesting 1)
+                                          env-nesting)))))
+                           (else (display x o)
+                             (loop brace-nesting env-nesting)))))
+                  ((and (char=? c *comment-char*)
+                        (not *dumping-nontex?*))
+                   (do-comment)
+                   (write-char #\% o) (newline o)
+                   (loop brace-nesting env-nesting))
+                  (else (write-char (get-actual-char) o)
+                    (cond ((char=? c #\{)
+                           (loop (+ brace-nesting 1) env-nesting))
+                          ((char=? c #\})
+                           (loop (- brace-nesting 1) env-nesting))
+                          (else (loop brace-nesting env-nesting)))))))))))
+
+;images
+
+(define dump-imgdef
+  (lambda (f)
+    (let ((aux-tex-file (string-append f ".tex")))
+      (ensure-file-deleted aux-tex-file)
+      (call-with-output-file aux-tex-file
+        (lambda (o)
+          (dump-tex-preamble o)
+          (display (ungroup (get-group)) o)
+          (dump-tex-postamble o))))))
+
+(define do-img-preamble
+  (lambda ()
+    ;(if *imgpreamble*
+    ;    (terror 'do-img-preamble "Calling \\imgpreamble more than once"))
+    (set! *imgpreamble*
+      (fluid-let ((*not-processing?* #t))
+        (let loop ((r *imgpreamble*))
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'do-img-preamble "Missing \\endimgpreamble"))
+                  ((char=? c *esc-char*)
+                   (let ((x (get-ctl-seq)))
+                     (cond ((ormap (lambda (z) (string=? x z))
+                                   '("\\endimgpreamble"
+                                     "\\endgifpreamble"
+                                     "\\endmathpreamble"))
+                            r)
+                           (else (loop (string-append r x))))))
+                  (else (get-actual-char)
+                    (loop (string-append r (string c)))))))))))
+
+;streams
+
+(define pick-new-stream-number
+  (lambda (stream-list)
+    (let loop ((i 0))
+      (if (or (table-get stream-list i)
+              (= i 16)
+              (= i 18))
+          (loop (+ i 1))
+          i))))
+
+(define do-new-stream
+  (lambda (type)
+    (let* ((x (get-ctl-seq))
+           (sl (if (eqv? type ':out) *output-streams*
+                 *input-streams*))
+           (n (pick-new-stream-number sl)))
+      (tex-def-count x n #t) ;streams are global?
+      (table-put! sl n ':free))))
+
+(define do-open-stream
+  (lambda (type)
+    (let* ((n (get-number))
+           (f (get-plain-filename))
+           (sl (if (eqv? type ':out)
+                   *output-streams* *input-streams*))
+           (c (table-get sl n)))
+      (unless (eq? c ':free)
+        (terror 'do-open-stream))
+      (table-put! sl n
+                  (case type
+                    ((:out)
+                     (set! f (add-dot-tex-if-no-extension-provided f))
+                     (ensure-file-deleted f)
+                     (open-output-file f))
+                    (else
+                     (set! f (actual-tex-filename f #f))
+                     (make-bport 'port (open-input-file f))))))))
+
+(define do-close-stream
+  (lambda (type)
+    (let* ((sl (if (eqv? type ':out)
+                   *output-streams*
+                   *input-streams*))
+           (o (get-number))
+           (c (table-get sl o)))
+      (when (eq? c ':free)
+        (terror 'do-close-stream))
+      (case type
+        ((:out) (close-output-port  c))
+        ((:in) (close-output-port (bport.port c))))
+      (table-put! sl o ':free))))
+
+(define tex-write-output-string
+  (lambda (s)
+    (let ((o (open-output-string)))
+      (fluid-let ((*outputting-to-non-html?* #t)
+                  (*html* o))
+        (call-with-input-string/buffered
+         s (lambda ()
+             (let loop ()
+               (let ((c (snoop-actual-char)))
+                 (unless (eof-object? c)
+                   (case c
+                     ((#\\ ) (do-tex-ctl-seq (get-ctl-seq)))
+                     (else (emit-html-char (get-actual-char))))
+                   (loop)))))))
+      (get-output-string o))))
+
+(define do-write-aux
+  (lambda (o)
+    (let ((output (tex-write-output-string (get-peeled-group))))
+      (cond ((and (= o 18) *enable-write-18?*)
+             (system output))
+            ((or (= o 16) (= o 18))
+             (write-log output)
+             (write-log ':separation-space))
+            ((table-get *output-streams* o)
+             => (lambda (p)
+                    (cond ((eq? p ':free) (terror 'do-write-aux))
+                          (else
+                            (display output p)
+                            (display #\space p)))))
+            (else (terror 'do-write))))))
+
+(define do-write
+  (lambda ()
+    (do-write-aux (get-number))))
+
+(define do-message
+  (lambda ()
+    (do-write-aux 16)))
+
+(define read-tex-line
+  (lambda (p)
+    (fluid-let ((*current-tex2page-input* p))
+      (let loop ((r '()))
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c)
+                 (if (null? r) c (list->string (nreverse r))))
+                ((char=? c #\newline)
+                 (get-actual-char)
+                 (list->string (nreverse r)))
+                ((char=? c #\{)
+                 (string-append (list->string (nreverse r))
+                                (get-group)))
+                (else
+                 (loop (cons (get-actual-char) r)))))))))
+
+(define do-read
+  (lambda (g?)
+    (let* ((i (get-number))
+           (x (begin (get-to) (get-ctl-seq)))
+           (p #f))
+      (cond ((ormap (lambda (j) (= i j)) '(-1 16))
+             (set! p (make-bport 'port (current-input-port)))
+             (unless (= i -1)
+               (write-log x) (write-log #\=)))
+            ((table-get *input-streams* i)
+             => (lambda (c)
+                  (set! p c)
+                  (unless (eq? p ':free) (terror 'do-read))))
+            (else (terror 'do-read)))
+      ((if g? tex-gdef-0arg tex-def-0arg)
+       x (let ((line (read-tex-line p)))
+           (if (eof-object? line) "" line))))))
+
+(define do-typein
+  (lambda ()
+    (let ((ctlseq (get-bracketed-text-if-any))
+          (p (make-bport 'port (current-input-port))))
+      (write-log ':separation-newline)
+      (write-log (tex-string->html-string (get-group)))
+      (write-log ':separation-newline)
+      (write-log (or ctlseq "\\@typein"))
+      (write-log #\=)
+      (let ((L (read-tex-line p)))
+        (when (eof-object? L) (set! L ""))
+        (cond (ctlseq
+               (tex-def-0arg ctlseq L))
+              (else
+               (tex2page-string L)))))))
+
+;conditionals
+
+(define do-ifeof
+  (lambda ()
+    (let* ((i (get-number))
+          (c (table-get *input-streams* i)))
+      (when (eq? c ':free)
+        (terror 'do-ifeof))
+      (if (eof-object? (read-char  c))
+          (do-iftrue)
+          (do-iffalse)))))
+
+(define do-iffalse
+  (lambda ()
+    (set! *tex-if-stack* (cons #f *tex-if-stack*))))
+
+(define do-iftrue
+  (lambda ()
+    (set! *tex-if-stack* (cons #t *tex-if-stack*))))
+
+(define insert-tex-if ;???
+  (lambda (test)
+    ((if test do-iftrue do-iffalse))))
+
+(define do-ifx
+  (lambda ()
+    (let* ((one (get-raw-token/is))
+           (two (get-raw-token/is))
+           (one2 one)
+           (two2 two))
+      ;NB: doesn't work like tex's \ifx if
+      ;one of the args is a "primitive" ctl seq
+      ((if (string=? one two) do-iftrue
+           (begin
+             (when (ctl-seq? one)
+               (set! one2
+                 (cond ((find-def one)
+                        => (lambda (d)
+                             (or (tdef.expansion d)
+                                 (tdef.prim d))))
+                       ((find-math-def one) => (lambda (x) x))
+                       (else "UnDeFiNeD"))))
+             (when (ctl-seq? two)
+               (set! two2
+                 (cond ((find-def two)
+                        => (lambda (d)
+                             (or (tdef.expansion d)
+                                 (tdef.prim d))))
+                       ((find-math-def two) => (lambda (x) x))
+                       (else "UnDeFiNeD"))))
+             (if (or (eqv? one2 two2)
+                     (and (string? one2) (string? two2)
+                          (string=? one2 two2)))
+                 do-iftrue
+                 do-iffalse)))))))
+
+(define do-ifdefined
+  (lambda ()
+    (let ((x (get-raw-token/is)))
+      ((if (or (not (ctl-seq? x))
+               (and (ctl-seq? x)
+                    (or (find-def x) (find-math-def x))))
+           do-iftrue
+           do-iffalse)))))
+
+(define do-if-get-atomic
+  (lambda ()
+    (let loop ()
+      (let ((x (get-raw-token/is)))
+        (if (ctl-seq? x)
+            (cond ((resolve-defs x)
+                   => (lambda (z)
+                        (toss-back-char *invisible-space*)
+                        (toss-back-string z)
+                        (loop)))
+                  (else x))
+            x)))))
+
+(define do-if
+  (lambda ()
+    (let* ((one (do-if-get-atomic))
+           (two (do-if-get-atomic)))
+      ((if (or (string=? one two)
+               (and (ctl-seq? one) (ctl-seq? two)))
+           do-iftrue
+           do-iffalse)))))
+
+(define do-ifmmode
+  (lambda ()
+    (set! *tex-if-stack*
+      (cons *math-mode?* *tex-if-stack*))))
+
+(define do-ifnum
+  (lambda ()
+    (let* ((one (get-number))
+           (rel (string-ref (get-raw-token/is) 0)))
+      ((if ((case rel
+              ((#\<) <)
+              ((#\=) =)
+              ((#\>) >)
+              (else (terror 'do-ifnum "Missing = for \\ifnum.")))
+            one (get-number))
+           do-iftrue
+           do-iffalse)))))
+
+(define read-ifcase-clauses
+  (lambda ()
+    (fluid-let ((*not-processing?* #t))
+      (let* ((else-clause #f)
+             (or-clauses
+              (let loop ((or-clauses '()) (else? #f))
+                (let loop2 ((clause ""))
+                  (let ((c (snoop-actual-char)))
+                    (cond ((eof-object? c)
+                           (terror 'read-ifcase-clauses "Incomplete \\ifcase."))
+                          ((char=? c *esc-char*)
+                           (let ((x (get-ctl-seq)))
+                             (cond ((string=? x "\\or")
+                                    (ignorespaces)
+                                    (if else?
+                                        (terror 'read-ifcase-clauses
+                                                "\\or after \\else")
+                                        (loop (cons clause or-clauses) #f)))
+                                   ((string=? x "\\else")
+                                    (ignorespaces)
+                                    (if else?
+                                        (terror 'read-ifcase-clauses
+                                                "\\else after \\else")
+                                        (loop (cons clause or-clauses) #t)))
+                                   ((string=? x "\\fi")
+                                    (ignorespaces)
+                                    (if else?
+                                        (begin
+                                         (set! else-clause clause)
+                                         or-clauses)
+                                        (cons clause or-clauses)))
+                                   (else
+                                    (loop2 (string-append clause x))))))
+                          (else (get-actual-char)
+                                (loop2 (string-append clause (string c)))))
+                    )))))
+        (cons else-clause or-clauses)))))
+
+(define do-ifcase
+  (lambda ()
+    (let* ((num (get-number))
+           (clauses (read-ifcase-clauses))
+           (else-clause (car clauses))
+           (or-clauses (nreverse (cdr clauses)))
+           (num-or-clauses (length or-clauses)))
+      (cond ((< num num-or-clauses)
+             (tex2page-string
+              (list-ref or-clauses num)))
+            (else-clause
+             (tex2page-string else-clause))))))
+
+(define do-ifodd
+  (lambda ()
+    ((if (odd? (get-number))
+         do-iftrue
+         do-iffalse))))
+
+(define do-else
+  (lambda ()
+    (when (null? *tex-if-stack*) (terror 'do-else "Extra \\else"))
+    (let ((top-if (car *tex-if-stack*)))
+      (set! *tex-if-stack* (cons (not top-if) (cdr *tex-if-stack*))))))
+
+(define do-fi
+  (lambda ()
+    (when (null? *tex-if-stack*) (terror 'do-fi "Extra \\fi"))
+    (set! *tex-if-stack* (cdr *tex-if-stack*))))
+
+(define do-newif
+  (lambda ()
+    (let* ((iffoo (get-ctl-seq))
+           (init-val #f)
+           (foo (string-append "\\" (substring iffoo 3 (string-length iffoo))))
+           (foo-register (string-append foo "BOOLEANREGISTER")))
+      (tex-def-count foo-register 0 #f)
+      (tex-def-thunk iffoo
+                     (lambda ()
+                       (set! *tex-if-stack*
+                         (cons (> (the-count foo-register) 0)
+                               *tex-if-stack*))) #f)
+      (tex-def-thunk (string-append foo "true")
+                     (lambda ()
+                       (tex-def-count foo-register 1 #f)) #f)
+      (tex-def-thunk (string-append foo "false")
+                     (lambda ()
+                       (tex-def-count foo-register 0 #f)) #f))))
+
+;
+
+(define do-htmlimg
+  (lambda (env)
+    ;(emit "<p><center>")
+      (call-with-html-image-port
+        (lambda (o)
+          (dump-till-end-env env o))
+      ;(emit "</center><p>")
+      )))
+
+(define find-img-file-extn
+  (lambda ()
+    (case (tex2page-flag-value "\\TZPimageformat")
+      ((#\p #\P) ".png")
+      ((#\j #\J) ".jpeg")
+      (else ".gif"))))
+
+(define do-htmlimageformat
+  (lambda ()
+    (tex-def-0arg "\\TZPimageformat" (get-peeled-group)) ))
+
+(define do-htmlimageconversionprogram
+  (lambda ()
+    (tex-def-0arg "\\TZPimageconverter" (get-peeled-group))))
+
+(define do-htmlimgmagnification
+  (lambda ()
+    #t ; obsolete
+    ))
+
+(define call-tex
+  (let ((latex-prog-name #f)
+        (tex-output-format #f))
+  (lambda (f)
+    ;run tex on f and return f.ps or f.pdf if successful
+    (unless latex-prog-name
+      (let ((d (find-def "\\TZPtexprogname")))
+        (when d (set! *tex-prog-name* (tdef.expansion d))))
+      (unless *tex-prog-name* (set! *tex-prog-name* "pdftex"))
+      (set! latex-prog-name
+        (string-append (substring *tex-prog-name*
+                                  0 (- (string-length *tex-prog-name*) 3))
+                       "latex"))
+      (set! tex-output-format
+        (if (or (eqv? (substring? "pdf" *tex-prog-name*) 0)
+                (eqv? (substring? "xe" *tex-prog-name*) 0))
+          ':pdf ':dvi)))
+    (let* ((dvifile (string-append
+                      f (if (eq? tex-output-format ':pdf)
+                          ".pdf" ".dvi")))
+           (outfile dvifile))
+      ;[shd we check if dvifile already exists? no]
+      (system (string-append
+                (if (eq? *tex-format* ':latex)
+                  latex-prog-name
+                  *tex-prog-name*)
+               " " f *bye-tex*))
+      (and (file-exists? dvifile)
+           (let ((logfile (string-append f ".log")))
+             (and (file-exists? logfile)
+                  ;scan the log file for sign of problems
+                  (let ((fine?
+                         (call-with-input-file logfile
+                           (lambda (i)
+                             (let loop ()
+                               (let ((x (read-line i)))
+                                 (cond ((eof-object? x) #t)
+                                       ((substring? "! I can't find file" x)
+                                        ;the dvi can't be good
+                                        #f)
+                                       (else (loop)))))))))
+                    (and fine?
+                         (begin
+                          (unless (eq? tex-output-format ':pdf)
+                            (let ((psfile (string-append f ".ps")))
+                              (system
+                               (string-append "dvips " dvifile " -o " psfile))
+                              (set! outfile psfile)))
+                          outfile))))))))))
+
+(define ps-to-img/gif/netpbm
+  (lambda (psfile f)
+    (system
+      (string-append *ghostscript* *ghostscript-options* " -sOutputFile=" f ".ppm.1 "
+                     psfile " quit.ps"))
+    (system
+      (string-append "pnmcrop " f ".ppm.1 > " f ".ppm.tmp"))
+;    (unless (= *img-magnification* 1)
+;       (system
+;         (string-append "pbmpscale " (number->string *img-magnification*)
+;                        " " f-ppm-tmp " > " f-ppm))
+;       (let ((swp f-ppm))
+;         (set! f-ppm f-ppm-tmp) (set! f-ppm-tmp swp)))
+    (system
+      (string-append "ppmquant 256 < " f ".ppm.tmp > " f ".ppm"))
+    (system
+      (string-append "ppmtogif -transparent rgb:ff/ff/ff < "
+                     f ".ppm > " *aux-dir/* f ".gif"))
+    (for-each
+       (lambda (e)
+         (ensure-file-deleted (string-append f e)))
+       '(".ppm" ".ppm.tmp" ".ppm.1"))))
+
+(define ps-to-img/png/netpbm
+  (lambda (psfile f)
+    (system
+      (string-append *ghostscript* *ghostscript-options* " -sOutputFile=" f ".ppm.1 "
+                    psfile " quit.ps"))
+    (system
+      (string-append "pnmcrop " f ".ppm.1 > " f ".ppm.tmp"))
+    '(system
+       (string-append "ppmquant 256 < " f ".ppm.tmp > " f ".ppm"))
+    (system
+      (string-append "pnmtopng -interlace -transparent \"#FFFFFF\" "
+                     " < " f ".ppm.tmp > " *aux-dir/* f ".png"))
+    (for-each
+      (lambda (e)
+        (ensure-file-deleted (string-append f e)))
+      '(".ppm.1" ".ppm.tmp" ".ppm"))
+    ))
+
+(define ps-to-img/jpeg/netpbm
+  (lambda (psfile f)
+    (system
+      (string-append *ghostscript* *ghostscript-options* " -sOutputFile=" f ".ppm.1 "
+                    psfile " quit.ps"))
+    (system
+      (string-append "pnmcrop " f ".ppm.1 > " f ".ppm.tmp"))
+    (system
+      (string-append "ppmquant 256 < " f ".ppm.tmp > " f ".ppm"))
+    (system
+      (string-append "ppmtojpeg --grayscale < " f ".ppm > "
+        *aux-dir/* f ".jpeg"))
+    (for-each
+      (lambda (e)
+        (ensure-file-deleted (string-append f e)))
+      '(".ppm.1" ".ppm.tmp" ".ppm"))
+    ))
+
+(define ps-to-img
+  (lambda (psfile f)
+    (case (tex2page-flag-value "\\TZPimageconverter")
+      ((#\i #\I)
+       (system
+         (string-append "convert -transparent white -trim "
+                  psfile  " " f (find-img-file-extn))))
+      (else
+        ((case (tex2page-flag-value "\\TZPimageformat")
+           ((#\p #\P) ps-to-img/png/netpbm)
+           ((#\j #\J) ps-to-img/jpeg/netpbm)
+           (else ps-to-img/gif/netpbm)) psfile f)))))
+
+(define tex-to-img
+  (lambda (f)
+    ;converts the TeX subfile `f' into img.  Follows the same
+    ;route as used in LaTeX2HTML
+    (set! *img-file-tally* (+ *img-file-tally* 1))
+    (let ((f.img (string-append *aux-dir/* f (find-img-file-extn))))
+      (unless (file-exists? f.img)
+        (write-log ':separation-space)
+        (write-log #\{)
+        (write-log (string-append f ".tex"))
+        (write-log ':separation-space)
+        (write-log "->")
+        (write-log ':separation-space)
+        (cond ((call-tex f)
+               => (lambda (psfile)
+               (ps-to-img psfile f)
+               (write-log f.img)
+               '(for-each
+                  (lambda (e)
+                    (ensure-file-deleted (string-append f e)))
+                  '(".aux" ".dvi" ".log" ".pdf" ".ps" ".tex"))))
+              (else
+                (write-log "failed, try manually")))
+        (write-log #\})
+        (write-log ':separation-space)
+        )
+      ;(move-aux-files-to-aux-dir f)
+      )))
+
+(define call-with-lazy-image-port
+  (lambda (eps-file img-file-stem p)
+    (let ((aux-tex-file (string-append img-file-stem ".tex")))
+      (ensure-file-deleted aux-tex-file)
+      (call-with-output-file aux-tex-file
+        (lambda (o)
+          (dump-tex-preamble o)
+          (p o)
+          (dump-tex-postamble o)))
+      (if (file-exists? eps-file) (tex-to-img img-file-stem)
+          (set! *missing-eps-files*
+            (cons (cons eps-file img-file-stem)
+                  *missing-eps-files*))))))
+
+(define retry-lazy-image
+  (lambda (eps-file img-file-stem)
+    (cond ((file-exists? eps-file) (tex-to-img img-file-stem))
+          (else
+           (write-log "! I can't find EPS file ")
+           (write-log eps-file)
+           (write-log ':separation-newline)))))
+
+(define lazily-make-epsf-image-file
+  (lambda (eps-file img-file-stem)
+    (fluid-let ((*imgpreamble-inferred*
+                 (cons ':epsfbox *imgpreamble-inferred*)))
+      (call-with-lazy-image-port
+       eps-file img-file-stem
+       (lambda (o)
+         (display "\\epsfbox{" o)
+         (display eps-file o)
+         (display #\} o))))
+    ;(source-img-file img-file-stem)
+    ))
+
+(define do-epsfbox
+  (lambda ()
+    (let* ((b (get-bracketed-text-if-any))
+           (f (get-filename-possibly-braced)))
+      (unless *eval-for-tex-only?*
+        (let ((epsf-x-size (get-dimen "\\epsfxsize"))
+              (epsf-y-size (get-dimen "\\epsfysize")))
+          (cond ((and (= epsf-x-size 0) (= epsf-y-size 0))
+                 (let ((img-file-stem (next-html-image-file-stem)))
+                   (lazily-make-epsf-image-file f img-file-stem)
+                   (source-img-file img-file-stem)))
+                (else
+                  (unless (= epsf-x-size 0)
+                    (tex2page-string "\\epsfxsize=0pt"))
+                  (unless (= epsf-y-size 0)
+                    (tex2page-string "\\epsfysize=0pt"))
+                  (fluid-let ((*imgpreamble-inferred*
+                                (cons ':epsfbox *imgpreamble-inferred*)))
+                    (call-with-html-image-port
+                      (lambda (o)
+                        (unless (= epsf-x-size 0)
+                          (display "\\epsfxsize=" o)
+                          (display epsf-x-size o)
+                          (display "sp" o) (newline o))
+                        (unless (= epsf-y-size 0)
+                          (display "\\epsfysize=" o)
+                          (display epsf-y-size o)
+                          (display "sp" o) (newline o))
+                        (display "\\epsfbox{" o)
+                        (display f o)
+                        (display #\} o)))))))))))
+
+(define do-epsfig
+  (lambda ()
+    (fluid-let ((*imgpreamble-inferred*
+                  (cons ':epsfbox *imgpreamble-inferred*)))
+      (call-with-html-image-port
+        (lambda (o)
+          (display "\\epsfig{" o)
+          (dump-groupoid o)
+          (display #\} o))))))
+
+(define do-convertmptopdf
+  (lambda ()
+    (let ((f (get-filename-possibly-braced))
+          (img-file-stem (next-html-image-file-stem)))
+      (get-token) (get-token) ;ignore scale args 4now
+      (lazily-make-epsf-image-file f img-file-stem)
+      (source-img-file img-file-stem))))
+
+(define do-includegraphics-web
+  (lambda (bracketed-text image-file)
+    (emit "<img")
+    (when bracketed-text
+      (let ((height #f) (width #f))
+        (toss-back-string " enoughalready ")
+        (toss-back-string bracketed-text)
+        (let loop ()
+          (cond ((eat-word "height") (get-equal-sign)
+                                     (set! height (get-pixels)) (loop))
+                ((eat-word "width") (get-equal-sign)
+                                    (set! width (get-pixels)) (loop))
+                ((eat-word "enoughalready") (ignorespaces))
+                (else (get-actual-char) (loop))))
+        (when height
+          (emit " height=") (emit height))
+        (when width
+          (emit " width=") (emit width))))
+    (emit " src=\"")
+    (emit (fully-qualify-url image-file))
+    (emit "\">")))
+
+(define do-includegraphics
+  (lambda ()
+    (let* ((star? (eat-star))
+           (b1 (get-bracketed-text-if-any))
+           (b2 (and b1 (get-bracketed-text-if-any)))
+           (f (get-filename-possibly-braced))
+           (img-file-stem (next-html-image-file-stem))
+           (ffull (if (file-exists? f) f
+                      (ormap (lambda (e)
+                               (let ((f2 (string-append f e)))
+                                 (and (file-exists? f2) f2)))
+                             *graphics-file-extensions*)))
+           (ffull-ext (and ffull (file-extension ffull))))
+      (cond ((and ffull-ext
+                  (ormap (lambda (y) (string=? ffull-ext y))
+                         '(".jpg" ".jpeg" ".png")))
+             (do-includegraphics-web b1 ffull))
+            (else
+              (fluid-let ((*imgpreamble-inferred*
+                            (cons ':includegraphics *imgpreamble-inferred*)))
+                (call-with-lazy-image-port
+                  (or ffull f) img-file-stem
+                  (lambda (o)
+                    (display "\\includegraphics" o)
+                    (when star? (display #\* o))
+                    (when b1
+                      (display #\[ o)
+                      (display b1 o)
+                      (display #\] o))
+                    (when b2
+                      (display #\[ o)
+                      (display b2 o)
+                      (display #\] o))
+                    (display #\{ o)
+                    (display f o)
+                    (display #\} o))))
+              (source-img-file img-file-stem))))))
+
+(define do-resizebox
+  (lambda ()
+    (let* ((arg1 (get-group))
+           (arg2 (get-group))
+           (arg3 (get-group)))
+      (fluid-let ((*imgpreamble-inferred*
+                   (cons ':includegraphics *imgpreamble-inferred*)))
+         (call-with-html-image-port
+          (lambda (o)
+            (display "\\resizebox" o)
+            (display arg1 o)
+            (display arg2 o)
+            (display arg3 o)))))))
+
+;mfpic
+
+(define do-mfpic-opengraphsfile
+  (lambda ()
+    (set! *mfpic-file-stem* (get-filename-possibly-braced))
+    (when *mfpic-port* (close-output-port *mfpic-port*))
+    (let ((f (string-append *mfpic-file-stem* *mfpic-tex-file-suffix*)))
+      (ensure-file-deleted f)
+      (set! *mfpic-port* (open-output-file f)))
+    (set! *mfpic-file-num* 0)
+    (display "\\input mfpic \\usemetapost " *mfpic-port*) (newline *mfpic-port*)
+    (display "\\opengraphsfile{" *mfpic-port*)
+    (display *mfpic-file-stem* *mfpic-port*)
+    (display #\} *mfpic-port*) (newline *mfpic-port*)
+    (tex-def-prim "\\headshape"
+                  (lambda ()
+                    (let* ((g1 (get-group))
+                           (g2 (get-group))
+                           (g3 (get-group)))
+                      (display "\\headshape" *mfpic-port*)
+                      (display g1 *mfpic-port*)
+                      (display g2 *mfpic-port*)
+                      (display g3 *mfpic-port*)
+                      (newline *mfpic-port*))))
+    (tex-def-prim "\\mfpframesep" eat-dimen)
+    (tex-def-prim "\\mftitle" get-group)
+    ))
+
+(define do-mfpic-closegraphsfile
+  (lambda ()
+    (display "\\closegraphsfile" *mfpic-port*)
+    (newline *mfpic-port*)
+    (close-output-port *mfpic-port*)
+    (let ((tex-f (string-append *mfpic-file-stem* *mfpic-tex-file-suffix*))
+          (mp-f (string-append *mfpic-file-stem* ".mp")))
+      (unless (file-exists? mp-f)
+        (fluid-let ((*tex-format* ':plain))
+          (call-tex tex-f)))
+      (when (file-exists? mp-f)
+        (system (string-append *metapost* " " *mfpic-file-stem*))))))
+
+(define do-mfpic
+  (lambda ()
+    (display "\\mfpic" *mfpic-port*)
+    (dump-till-end-env "mfpic" *mfpic-port*)
+    (display "\\endmfpic" *mfpic-port*) (newline *mfpic-port*)
+    (set! *mfpic-file-num* (+ *mfpic-file-num* 1))
+    (let ((f (string-append *mfpic-file-stem* "."
+                            (number->string *mfpic-file-num*)))
+          (img-file-stem (next-html-image-file-stem)))
+      (lazily-make-epsf-image-file f img-file-stem)
+      (source-img-file img-file-stem))))
+
+(define do-following-latex-env-as-image
+  (lambda ()
+    (do-latex-env-as-image
+      (ungroup (get-group)) ':display)))
+
+(define do-latex-env-as-image
+  (lambda (env display-p)
+    (let ((env2 (if (string=? env "align") "eqnarray" env)))
+    (when (char=? (snoop-actual-char) #\*)
+      (get-actual-char)
+      (set! env (string-append env "*"))
+      (set! env2 (string-append env2 "*")))
+    (egroup) ;because \begin introduces a group
+    (when display-p
+      (do-end-para)
+      (emit "<div align=")
+      (emit *display-justification*)
+      (emit ">"))
+     (call-with-html-image-port
+      (lambda (o)
+        (display "\\begin{" o)
+        (display env2 o)
+        (display "}" o)
+        (dump-till-end-env env o)
+        (display "\\end{" o)
+        (display env2 o)
+        (display "}" o) (newline o)
+        ))
+    (when display-p
+      (emit "</div>")
+      (do-para)))))
+
+(define do-box
+  (lambda ()
+    (fluid-let ((*ignore-active-space?* #t))
+      (ignorespaces)
+      (get-to))
+    (eat-dimen)
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (case c
+        ((#\{) #t)
+        ((#\\ ) (get-ctl-seq))
+        ;(else error) ;well let's not stop the show on this
+        ))
+    (get-actual-char)
+    (bgroup)
+    (add-postlude-to-top-frame
+      (let ((old-math-mode? *math-mode?*)
+            (old-in-display-math? *in-display-math?*)
+            (old-tabular-stack *tabular-stack*)
+            (old-ligatures? *ligatures?*))
+        (set! *math-mode?* #f)
+        (set! *in-display-math?* #f)
+        (set! *tabular-stack* '())
+        (set! *ligatures?* #t)
+        (lambda ()
+          (set! *math-mode?* old-math-mode?)
+          (set! *in-display-math?* old-in-display-math?)
+          (set! *tabular-stack* old-tabular-stack)
+          (set! *ligatures?* old-ligatures?))))))
+
+(define do-latex-frac
+  (lambda ()
+    (emit "(")
+    (tex2page-string (get-token))
+    (emit "/")
+    (tex2page-string (get-token))
+    (emit ")")))
+
+(define do-tex-frac
+  (lambda ()
+    (ignorespaces)
+    (let ((inner-level? (or (not *in-display-math?*)
+                            (not (null? *tabular-stack*)))))
+      (fluid-let ((*tabular-stack* (cons 'frac *tabular-stack*)))
+        (cond (inner-level?
+               (emit "<sup>")
+               (tex2page-string (get-till-char #\/))
+               (emit "</sup>/<sub>")
+               (get-actual-char) (ignorespaces)
+               (tex2page-string (get-token))
+               (emit "</sub>"))
+              (else
+               (emit "</td><td><table align=left><tr><td align=center>")
+               (tex2page-string (get-till-char #\/))
+               (get-actual-char) (ignorespaces)
+               (emit  "<hr noshade>")
+               (tex2page-string (get-token))
+               (emit  "</td></tr></table></td><td>")))))))
+
+(define do-frac
+  (lambda ()
+    ((if (eqv? *tex-format* ':latex) do-latex-frac
+         do-tex-frac))))
+
+(define do-eqno
+  (lambda ()
+    (unless *in-display-math?*
+      (terror 'do-eqno "You can't use \\eqno in math mode"))
+    (emit "</td><td width=10% align=right>")))
+
+(define do-eqalign
+  (lambda (type)
+    (ignorespaces)
+    (let ((c (get-actual-char)))
+      (when (eof-object? c) (terror 'do-eqalign "Missing {"))
+      (unless (char=? c #\{) (terror 'do-eqalign "Missing {"))
+      ;
+      (bgroup)
+      (set! *tabular-stack* (cons type *tabular-stack*))
+      (add-postlude-to-top-frame
+       (lambda ()
+         (emit "</td></tr>") (emit-newline)
+         (emit "</table>") (emit-newline)
+         (when *in-display-math?* (emit "</td><td>"))
+         (pop-tabular-stack type)
+         (set! *equation-position* 0)))
+      (when *in-display-math?* (emit "</td><td>"))
+      (emit-newline)
+      (emit "<table><tr><td>"))))
+
+(define do-noalign
+  (lambda ()
+    (let* ((type (and (not (null? *tabular-stack*))
+                      (car *tabular-stack*)))
+           (split? (memv type '(:eqalignno :displaylines))))
+      (when split? (egroup)
+        (emit "</td></tr></table></div>") (emit-newline)
+        ;(emit "<tr><td>")
+        (do-para))
+      (tex2page-string (get-group))
+      (cond (split? (do-end-para)
+                    ;(emit "</td></tr>")
+                    (emit-newline) (emit "<div align=center><table><tr><td>")
+                    (toss-back-char #\{) (do-eqalign type))
+            (else (emit "</td></tr>") (emit-newline)
+                  (emit "<tr><td>"))))))
+
+(define do-pmatrix
+  (lambda ()
+    (ignorespaces)
+    (let ((c (get-actual-char)))
+      (when (eof-object? c) (terror 'do-pmatrix "Missing {"))
+      (unless (char=? c #\{) (terror 'do-pmatrix "Missing {"))
+      (bgroup)
+      (set! *tabular-stack* (cons ':pmatrix *tabular-stack*))
+      (add-postlude-to-top-frame
+       (lambda ()
+         (emit "</td></tr></table>")
+         (when *in-display-math?* (emit "</td><td>"))
+         (emit-newline)
+         (pop-tabular-stack ':pmatrix)))
+      (when *in-display-math?* (emit "</td><td>"))
+      (emit "<table border=1><tr><td>")
+      (emit-newline))))
+
+(define do-over
+  (lambda ()
+    (emit
+     (cond ((or (not *in-display-math?*) *math-script-mode?*) "/")
+           (else (set! *math-height* (+ *math-height* 1))
+                 "</td></tr><tr><td style=\"height=1pt; background-color: black\"></td></tr><tr><td align=center>")))))
+
+(define eat-till-eol
+  (lambda ()
+    ;move just past the next newline
+    (let loop ()
+      (let ((c (get-actual-char)))
+        (unless (or (eof-object? c) (char=? c #\newline)) (loop))))))
+
+(define do-comment
+  (lambda ()
+    ;move past tex %comment
+    (eat-till-eol)
+    (when (munched-a-newline?)
+      (toss-back-char #\newline)
+      (toss-back-char #\newline))
+    ;(emit-newline)
+    ))
+
+(define latex-style-file?
+  (lambda (f)
+    (let ((e (file-extension f)))
+      (and e (string-ci=? e ".sty")))))
+
+(define path-to-list
+  (lambda (p)
+    ;convert an OS path into a Scheme list
+    (if (not p) '()
+        (let loop ((p p) (r '()))
+          (let ((i (string-index p *path-separator*)))
+            (if i
+                (loop (substring p (+ i 1) (string-length p))
+                  (cons (substring p 0 i) r))
+                (nreverse (cons p r))))))))
+
+(define kpsewhich
+  (lambda (f)
+    (let ((tmpf (string-append *aux-dir/* *jobname* "-Z-Z.temp")))
+      (ensure-file-deleted tmpf)
+      (system (string-append "kpsewhich -- " f " > " tmpf))
+      (let ((f (and (file-exists? tmpf)
+                    (call-with-input-file tmpf
+                      (lambda (i) (read-line i))))))
+        (ensure-file-deleted tmpf)
+        (if (or (not f) (eof-object? f)) #f
+            (let ((f (string-trim-blanks f)))
+              (when (eq? *operating-system* ':cygwin)
+                (cond  ((eqv? (substring? "/cygdrive/" f) 0)
+                        (set! f (substring f 11 (string-length f))))
+                       ((eqv? (substring? "/usr/" f) 0)
+                        (set! f (string-append "/cygwin" f)))))
+              (cond ((= (string-length f) 0) #f)
+                    ((eq? *operating-system* ':cygwin) f)
+                    ((file-exists? f) f)
+                    (else #f))))))))
+
+(define find-tex-file
+  (lambda (file)
+    ;search for file.tex before file;
+    ;search in current directory first;
+    ;if TEX2PAGEINPUTS is set, search there,
+    ;else use kpsewhich
+    (let ((files (list (string-append file ".tex")
+                       file)))
+      (or (ormap (lambda (file)
+                   (and (file-exists? file) file))
+                 files)
+          (if (not (null? *tex2page-inputs*))
+              (ormap (lambda (dir)
+                       (ormap (lambda (file)
+                                (let ((qfile (string-append
+                                              dir
+                                              *directory-separator*
+                                              file)))
+                                  (and (file-exists? qfile)
+                                       qfile)))
+                              files))
+                     *tex2page-inputs*)
+              (kpsewhich file))))))
+
+(define initialize-scm-words
+  (lambda ()
+    (set! *scm-keywords* (make-table 'equ string=?))
+    (set! *scm-builtins* (make-table 'equ string=?))
+    (set! *scm-special-symbols* (make-table 'equ string=?))
+    (set! *scm-variables* (make-table 'equ string=?))
+    (for-each (lambda (s) (table-put! *scm-keywords* s #t))
+              '("=>" "and" "begin" "begin0" "case" "cond" "define" "define-macro"
+                "define-syntax" "defmacro" "defstruct" "delay" "do" "else" "flet"
+                "fluid-let" "if" "labels" "lambda" "let" "let-syntax" "let*"
+                "letrec" "letrec-syntax" "macrolet" "or" "quasiquote" "quote"
+                "set!" "syntax-case" "syntax-rules" "unless" "unquote" "unquote-splicing"
+                "when" "with" "with-handlers"))))
+
+(define actual-tex-filename
+  (lambda (f check-timestamp?)
+    ;convert filename f to an "actual" filename, just
+    ;like TeX does.  Ie, prefer the .tex extension, and
+    ;search a pathlist.
+    ;If doing main TeX file, do some setup
+    (let ((doing-main-file? (not *main-tex-file*))
+          (f2 (find-tex-file f)))
+      (when doing-main-file?
+        ;(initialize-tex2page)
+        (when f2
+          (set! *jobname* (file-stem-name f2))
+          (make-target-dir)
+          (let ((zeroth-html-page
+                  (string-append *aux-dir/* *jobname* *output-extension*)))
+            (when (string=? zeroth-html-page f2)
+              (let ((f2-save (string-append f2 "_save")))
+                (write-log ':separation-newline)
+                (write-log "Copying weirdly named TeX source file ")
+                (write-log f2)
+                (write-log " to ")
+                (write-log f2-save)
+                (write-log ':separation-newline)
+                (case *operating-system*
+                  ((:cygwin :unix)
+                   (system (string-append "cp -pf " f2 " " f2-save)))
+                  ((:windows)
+                   (system (string-append "copy/y " f2 " " f2-save))))
+                (set! f2 f2-save))))
+          ;(initialize-globals)
+          )
+        (load-aux-file)
+        )
+      (when (and f2 check-timestamp?
+                 (ormap (lambda (vwf) (string=? f2 vwf))
+                        *verb-written-files*))
+        (set! check-timestamp? #f))
+      (when (and f2 check-timestamp?)
+        (update-last-modification-time f2))
+      f2)))
+
+(define add-dot-tex-if-no-extension-provided
+  (lambda (f)
+    (let ((e (file-extension f)))
+      (if e f
+          (string-append f ".tex")))))
+
+(define ignore-tex-specific-text
+  (lambda (env)
+    (let ((endenv (string-append "\\end" env)))
+      (let loop ()
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c)
+                 (terror 'ignore-tex-specific-text "Missing \\end" env))
+                ((char=? c *esc-char*)
+                 (let ((x (get-ctl-seq)))
+                   (cond ((string=? x endenv) #t)
+                         ((string=? x "\\end")
+                          (let ((g (get-grouped-environment-name-if-any)))
+                            (unless (and g (string=? g env))
+                              (loop))))
+                         (else (loop)))))
+                (else (get-actual-char) (loop))))))))
+
+(define do-rawhtml
+  (lambda ()
+    (let loop ()
+      (let ((c (snoop-actual-char)))
+        (cond ((eof-object? c)
+               (terror 'do-rawhtml "Missing \\endrawhtml"))
+              ((char=? c *esc-char*)
+               (let* ((x (get-ctl-seq))
+                      (y (find-corresp-prim x)))
+                 (cond ((string=? y "\\endrawhtml") 'done)
+                       ((and (string=? x "\\end")
+                             (get-grouped-environment-name-if-any))
+                        => (lambda (g)
+                             (let ((y (find-corresp-prim (string-append x g))))
+                               (if (string=? y "\\endrawhtml") 'done
+                                   (begin (emit "\\end{")
+                                          (emit g) (emit "}")
+                                          (loop))))))
+                       ((string=? x "\\\\")
+                        (emit c) (toss-back-char c) (loop))
+                       (else (emit x) (loop)))))
+              (else (get-actual-char)
+                    (emit c) (loop)))))))
+
+(define do-htmlheadonly
+  (lambda ()
+    (when (null? *html-head*) (flag-missing-piece ':html-head))
+    (let loop ((s '()))
+      (let ((c (snoop-actual-char)))
+        (cond ((eof-object? c)
+               (write-aux `(!html-head ,(list->string (nreverse s)))))
+              ((char=? c *esc-char*)
+               (write-aux `(!html-head ,(list->string (nreverse s))))
+               (let ((x (get-ctl-seq)))
+                 (cond ((string=? x "\\endhtmlheadonly") 'done)
+                       ((string=? x "\\input")
+                        (let ((f (get-filename-possibly-braced)))
+                          (call-with-input-file/buffered
+                           f do-htmlheadonly)
+                          (loop '())))
+                       (else (write-aux `(!html-head ,x))
+                             (loop '())))))
+              ((char=? c #\newline)
+               ;kludge: (most?) Schemes print newline within string as \n, which
+               ;CL reads as n
+               (get-actual-char)
+               (loop (cons #\space s)))
+              (else (get-actual-char)
+                    (loop (cons c s))))))))
+
+;\let, \def, \imgdef
+
+(define resolve-chardefs
+  (lambda (c)
+    (cond ((find-chardef c)
+           => (lambda (y)
+                (get-actual-char)
+                (expand-tex-macro (cdef.optarg y)
+                                  (cdef.argpat y)
+                                  (cdef.expansion y))))
+          (else #f))))
+
+(define resolve-defs
+  (lambda (x)
+    (cond ((find-def x)
+           => (lambda (y)
+                (cond ((tdef.defer y) => (lambda (z) z))
+                      ((tdef.thunk y) #f)
+                      (else
+                        (cond ((and (inside-false-world?)
+                                    (not (if-aware-ctl-seq? x))
+                                    ;(> (length (tdef.argpat y)) 0)
+                                    ) #f)
+                              (else
+                                (when *outer?*
+                                  (set! *outer?* #f)
+                                  (toss-back-char *outer-invisible-space*))
+                                (expand-tex-macro
+                                  (tdef.optarg y)
+                                  (tdef.argpat y)
+                                  (tdef.expansion y))))))))
+          (else #f))))
+
+(define do-expandafter
+  (lambda ()
+    (let* ((first (get-raw-token/is))
+           (second (get-raw-token/is)))
+      (toss-back-char *invisible-space*)
+      (cond ((ctl-seq? second)
+             (toss-back-string (expand-ctl-seq-into-string second)))
+            (else (toss-back-string second)))
+      (toss-back-char *invisible-space*)
+      (toss-back-string first))))
+
+(define resolve-expandafters
+  (lambda ()
+    (let ((c (snoop-actual-char)))
+      (when (char=? c *esc-char*)
+        (let ((x (get-ctl-seq)))
+          (if (string=? x "\\expandafter")
+              (do-expandafter)
+            (begin (toss-back-char *invisible-space*)
+                   (toss-back-string x))))))))
+
+(define do-futurelet
+  (lambda ()
+    (let* ((first (get-raw-token/is))
+           (second (get-raw-token/is))
+           (third (get-raw-token)))
+      (do-futurelet-aux first second third))))
+
+(define do-futurenonspacelet
+  (lambda ()
+    (let* ((first (get-raw-token/is))
+           (second (get-raw-token/is))
+           (third (get-raw-token/is)))
+      (do-futurelet-aux first second third))))
+
+(define do-futurelet-aux
+  (lambda (first second third)
+    (tex-let first third #f)
+    (toss-back-char *invisible-space*)
+    (toss-back-string third)
+    (toss-back-char *invisible-space*)
+    (toss-back-string second)))
+
+(define set-start-time
+  (lambda ()
+    (let* ((secs (current-seconds))
+           (ht (and secs (seconds->date secs))))
+      (when ht
+        (tex-def-count "\\time"
+                       (+ (* 60 (date-hour ht)) (date-minute ht))
+                       #t)
+        (tex-def-count "\\day" (date-day ht) #t)
+        (tex-def-count "\\month"
+                       (+ (date-month ht) (- *january-number*) 1)
+                       #t)
+        (tex-def-count "\\year"
+                       (+ *anno-domini-at-0* (date-year ht))
+                       #t)))))
+
+(define initialize-globals
+  (lambda ()
+    (set! *global-texframe* (make-texframe))
+    (set! *section-counter-dependencies* (make-table))
+    (set! *dotted-counters* (make-table 'equ string=?))
+    (set! *index-page-mention-alist* (make-table))
+    ;
+    ;for tex, 0 <= \language <= 255.  For
+    ;tex2page, let's make it 256
+    ;
+    (tex-def-count "\\language" 256 #t)
+    ;
+    ;the lowest section depth, the part, is -1
+    ;so -2 is the closest-to-0 number that
+    ;is a meaningless depth
+    ;
+    (tex-def-count "\\secnumdepth" -2 #t)
+    (tex-def-count "\\tocdepth" -2 #t)
+    (tex-def-count "\\footnotenumber" 0 #t)
+    (tex-def-count "\\TIIPtabularborder" 1 #t)
+    (tex-def-count "\\TIIPnestedtabularborder" 0 #t)
+    (tex-def-count "\\TIIPobeyspacestrictly" 0 #t)
+    (tex-def-count "\\TIIPobeylinestrictly" 0 #t)
+    (tex-def-count "\\errorcontextlines" 5 #t)
+    (tex-def-count "\\doublehyphendemerits" 10000 #t)
+    (tex-def-count "\\finalhyphendemerits" 5000 #t)
+    (tex-def-count "\\hyphenpenalty" 50 #t)
+    (tex-def-count "\\exhyphenpenalty" 50 #t)
+    (tex-def-count "\\pretolerance" 100 #t)
+    (tex-def-count "\\tolerance" 200 #t)
+    (tex-def-count "\\hbadness" 1000 #t)
+    (tex-def-count "\\widowpenalty" 150 #t)
+    (tex-def-count "\\showboxdepth" 3 #t)
+    (tex-def-count "\\outputpenalty" 0 #t)
+    (tex-def-count "\\globaldefs" 0 #t)
+    (tex-def-count "\\mag" 1000 #t)
+    (tex-def-count "\\tracingcommands" 0 #t)
+    (tex-def-count "\\tracingmacros" 0 #t)
+    (tex-def-count "\\tracingonline" 0 #t) ; not used yet
+    (tex-def-count "\\time" 0 #t)
+    (tex-def-count "\\day" 0 #t)
+    (tex-def-count "\\month" 0 #t)
+    (tex-def-count "\\year" 0 #t)
+    ;
+    (tex-def-dimen "\\hsize" (tex-length 6.5 ':in) #t)
+    (tex-def-dimen "\\vsize" (tex-length 8.9 ':in) #t)
+    (tex-def-dimen "\\maxdepth" (tex-length 4 ':pt) #t)
+    (tex-def-dimen "\\delimitershortfall" (tex-length 5 ':pt) #t)
+    (tex-def-dimen "\\nulldelimiterspace" (tex-length 1.2 ':pt) #t)
+    (tex-def-dimen "\\scriptspace" (tex-length .5 ':pt) #t)
+    (tex-def-dimen "\\hoffset" 0 #t)
+    (tex-def-dimen "\\voffset" 0 #t)
+    (tex-def-dimen "\\epsfxsize" 0 #t)
+    (tex-def-dimen "\\epsfysize" 0 #t)
+    (tex-def-dimen "\\emergencystretch" 0 #t)
+    (tex-def-dimen "\\hfuzz" (tex-length .1 ':pt) #t)
+    (tex-def-dimen "\\vfuzz" (tex-length .1 ':pt) #t)
+    (tex-def-dimen "\\textwidth" (tex-length 6.5 ':in) #t)
+    (tex-def-dimen "\\baselineskip" (tex-length 12 ':pt) #t)
+    (tex-def-dimen "\\overfullrule" (tex-length 5 ':pt) #t)
+    (tex-def-dimen "\\parindent" (tex-length 20 ':pt) #t)
+    (tex-def-dimen "\\leftskip" 0 #t)
+    (tex-def-dimen "\\parfillskip" 0 #t)
+    (tex-def-dimen "\\parskip" 0 #t)
+    (tex-def-dimen "\\abovedisplayskip" (tex-length 12 ':pt) #t)
+    (tex-def-dimen "\\belowdisplayskip" (tex-length 12 ':pt) #t)
+    ;
+    (tex-def-toks "\\everypar" "" #t)
+    (tex-def-toks "\\headline" "" #t)
+    (tex-def-toks "\\footline" "\\folio" #t)
+    ;
+    (tex-def-dotted-count "figure" #f)
+    (tex-def-dotted-count "table" #f)
+    (tex-def-dotted-count "equation" #f)
+    ;
+    ;
+    (tex-gdef-0arg "\\TIIPcurrentnodename" "no value yet")
+    (tex-gdef-0arg "\\@currentlabel" "no value yet")
+    (tex-gdef-0arg "\\TZPcolophonlastpage" "0")
+    (tex-gdef-0arg "\\TZPcolophontimestamp" "1")
+    (tex-gdef-0arg "\\TZPcolophoncredit" "1")
+    (tex-gdef-0arg "\\TZPcolophonweblink" "1")
+    (tex-gdef-0arg "\\TZPmathimage" "1")
+    (tex-gdef-0arg "\\TZPimageformat" "GIF")
+    (tex-gdef-0arg "\\TZPimageconverter" "NetPBM")
+    (tex-gdef-0arg "\\TZPslatexcomments" "0")
+    (tex-gdef-0arg "\\TZPtexlayout" "0")
+    (tex-gdef-0arg "\\TZPraggedright" "1")
+    ;
+    ;(tex-def-thunk "\\pageno"
+    ;   (lambda () (number->string *html-page-count*))
+    ;   #t)
+
+    (initialize-scm-words)
+    ))
+
+;
+
+(define find-def
+  (lambda (ctlseq)
+    (or (ormap
+          (lambda (fr)
+            (table-get (texframe.definitions fr) ctlseq))
+          *tex-env*)
+        (and *global-texframe*
+             (table-get (texframe.definitions *global-texframe*) ctlseq))
+        (table-get (texframe.definitions *primitive-texframe*) ctlseq))))
+
+;(trace find-def)
+
+(define find-math-def
+  (lambda (ctlseq)
+    (table-get (texframe.definitions *math-primitive-texframe*)
+               ctlseq)))
+
+(define find-count
+  (lambda (ctlseq)
+    (or (ormap (lambda (fr)
+                 (table-get (texframe.counts fr) ctlseq))
+                 *tex-env*)
+        (table-get (texframe.counts *global-texframe*) ctlseq)
+        (table-get (texframe.counts *primitive-texframe*) ctlseq))))
+
+(define find-toks
+  (lambda (ctlseq)
+    (or (ormap (lambda (fr)
+                 (table-get (texframe.toks fr) ctlseq))
+               *tex-env*)
+        (table-get  (texframe.toks *global-texframe*) ctlseq)
+        (table-get (texframe.toks *primitive-texframe*) ctlseq))))
+
+(define find-dimen
+  (lambda (ctlseq)
+    (or (ormap (lambda (fr)
+                 (table-get (texframe.dimens fr) ctlseq))
+          *tex-env*)
+        (table-get (texframe.dimens *global-texframe*) ctlseq)
+        (table-get (texframe.dimens *primitive-texframe*) ctlseq))))
+
+(define get-toks
+  (lambda (ctlseq)
+    (or (find-toks ctlseq)
+        (terror 'get-toks))))
+
+(define get-dimen
+  (lambda (ctlseq)
+    (cond ((find-dimen ctlseq))
+          (else ;let's just assume 6.5in (the default \hsize)
+          (tex-length 6.5 ':in)))))
+
+(define the-count
+  (lambda (ctlseq)
+    (or (find-count ctlseq) (terror 'the-count))))
+
+(define do-count=
+  (lambda (z g?)
+    (get-equal-sign)
+    (tex-def-count z
+                   (get-number)
+                   g?)))
+
+(define do-toks=
+  (lambda (z g?)
+    (get-equal-sign)
+    (tex-def-toks z
+                  (get-group)
+                  g?)))
+
+(define do-dimen=
+  (lambda (z g?)
+    (get-equal-sign)
+    (tex-def-dimen z (get-scaled-points) g?)
+    (ignorespaces)))
+
+(define get-gcount
+  (lambda (ctlseq)
+    (table-get (texframe.counts *global-texframe*) ctlseq)))
+
+(define set-gcount!
+  (lambda (ctlseq v)
+    (tex-def-count ctlseq v #t)))
+
+(define do-number
+  (lambda ()
+    (emit (get-number))))
+
+(define do-magnification
+  (lambda ()
+    (tex-def-count "\\mag" (get-number) #f)))
+
+(define do-magstep
+  (lambda ()
+    (case (string->number (get-token-or-peeled-group))
+      ((1) "1000")
+      ((2) "1200")
+      ((3) "1440")
+      ((4) "1728")
+      ((5) "2074")
+      ((6) "2488")
+      (else ""))))
+
+(define scaled-point-to-tex-point
+  (lambda (sp)
+    (string-append
+      (number->string
+        (/ sp 65536.0)) "pt")))
+
+(define expand-the
+  (lambda ()
+    (let ((ctlseq (get-ctl-seq)))
+      (cond ((find-dimen ctlseq)
+             => (lambda (x) (scaled-point-to-tex-point x)))
+            ((get-number-corresp-to-ctl-seq ctlseq) => (lambda (x) x))
+            ((find-toks ctlseq))
+            (else (trace-if #f "expand-the failed"))))))
+
+(define do-the
+  (lambda ()
+    ;almost like do-number
+    (let ((ctlseq (get-ctl-seq)))
+      (cond ((find-dimen ctlseq)
+             => (lambda (x)
+                  (emit (scaled-point-to-tex-point  x))))
+            ((get-number-corresp-to-ctl-seq ctlseq) => emit)
+            ;       ((find-count ctlseq) =>
+            ;             (lambda (x) (emit (cadr x))))
+            ((find-toks ctlseq)
+             => (lambda (x)
+                  (tex2page-string x)))
+            (else (trace-if #f "do-the failed"))))))
+
+(define find-corresp-prim
+  ;is this really necessary? -- why not make resolve-defs
+  ;take over this too?
+  (lambda (ctlseq)
+    (let ((y (find-def ctlseq)))
+      (or (and y (tdef.defer y))
+          ctlseq))))
+
+(define find-corresp-prim-thunk
+  (lambda (ctlseq)
+    (let ((y (find-def ctlseq)))
+      (if (and y (tdef.thunk y))
+          (tdef.prim y)
+          ctlseq))))
+
+(define global?
+  (lambda ()
+    (> (get-gcount "\\globaldefs") 0)))
+
+(define do-let
+  (lambda (g?)
+    (unless (inside-false-world?)
+      (ignorespaces)
+      (let* ((lhs (get-ctl-seq))
+             (rhs (begin (get-equal-sign)
+                         (get-raw-token/is)))
+             (frame (and g? *global-texframe*)))
+        (if (ctl-seq? rhs)
+            (tex-let lhs rhs frame)
+            (tex-def lhs '() rhs #f #f #f #f frame))))))
+
+(define do-def
+  (lambda (g? e?)
+    (unless (inside-false-world?)
+      (let ((lhs (get-raw-token/is)))
+        (when (and (ctl-seq? lhs) (string=? lhs "\\TIIPcsname"))
+          (set! lhs (get-peeled-group)))
+        (let* ((argpat (get-def-arguments lhs))
+               (rhs (ungroup (get-group)))
+               (frame (and g? *global-texframe*)))
+          (when e?
+            (set! rhs (expand-edef-macro rhs)))
+          (cond ((ctl-seq? lhs)
+                 (tex-def lhs argpat rhs #f #f #f #f frame))
+                (else
+                  (tex-def-char (string-ref lhs 0) argpat rhs frame))))))))
+
+(define do-newcount
+  (lambda (g?)
+    (tex-def-count (get-ctl-seq) 0
+                   g?)))
+
+(define do-newtoks
+  (lambda (g?)
+    (tex-def-toks (get-ctl-seq) ""
+                  g?)))
+
+(define do-newdimen
+  (lambda (g?)
+    (tex-def-dimen (get-ctl-seq) 0
+                   g?)))
+
+(define do-advance
+  (lambda (g?)
+    (let* ((ctlseq (get-ctl-seq))
+           (count (find-count ctlseq)))
+      (get-by)
+      (if count
+          (tex-def-count ctlseq
+                         (+ count (get-number))
+                         g?)
+        (eat-dimen)))))
+
+(define do-multiply
+  (lambda (g?)
+    (let* ((ctlseq (get-ctl-seq))
+           (curr-val (find-count ctlseq)))
+      (get-by)
+      (tex-def-count ctlseq
+                     (* curr-val (get-number))
+                     g?))))
+
+(define do-divide
+  (lambda (g?)
+    (let* ((ctlseq (get-ctl-seq))
+           (curr-val (find-count ctlseq)))
+      (get-by)
+      (tex-def-count ctlseq
+        (quotient curr-val (get-number))
+                     g?))))
+
+(define do-newcommand
+  (lambda (renew?)
+    (ignorespaces)
+    (let* ((lhs (string-trim-blanks (ungroup (get-token))))
+           (optarg #f)
+           (argc
+             (cond ((get-bracketed-text-if-any)
+                    => (lambda (s)
+                         (cond ((get-bracketed-text-if-any)
+                                => (lambda (s)
+                                     (set! optarg s))))
+                         (string->number (string-trim-blanks s))))
+                   (else 0)))
+           (rhs (ungroup (get-token)))
+           (ok-to-def? (or renew? (not (find-def lhs)))))
+      (tex-def lhs (latex-arg-num->plain-argpat argc)
+               rhs optarg #f #f #f #f)
+      (unless ok-to-def?
+        (trace-if (> (find-count "\\tracingcommands") 0)
+                  lhs " already defined")))))
+
+(define do-advancetally
+  (lambda (g?)
+    (let* ((ctlseq (get-ctl-seq))
+           (increment (string->number
+                       (string-trim-blanks (ungroup (get-token))))))
+      (tex-def ctlseq '()
+               (number->string
+                (+ (string->number
+                    (or (resolve-defs ctlseq) ctlseq))
+                   increment))
+               #f #f #f #f
+               g?))))
+
+(define do-newenvironment
+  (lambda (renew?)
+    (ignorespaces)
+    (let* ((envname (string-trim-blanks (ungroup (get-token))))
+           (bs-envname (string-append "\\" envname))
+           (optarg #f)
+           (argc
+             (cond ((get-bracketed-text-if-any)
+                    => (lambda (s)
+                         (cond ((get-bracketed-text-if-any)
+                                => (lambda (s)
+                                     (set! optarg s))))
+                         (string->number (string-trim-blanks s))))
+                   (else 0)))
+           (beginning (string-append "\\begingroup " (ungroup (get-token))))
+           (ending (string-append (ungroup (get-token)) "\\endgroup"))
+           (ok-to-def? (or renew? (not (find-def bs-envname)))))
+      (tex-def bs-envname
+               (latex-arg-num->plain-argpat argc) beginning optarg
+               #f #f #f #f)
+      (tex-def (string-append "\\end" envname) '() ending #f
+               #f #f #f #f)
+      (unless ok-to-def?
+        (trace-if #t "{" envname "} already defined")))))
+
+(define tex-def-dotted-count
+  (lambda (counter-name sec-num)
+    (when sec-num
+      (table-put! *section-counter-dependencies* sec-num
+        (cons counter-name
+          (table-get *section-counter-dependencies* sec-num '()))))
+    (table-put! *dotted-counters* counter-name
+      (make-counter 'within sec-num))))
+
+(define do-newtheorem
+  (lambda ()
+    (let* ((env (ungroup (get-group)))
+           (numbered-like (get-bracketed-text-if-any))
+           (counter-name (or numbered-like env))
+           (caption (ungroup (get-group)))
+           (within (if numbered-like #f (get-bracketed-text-if-any)))
+           (sec-num (and within (section-ctl-seq?
+                                 (string-append "\\" within)))))
+      (unless numbered-like
+        (tex-def-dotted-count counter-name sec-num))
+      (tex-def (string-append "\\" env) '()
+               (string-append "\\par\\begingroup\\TIIPtheorem{"
+                              counter-name "}{" caption "}")
+               #f #f #f #f *global-texframe*)
+      (tex-def (string-append "\\end" env) '()
+               "\\endgroup\\par" #f #f #f #f *global-texframe*))))
+
+(define do-theorem
+  (lambda ()
+    (let* ((counter-name (ungroup (get-group)))
+           (counter (table-get *dotted-counters* counter-name))
+           (caption (ungroup (get-group))))
+      (unless counter (terror 'do-theorem))
+      (let ((new-counter-value (+ 1 (counter.value counter))))
+        (set!counter.value counter new-counter-value)
+        (let* ((thm-num (let ((sec-num (counter.within counter)))
+                          (if sec-num
+                              (string-append (section-counter-value sec-num) "."
+                                (number->string new-counter-value))
+                              (number->string new-counter-value))))
+               (lbl (string-append *html-node-prefix* "thm_" thm-num)))
+          (tex-def-0arg "\\TIIPcurrentnodename" lbl)
+          (tex-def-0arg  "\\@currentlabel" thm-num)
+          (emit-anchor lbl)
+          (emit-newline)
+          (emit "<b>")
+          (emit caption)
+          (emit " ")
+          (emit thm-num)
+          (emit ".</b>")
+          (emit-nbsp 2))))))
+
+(define do-begin
+  (lambda ()
+    (cond ((get-grouped-environment-name-if-any)
+           => (lambda (env)
+                (toss-back-char *invisible-space*)
+                (toss-back-string (string-append "\\" env))
+                (unless (ormap (lambda (y) (string=? env y))
+                               '("htmlonly" "cssblock" "document" "latexonly"
+                                 "rawhtml" "texonly" "verbatim" "verbatim*"))
+                  (toss-back-string "\\begingroup")
+                  (do-end-para))))
+                (else
+                  (terror 'do-begin "\\begin not followed by environment name")))))
+
+(define do-end
+  (lambda ()
+    (cond ((get-grouped-environment-name-if-any)
+           => (lambda (env)
+                (toss-back-char *invisible-space*)
+                (unless (ormap (lambda (y) (string=? env y))
+                               '("htmlonly" "document"))
+                  (do-end-para)
+                  (toss-back-string "\\endgroup"))
+                (toss-back-string (string-append "\\end" env))))
+          (else
+            (toss-back-char *invisible-space*)
+            (toss-back-string "\\TIIPbye")))))
+
+(define latex-arg-num->plain-argpat
+  (lambda (n)
+    (let loop ((n n) (s '()))
+      (if (<= n 0) s
+          (loop (- n 1)
+            (cons #\# (cons (integer->char (+ *int-corresp-to-0* n)) s)))))))
+
+(define make-reusable-img
+  (lambda (g?)
+    (set! *imgdef-file-count* (+ *imgdef-file-count* 1))
+    (ignorespaces)
+    (let ((lhs (get-ctl-seq))
+          (imgdef-file-stem (string-append
+                             *subjobname*
+                             *img-file-suffix* *imgdef-file-suffix*
+                             (number->string *imgdef-file-count*))))
+      (dump-imgdef imgdef-file-stem)
+      (tex-to-img imgdef-file-stem)
+      (tex-def
+       lhs '() (string-append "\\TIIPreuseimage{" imgdef-file-stem "}")
+       #f #f #f #f (and g? *global-texframe*)))))
+
+(define valid-img-file?
+  (lambda (f)
+    (and (file-exists? f)
+         (or
+          (call-with-input-file f
+            (lambda (i)
+              (not (eof-object? (read-char i)))))
+          (begin (delete-file f)
+                 #f)))))
+
+(define source-img-file
+  (lambda (img-file-stem . alt)
+    (let* ((alt (if (null? alt) #f (car alt)))
+           (img-file (string-append img-file-stem (find-img-file-extn)))
+           (f (string-append *aux-dir/* img-file)))
+      (write-log #\()
+      (write-log f)
+      (write-log ':separation-space)
+      (valid-img-file? f)
+      (emit "<img src=\"")
+      (emit img-file)
+      (emit "\" border=\"0\" alt=\"")
+      (cond (alt (emit alt))
+            (else
+              (emit "[")
+              (emit img-file)
+              (emit "]")))
+      (emit "\">")
+      (write-log #\))
+      (write-log ':separation-space)
+      #t ;?
+      )))
+
+(define reuse-img
+  (lambda ()
+    (source-img-file (ungroup (get-group)))))
+
+(define get-def-arguments
+  (lambda (lhs)
+    (let aux ()
+      (let ((c (snoop-actual-char)))
+        (cond ((eof-object? c)
+               (terror 'get-def-arguments
+                       "EOF found while scanning definition of " lhs))
+              ((char=? c *esc-char*)
+               (let ((x (get-ctl-seq)))
+                 (if (string=? x "\\par")
+                     (cons #\newline
+                           (cons #\newline (aux)))
+                     (append (string->list x) (aux)))))
+              ((char=? c #\{) '())
+              (else
+               (cond ((char=? c #\newline)
+                      ;kludge for writing texi-type macros.  Should
+                      ;really be equivalent to any whitespace
+                      (get-actual-char)
+                      (ignorespaces))
+                     ((char-whitespace? c) (ignorespaces)
+                      (set! c #\space))
+                     (else (get-actual-char)))
+               (cons c (aux))))))))
+
+(define get-till-char
+  (lambda (c0)
+    ;(ignorespaces)
+    (list->string
+      (nreverse
+        (let loop ((s '()) (nesting 0) (escape? #f))
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'get-till-char "File ended too soon"))
+                  (escape?
+                    (loop (cons (get-actual-char) s) nesting #f))
+                  ((char=? c c0) s)
+                  ((char=? c *esc-char*)
+                   (loop (cons (get-actual-char) s) nesting #t))
+                  ((char=? c #\{)
+                   (loop (cons (get-actual-char) s) (+ nesting 1) #f))
+                  ((char=? c #\})
+                   (loop (cons (get-actual-char) s) (- nesting 1) #f))
+                  ((> nesting 0)
+                   (loop (cons (get-actual-char) s) nesting #f))
+                  ((and (char-whitespace? c) (not (char=? c0 #\newline))
+                        (char-whitespace? c0))
+                   s)
+                  (else (loop (cons (get-actual-char) s) nesting #f)))))))))
+
+(define digit->int
+  (lambda (d)
+    (- (char->integer d) *int-corresp-to-0*)))
+
+(define do-halign
+  (lambda ()
+    (do-end-para)
+    (ignorespaces)
+    (let ((c (get-actual-char)))
+      (when (eof-object? c) (terror 'do-halign "Missing {"))
+      (unless (char=? c #\{) (terror 'do-halign "Missing {")))
+    (fluid-let ((*tabular-stack* (cons 'halign *tabular-stack*)))
+      (bgroup)
+      (emit "<table>")
+      (let ((tmplt (get-halign-template)))
+        (let loop ()
+          (ignorespaces)
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'do-halign "Eof inside \\halign"))
+                  ((char=? c #\}) (get-actual-char)
+                   (emit "</table>")
+                   (egroup)
+                   (do-para))
+                  (else
+                    (expand-halign-line tmplt)
+                    (loop)))))))))
+
+(define get-halign-template
+  (lambda ()
+    (let loop ((s '()))
+      (let ((x (get-raw-token)))
+        (cond ((eof-object? x)
+               (terror 'get-halign-template "Eof in \\halign"))
+              ((string=? x "\\cr") (nreverse (cons #f s)))
+              ((string=? x "#") (loop (cons #t s)))
+              ((string=? x "&") (loop (cons #f s)))
+              (else (loop (cons x s))))))))
+
+(define expand-halign-line
+  (lambda (tmplt)
+    (emit "<tr>")
+    (let loop ((tmplt tmplt) (ins " "))
+      (let ((x (get-raw-token)))
+        (cond ((eof-object? x)
+               (terror 'expand-halign-line "Eof in \\halign"))
+              ((or (string=? x "&") (string=? x "\\cr"))
+               (let loop2 ((tmplt tmplt) (r "{"))
+                 (if (null? tmplt)
+                     (terror 'expand-halign-line "Eof in \\halign")
+                     (let ((y (car tmplt)))
+                       (case y
+                         ((#f) (emit "<td>")
+                          (tex2page-string (string-append r "}"))
+                          (when (and (string=? x "\\cr")
+                                     (string=? ins " "))
+                            (emit-nbsp 1))
+                          (emit "</td>")
+                          (if (string=? x "\\cr")
+                              (begin (emit "</tr>") (emit-newline))
+                              (loop (cdr tmplt) " ")))
+                         ((#t) (loop2 (cdr tmplt)
+                                 (string-append r ins)))
+                         (else (loop2 (cdr tmplt)
+                                 (string-append r y))))))))
+              (else (loop tmplt (string-append ins x))))))))
+
+(define read-till-next-sharp
+  (lambda (k argpat)
+    (let ((n (length argpat)))
+      (let loop ((ss '()))
+        (let loop2 ((i k) (s '()))
+          (let ((c (if (< i n) (list-ref argpat i) #\#)))
+            (if (char=? c #\#)
+                (cons i (list->string (nreverse ss)))
+                (let ((d (snoop-actual-char)))
+                  (cond ((and (char=? c #\space) (char-whitespace? d))
+                         (ignorespaces)
+                         '(if (char=? d #\newline) (get-actual-char)
+                             (ignorespaces))
+                         (loop2 (+ i 1) (cons c s)))
+                        ((and *comment-char* (char=? d *comment-char*))
+                         (do-comment)
+                         (loop2 i s))
+                        ((and (char=? c #\newline)
+                              (char-whitespace? d)
+                              (or (munched-a-newline?)
+                                  (begin (toss-back-char d) #f)))
+                         (loop2 (+ i 1) (cons c s)))
+                        ((char=? c d) (get-actual-char)
+                         (loop2 (+ i 1) (cons c s)))
+                        ((= i k)
+                         (loop
+                          (if (and (char=? d #\{)
+                                   (or (null? ss)
+                                       (not (char=? (car ss) *esc-char*))))
+                              (append (get-group-as-reversed-chars) ss)
+                              (begin
+                               (if (and (char-whitespace? d)
+                                        (not (char=? d #\newline)))
+                                   (ignorespaces)
+                                   (get-actual-char))
+                               (cons d ss)))))
+                        (else (loop (append s ss))))))))))))
+
+;(trace read-till-next-sharp)
+
+(define read-macro-args
+  (lambda (argpat k r)
+    (let ((n (length argpat)))
+      (nreverse
+       (let loop ((k k) (r r))
+         (if (>= k n) r
+             (let ((c (list-ref argpat k)))
+               ;(resolve-expandafters)
+               (cond ((char=? c #\#)
+                      (cond ((= k (- n 1))
+                             (cons (get-till-char #\{) r))
+                            ((= k (- n 2))
+                             (cons (ungroup (get-token)) r))
+                            (else
+                             (let ((c2 (list-ref argpat (+ k 2))))
+                               (if (char=? c2 #\#)
+                                   (loop (+ k 2)
+                                         (cons (ungroup (get-token)) r))
+                                   (let ((x (read-till-next-sharp
+                                             (+ k 2) argpat)))
+                                     (loop (car x) (cons (cdr x) r))))))))
+                     (else
+                      (let ((d (get-actual-char)))
+                        (cond ((eof-object? d)
+                               (terror 'read-macro-args
+                                       "Eof before macro got enough args"))
+                              ((char=? c d)
+                               (loop (+ k 1) r))
+                              (else
+                               (terror 'read-macro-args
+                                       "Misformed macro call")))))))))))))
+
+;(trace read-macro-args)
+
+(define expand-edef-macro
+  (lambda (rhs)
+    (fluid-let ((*not-processing?* #t))
+      (let ((tmp-port (open-output-string)))
+        (call-with-input-string/buffered
+          rhs
+          (lambda ()
+            (let loop ()
+              (let ((c (snoop-actual-char)))
+                (unless (eof-object? c)
+                  (display
+                    (cond ((char=? c *esc-char*)
+                           (let ((x (get-ctl-seq)))
+                             (toss-back-char *invisible-space*)
+                             (cond ((or (string=? x "\\the")
+                                        (string=? x "\\number"))
+                                    (let ((x2 (get-raw-token/is)))
+                                      (toss-back-char *invisible-space*)
+                                      (toss-back-string x2)
+                                      (cond ((ctl-seq? x2)
+                                             (cond ((string=? x "\\the")
+                                                    (expand-the))
+                                                   ((string=? x "\\number")
+                                                    (get-number))
+                                                   (else "deadcode")))
+                                            (else x))))
+                                   ((string=? x "\\noexpand")
+                                    (let ((x2 (get-raw-token/is)))
+                                      (toss-back-char *invisible-space*)
+                                      x2))
+                                   ((find-def x)
+                                    => (lambda (y)
+                                         (cond ((and (null? (tdef.argpat y))
+                                                     (not (tdef.optarg y))
+                                                     (not (tdef.thunk y))
+                                                     (not (tdef.prim y))
+                                                     (not (tdef.defer y)))
+                                                (toss-back-char *invisible-space*)
+                                                (toss-back-string
+                                                  (tdef.expansion y))
+                                                "")
+                                               (else x))))
+                                   (else x))))
+                          (else (get-actual-char) c))
+                    tmp-port)
+                  (loop))))))
+        (get-output-string tmp-port)))))
+
+(define expand-tex-macro
+  (lambda (optarg argpat rhs)
+    ;(unless (or *in-verb?* *math-mode?*)
+    ;     (ignorespaces))
+    (let* (;(arg-pat-n (length argpat))
+           (k 0)
+           (r (if (not optarg) '()
+                  (begin (set! k 2)
+                    (list (cond ((get-bracketed-text-if-any)
+                                 => (lambda (s) s))
+                                (else optarg))))))
+           (args (read-macro-args argpat k r))
+           (rhs-n (string-length rhs)))
+      (list->string
+        (let aux ((k 0))
+          (if (>= k rhs-n) '()
+              (let ((c (string-ref rhs k)))
+                (cond ((char=? c #\\ )
+                       ;shall we assume esc char inside def bodies is always \ ?
+                       ;when we expand it  \ becomes <curr esc char>
+                       (let loop ((j (+ k 1)) (s (list #\\ )))
+                         (if (>= j rhs-n)
+                             (nreverse s)
+                             (let ((c (string-ref rhs j)))
+                               (cond ((char-alphabetic? c)
+                                      (loop (+ j 1) (cons c s)))
+                                     ((and (char=? c #\#)
+                                           (> (length s) 1))
+                                      ;# preceded by ctlseq -- insert space
+                                      (append (nreverse s)
+                                        ;(string->list "\\TIIPnull1")
+                                        (cons #\space (aux j))))
+                                     ((= (length s) 1)
+                                      (append (nreverse (cons c s))
+                                        (aux (+ j 1))))
+                                     (else
+                                       (append (nreverse s) (aux j))))))))
+                      ((char=? c #\#)
+                       (if (= k (- rhs-n 1))
+                           (list #\#)
+                           (let ((n (string-ref rhs (+ k 1))))
+                             (cond ((char=? n #\#)
+                                    (cons #\# (aux (+ k 2)))) ;really?
+                                   ((and (char-numeric? n)
+                                         (<= (digit->int n) (length args)))
+                                    ;not really such a good test :-<
+                                    (append (string->list
+                                              (list-ref args
+                                                (- (digit->int n) 1)))
+                                      (aux (+ k 2))))
+                                   (else (cons #\# (aux (+ k 1))))))))
+                      (else (cons c (aux (+ k 1))))))))))))
+
+;(trace expand-tex-macro)
+
+;verbatim
+
+(define do-verbatimescapechar
+  (lambda ()
+    (ignorespaces)
+    (let* ((c1 (get-actual-char))
+           (c2 (get-actual-char)))
+      (unless (char=? c1 *esc-char*)
+        (terror 'do-verbatimescapechar "Arg must be \\<char>"))
+      (set! *esc-char-verb* c2))))
+
+(define do-verb-braced
+  (lambda (ignore)
+    (fluid-let ((*esc-char* *esc-char-verb*)
+                (*tex-extra-letters* '()))
+      (let loop ((nesting 0))
+        (let ((c (get-actual-char)))
+          (cond ((eof-object? c)
+                 (terror 'do-verb-braced "Eof inside verbatim"))
+                ((char=? c *esc-char*)
+                 (toss-back-char c)
+                 (let ((x (fluid-let ((*not-processing?* #t))
+                            (get-ctl-seq))))
+                   (cond ((ormap (lambda (z) (string=? x z))
+                                 '("\\ " "\\{" "\\}"))
+                          (emit (string-ref x 1)))
+                         (else
+                          (fluid-let ((*esc-char* *esc-char-std*))
+                            (do-tex-ctl-seq-completely x)))))
+                 (loop nesting))
+                ((char=? c #\{)
+                 (emit #\{)
+                 (loop (+ nesting 1)))
+                ((char=? c #\})
+                 (unless (= nesting 0)
+                   (emit #\})
+                   (loop (- nesting 1))))
+                ((char=? c #\space)
+                 (emit
+                  (if *verb-visible-space?*
+                      *verbatim-visible-space*
+                    #\space))
+                 (loop nesting))
+                ((char=? c #\newline)
+                 (cond (*verb-display?* (emit "&nbsp;")
+                                        (emit-newline))
+                       (*verb-visible-space?*
+                        (emit *verbatim-visible-space*))
+                       (else (emit-newline)))
+                 (loop nesting))
+                ((and (char=? c #\-) (not *verb-display?*))
+                 (emit "&#x2011;") (loop nesting))
+                (else (emit-html-char c)
+                      (loop nesting))))))))
+
+(define do-verb-delimed
+  (lambda (d)
+    (let loop ()
+      (let ((c (get-actual-char)))
+        (cond ((eof-object? c)
+               (terror 'do-verb-delimed "Eof inside verbatim"))
+              ((char=? c d) 'done)
+              ((char=? c #\space)
+               (emit
+               (if *verb-visible-space?*
+                   *verbatim-visible-space*
+ #\space))
+               (loop))
+              ((char=? c #\newline)
+               (cond (*verb-display?* (emit "&nbsp;")
+                                      (emit-newline))
+                     (*verb-visible-space?*
+                      (emit *verbatim-visible-space*))
+                     (else (emit-newline)))
+               (loop))
+              ((and (char=? c #\-) (not *verb-display?*))
+               (emit "&#x2011;") (loop))
+              (else (emit-html-char c)
+                    (loop)))))))
+
+(define do-verb
+  (lambda ()
+    (ignorespaces)
+    (bgroup)
+    (fluid-let ((*verb-visible-space?* (eat-star))
+                (*ligatures?* #f))
+      (let ((d (get-actual-char)))
+        (fluid-let ((*verb-display?* (munched-a-newline?)))
+          (cond (*outputting-external-title?* #f)
+                (*verb-display?* (do-end-para) (emit "<pre class=verbatim>"))
+                (else (emit "<code class=verbatim>")))
+          ((if (char=? d #\{)
+               do-verb-braced
+               do-verb-delimed) d)
+          (cond (*outputting-external-title?* #f)
+                (*verb-display?* (emit "</pre>") ;(do-para)
+                                 (do-noindent))
+                (else (emit "</code>"))))))
+    (egroup)))
+
+(define do-verbc
+  (lambda ()
+    (ignorespaces)
+    (bgroup)
+    (fluid-let ((*ligatures?* #f))
+      (emit "<code class=verbatim>")
+      (emit-html-char (get-actual-char))
+      (emit "</code>"))
+    (egroup)))
+
+(define do-verbatiminput
+  (lambda ()
+    (ignorespaces)
+    (let ((f (add-dot-tex-if-no-extension-provided
+               (get-filename-possibly-braced))))
+      (cond ((file-exists? f)
+             (do-end-para)
+             (bgroup)
+             (emit "<pre class=verbatim>")
+             (call-with-input-file f
+               (lambda (p)
+                 (let loop ()
+                   (let ((c (read-char p)))
+                     (unless (eof-object? c)
+                       (emit-html-char c)
+                       (loop))))))
+             (emit "</pre>")
+             (egroup)
+             (do-para))
+            (else
+             (non-fatal-error
+              "File " f " not found"))))))
+
+(define do-verbwritefile
+  (lambda ()
+    (let* ((f (get-filename-possibly-braced))
+           (e (file-extension f)))
+      (unless e
+        (set! e ".tex")
+        (set! f (string-append f e)))
+      (when *verb-port* (close-output-port *verb-port*))
+      (ensure-file-deleted f)
+      (set! *verb-written-files* (cons f *verb-written-files*))
+      (when (string-ci=? e ".mp")
+        (set! *mp-files* (cons f *mp-files*)))
+      (set! *verb-port* (open-output-file f)))))
+
+(define verb-ensure-output-port
+  (lambda ()
+    (unless *verb-port*
+      (let ((output-file (string-append *jobname* ".txt")))
+        (ensure-file-deleted output-file)
+        (set! *verb-port*
+          (open-output-file output-file))))))
+
+(define dump-groupoid
+  (lambda (p)
+    (ignorespaces)
+    (let ((write-char write-char)
+          (d (get-actual-char)))
+      (unless p
+        (set! write-char (lambda (x y) #f)))
+      (case d
+        ((#\{) (let loop ((nesting 0))
+                 (let ((c (get-actual-char)))
+                   (cond ((eof-object? c)
+                          (terror 'dump-groupoid
+                                  "Eof inside verbatim"))
+                         ((char=? c *esc-char-verb*)
+                          (write-char c p)
+                          (write-char (get-actual-char) p)
+                          (loop nesting))
+                         ((char=? c #\{)
+                          (write-char c p)
+                          (loop (+ nesting 1)))
+                         ((char=? c #\})
+                          (unless (= nesting 0)
+                            (write-char c p)
+                            (loop (- nesting 1))))
+                         (else (write-char c p)
+                               (loop nesting))))))
+        (else (let loop ()
+                (let ((c (get-actual-char)))
+                  (cond ((eof-object? c)
+                         (terror 'dump-groupoid
+                                 "Eof inside verbatim"))
+                        ((char=? c d) 'done)
+                        (else (write-char c p)
+                              (loop))))))))))
+
+(define do-makehtmlimage
+  (lambda ()
+    (ignorespaces)
+    (unless (char=? (snoop-actual-char) #\{)
+      (terror 'do-makehtmlimage "\\makehtmlimage's argument must be a group"))
+     (call-with-html-image-port dump-groupoid)))
+
+(define do-verbwrite
+  (lambda ()
+    (verb-ensure-output-port)
+    (dump-groupoid *verb-port*)))
+
+(define do-string
+  (lambda ()
+    (let ((c (snoop-actual-char)))
+      (cond ((eof-object? c) #f)
+            ((char=? c *esc-char*)
+             (get-actual-char) (toss-back-char *invisible-space*)
+             (toss-back-string "\\TIIPbackslash"))
+            ((char=? c *comment-char*) (eat-till-eol) (do-string))
+            (else (toss-back-char (get-actual-char)))))))
+
+;LaTeX and eplain verbatim
+
+(define do-verbatim
+  (lambda ()
+    (if (eqv? *tex-format* ':latex)
+      (do-verbatim-latex "verbatim")
+      (do-verbatim-eplain))))
+
+(define do-verbatim-latex
+  (lambda (env)
+    (do-end-para)
+    (bgroup)
+    (fluid-let ((*verb-visible-space?* (eat-star)))
+               (when *verb-visible-space?*
+                 (set! env (string-append env "*")))
+      (emit "<pre class=verbatim>")
+      (munched-a-newline?)
+      (fluid-let ((*ligatures?* #f))
+        (let loop ()
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'do-verbatim-latex
+                           "Eof inside verbatim"))
+                  ((char=? c #\\ )
+                   (let ((end? (get-ctl-seq)))
+                     (if (string=? end? "\\end")
+                         (cond ((get-grouped-environment-name-if-any)
+                                => (lambda (e)
+                                  (unless (string=? e env)
+                                    (emit-html-string end?)
+                                    (emit-html-char #\{)
+                                    (emit-html-string e)
+                                    (emit-html-char #\})
+                                    (loop))))
+                               (else (emit-html-string end?)
+                                     (loop)))
+                         (begin
+                          (emit-html-string end?)
+                          (loop)))))
+                  ((char=? c #\space)
+                   (get-actual-char)
+                   (emit
+                   (if *verb-visible-space?*
+                       *verbatim-visible-space*
+ #\space))
+                   (loop))
+                  (else (emit-html-char (get-actual-char))
+                        (loop))))))
+      (emit "</pre>"))
+    (egroup)
+    (do-para)))
+
+(define do-verbatim-eplain
+  (lambda ()
+    (fluid-let ((*inside-eplain-verbatim?* #t)
+                (*esc-char* *esc-char-verb*))
+      (let loop ()
+        (when *inside-eplain-verbatim?*
+          (let ((c (get-actual-char)))
+            (cond ((eof-object? c) (terror 'do-verbatim-eplain "Eof inside verbatim"))
+                  ((char=? c *esc-char*)
+                   (toss-back-char c)
+                   (let ((x (fluid-let ((*not-processing?* #t))
+                              (get-ctl-seq))))
+                     (cond ((string=? x "\\ ") (emit " "))
+                           (else (do-tex-ctl-seq-completely x))))
+                   (loop))
+                  ((char=? c #\space) (emit "&nbsp;") (loop))
+                  ((char=? c #\newline) (emit "<br>") (emit-newline)
+                                        (loop))
+                  (else (emit-html-char c)
+                        (loop)))))))))
+
+(define do-endverbatim-eplain
+  (lambda ()
+    (set! *inside-eplain-verbatim?* #f)))
+
+;
+
+(define do-alltt
+  (lambda ()
+    (do-end-para)
+    (bgroup)
+    (emit "<pre class=verbatim>")
+    (munched-a-newline?)
+    (fluid-let ((*in-alltt?* #t))
+      (let loop ()
+        (let ((c (snoop-actual-char)))
+          (if (eof-object? c)
+              (terror 'do-alltt "Eof inside alltt")
+              (begin
+               (case c
+                 ((#\\ ) (do-tex-ctl-seq (get-ctl-seq)))
+                 ((#\{) (get-actual-char) (bgroup))
+                 ((#\}) (get-actual-char) (egroup))
+                 (else (emit-html-char (get-actual-char))))
+               (when *in-alltt?* (loop)))))))))
+
+(define do-end-alltt
+  (lambda ()
+    (emit "</pre>")
+    (egroup)
+    (do-para)
+    (set! *in-alltt?* #f)))
+
+;Scheme tokens
+
+(define do-scm-set-specialsymbol
+  (lambda ()
+    (let* ((sym (get-peeled-group))
+           (xln (get-group)))
+      (table-put! *scm-special-symbols* sym xln))))
+
+(define do-scm-unset-specialsymbol
+  (lambda ()
+    (call-with-input-string/buffered
+      (ungroup (get-group))
+      (lambda ()
+        (let loop ()
+          (ignore-all-whitespace)
+          (unless (eof-object? (snoop-actual-char))
+            (table-put! *scm-special-symbols*
+                        (scm-get-token) #f)
+            (loop)))))))
+
+(define do-scm-set-builtins
+  (lambda ()
+    (call-with-input-string/buffered
+     (ungroup (get-group))
+     (lambda ()
+       (let loop ()
+         (ignore-all-whitespace)
+         (let ((c (snoop-actual-char)))
+           (unless (eof-object? c)
+             (let ((s (scm-get-token)))
+               (table-put! *scm-keywords* s #f)
+               (table-put! *scm-variables* s #f)
+               (table-put! *scm-builtins* s #t))
+             (loop))))))))
+
+(define do-scm-set-keywords
+  (lambda ()
+    (call-with-input-string/buffered
+     (ungroup (get-group))
+     (lambda ()
+       (let loop ()
+         (ignore-all-whitespace)
+         (let ((c (snoop-actual-char)))
+           (unless (eof-object? c)
+             (let ((s (scm-get-token)))
+               (table-put! *scm-builtins* s #f)
+               (table-put! *scm-variables* s #f)
+               (table-put! *scm-keywords* s #t))
+             (loop))))))))
+
+(define do-scm-set-variables
+  (lambda ()
+    (call-with-input-string/buffered
+     (ungroup (get-group))
+     (lambda ()
+       (let loop ()
+         (ignore-all-whitespace)
+         (let ((c (snoop-actual-char)))
+           (unless (eof-object? c)
+             (let ((s (scm-get-token)))
+               (table-put! *scm-builtins* s #f)
+               (table-put! *scm-keywords* s #f)
+               (table-put! *scm-variables* s #t))
+             (loop))))))))
+
+;displaying Scheme programs
+
+(define scm-emit-html-char
+  (lambda (c)
+    (unless (eof-object? c)
+      (when *scm-dribbling?* (write-char c *verb-port*))
+      (if (and (char=? c #\-) (not *verb-display?*))
+          (emit "&#x2011;")
+        (emit-html-char c)))))
+
+(define scm-output-next-chunk
+  (lambda ()
+    (let ((c (snoop-actual-char)))
+      (cond ((and *slatex-math-escape*
+                  (char=? c *slatex-math-escape*))
+             (scm-escape-into-math))
+            ((char=? c #\;) (scm-output-comment) (do-end-para))
+            ((char=? c #\") (scm-output-string))
+            ((char=? c #\#) (scm-output-hash))
+            ((char=? c #\,) (get-actual-char)
+             (emit "<span class=keyword>")
+             (scm-emit-html-char c)
+             (let ((c (snoop-actual-char)))
+               (when (char=? c #\@)
+                 (get-actual-char)
+                 (scm-emit-html-char c)))
+             (emit "</span>"))
+            ((or (char=? c #\') (char=? c #\`))
+             (get-actual-char)
+             (emit "<span class=keyword>")
+             (scm-emit-html-char c)
+             (emit "</span>"))
+            ((or (char-whitespace? c) (memv c *scm-token-delims*))
+             (get-actual-char)
+             (scm-emit-html-char c))
+            (else (scm-output-token (scm-get-token)))))))
+
+(define scm-set-mathescape
+  (lambda (yes?)
+    (let ((c (fluid-let ((*esc-char* (integer->char 0)))
+               (string-ref (ungroup (get-group)) 0))))
+      (cond (yes?
+              (set! *slatex-math-escape* c)
+              (set! *scm-token-delims*
+                (cons *slatex-math-escape* *scm-token-delims*)))
+            (else
+              (set! *slatex-math-escape* #f)
+              (set! *scm-token-delims*
+                (ldelete c *scm-token-delims* char=?)))))))
+
+(define scm-escape-into-math
+  (lambda ()
+    (get-actual-char)
+    (let ((math-text (get-till-char *slatex-math-escape*)))
+      (get-actual-char)
+      (unless (string=? math-text "")
+        (emit "<span class=variable>")
+        (fluid-let ((*esc-char* *esc-char-std*))
+          (tex2page-string (string-append "$" math-text "$")))
+        (emit "</span>")))))
+
+(define scm-output-slatex-comment
+  (lambda ()
+    (let ((s (get-line)))
+      (emit "<span class=comment>")
+      (when *scm-dribbling?*
+        (display s *verb-port*)
+        (newline *verb-port*))
+      (fluid-let ((*esc-char* *esc-char-std*))
+        (tex2page-string s))
+      (do-end-para)
+      (emit "</span>")
+      (toss-back-char #\newline)
+      ;(emit-newline)
+      )))
+
+(define scm-output-verbatim-comment
+  (lambda ()
+    ;(get-actual-char)
+    (emit "<span class=comment>")
+    ;(scm-emit-html-char #\;)
+    (let loop ()
+      (let ((c (get-actual-char)))
+        (cond ((or (eof-object? c) (char=? c #\newline))
+               (emit "</span>")
+               (scm-emit-html-char c))
+              ((and (char-whitespace? c)
+                    (let ((c2 (snoop-actual-char)))
+                      (or (eof-object? c2) (char=? c2 #\newline))))
+               (emit "</span>")
+               (scm-emit-html-char (get-actual-char)))
+              (else (scm-emit-html-char c)
+                (loop)))))))
+
+(define scm-output-comment
+  (lambda ()
+    ((if (tex2page-flag-boolean "\\TZPslatexcomments")
+         scm-output-slatex-comment
+         scm-output-verbatim-comment))))
+
+(define scm-output-extended-comment
+  (lambda ()
+    (get-actual-char)              ;read the `|'
+    (emit "<span class=comment>")
+    (scm-emit-html-char #\#)
+    (scm-emit-html-char #\|)
+    (let loop ()
+      (let ((c (get-actual-char)))
+        (cond ((eof-object? c) #t)
+              ((char=? c #\|)
+               (let ((c2 (snoop-actual-char)))
+                 (cond ((eof-object? c2) (scm-emit-html-char c))
+                       ((char=? c2 #\#) (get-actual-char))
+                       (else (scm-emit-html-char c)
+                             (loop)))))
+              (else (scm-emit-html-char c)
+                    (loop)))))
+    (scm-emit-html-char #\|)
+    (scm-emit-html-char #\#)
+    (emit "</span>")))
+
+(define scm-output-string
+  (lambda ()
+    (get-actual-char)
+    (emit "<span class=selfeval>")
+    (scm-emit-html-char #\")
+    (let loop ((esc? #f))
+      (let ((c (get-actual-char)))
+        (case c
+          ((#\") (when esc?
+                   (scm-emit-html-char c) (loop #f)))
+          ((#\\ ) (scm-emit-html-char c) (loop (not esc?)))
+          (else (scm-emit-html-char c) (loop #f)))))
+    (scm-emit-html-char #\")
+    (emit "</span>")))
+
+(define scm-output-hash
+  (lambda ()
+    (get-actual-char) ;read the #\#
+    (let ((c (snoop-actual-char)))
+      (cond ((eof-object? c)
+             (emit "<span class=selfeval>")
+             (scm-emit-html-char #\#)
+             (emit "</span>"))
+            ((char=? c #\|) (scm-output-extended-comment))
+            (else (toss-back-char #\#)
+                  (scm-output-token (scm-get-token)))))))
+
+(define scm-output-token
+  (lambda (s)
+    (case (scm-get-type s)
+      ((special-symbol)
+       (fluid-let ((*esc-char* *esc-char-std*))
+         (tex2page-string
+           (table-get *scm-special-symbols* s))))
+      ((keyword)
+       (emit "<span class=keyword>")
+       (scm-display-token s)
+       (emit "</span>"))
+      ((global)
+       (emit "<span class=global>")
+       (scm-display-token s)
+       (emit "</span>"))
+      ((selfeval)
+       (emit "<span class=selfeval>")
+       (scm-display-token s)
+       (emit "</span>"))
+      ((builtin)
+       (emit "<span class=builtin>")
+       (scm-display-token s)
+       (emit "</span>"))
+      ((background)
+       (scm-display-token s))
+      (else
+        (emit "<span class=variable>")
+        (scm-display-token s)
+        (emit "</span>")))))
+
+(define scm-display-token
+  (lambda (s)
+    (let ((n (string-length s)))
+      (let loop ((k 0))
+        (when (< k n)
+          (scm-emit-html-char (string-ref s k))
+          (loop (+ k 1)))))))
+
+(define do-scm-braced
+  (lambda (result?)
+    (get-actual-char)
+    (let ((display? (munched-a-newline?)))
+      (cond ((not display?)
+             (emit "<code class=scheme")
+             (when result? (emit "response"))
+             (emit ">"))
+            (else (do-end-para) (emit "<pre class=scheme>")))
+      (bgroup)
+      (fluid-let ((*esc-char* *esc-char-verb*)
+                  (*verb-display?* display?))
+        (let loop ((nesting 0))
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'do-scm-braced "Eof inside verbatim"))
+                  ((char=? c *esc-char*)
+                   (let ((x (fluid-let ((*not-processing?* #t))
+                              (get-ctl-seq))))
+                     (cond ((ormap (lambda (z) (string=? x z))
+                                   '("\\ " "\\{" "\\}"))
+                            (scm-emit-html-char (string-ref x 1)))
+                           (else
+                            (fluid-let ((*esc-char* *esc-char-std*))
+                              (do-tex-ctl-seq-completely x)))))
+                   (loop nesting))
+                  ((char=? c #\{)
+                   (get-actual-char)
+                   (scm-emit-html-char c)
+                   (loop (+ nesting 1)))
+                  ((char=? c #\})
+                   (get-actual-char)
+                   (unless (= nesting 0)
+                     (scm-emit-html-char c)
+                     (loop (- nesting 1))))
+                  (else (scm-output-next-chunk)
+                        (loop nesting))))))
+      (egroup)
+      (if (not display?) (emit "</code>")
+          (begin (emit "</pre>")
+                 ;(do-para)
+                 (do-noindent)
+                 )))))
+
+(define do-scm-delimed
+  (lambda (result?)
+    (let ((d (get-actual-char)))
+      (let ((display? (munched-a-newline?)))
+        (cond  ((not display?) (emit "<code class=scheme")
+                         (when result? (emit "response"))
+                         (emit ">"))
+               (else (do-end-para) (emit "<pre class=scheme>")))
+        (fluid-let ((*verb-display?* display?)
+                    (*scm-token-delims* (cons d *scm-token-delims*)))
+          (let loop ()
+            (let ((c (snoop-actual-char)))
+              (cond ((eof-object? c)
+                     (terror 'do-scm-delimed "Eof inside verbatim"))
+                    ((char=? c d) (get-actual-char))
+                    (else (scm-output-next-chunk)
+                      (loop))))))
+        (if (not display?) (emit "</code>")
+            (begin (emit "</pre>") (do-para)))))))
+
+(define do-scm
+  (lambda (result?)
+    (cond (*outputting-external-title?* (do-verb))
+          (else
+            (ignorespaces)
+            (bgroup)
+            (fluid-let ((*ligatures?* #f))
+              ((if (char=? (snoop-actual-char) #\{)
+                   do-scm-braced
+                   do-scm-delimed) result?))
+            (egroup)))))
+
+(define do-scminput
+  (lambda ()
+    (ignorespaces)
+    (do-end-para)
+    (bgroup)
+    (emit "<pre class=scheme>")
+    (let ((f (add-dot-tex-if-no-extension-provided
+               (get-filename-possibly-braced))))
+      (call-with-input-file/buffered f
+        (lambda ()
+          (let loop ()
+            (let ((c (snoop-actual-char)))
+              (unless (eof-object? c)
+                (scm-output-next-chunk)
+                (loop)))))))
+    (emit "</pre>")
+    (egroup)
+    ;(do-para)
+    (do-noindent)))
+
+;Literate programming
+
+(define do-scmdribble
+  (lambda ()
+    (verb-ensure-output-port)
+    (fluid-let ((*scm-dribbling?* #t))
+      (do-scm #f))
+    (newline *verb-port*)))
+
+;SLaTeX {schemedisplay}, &c
+
+(define do-scm-slatex-lines
+  (lambda (env display? result?)
+    (let ((endenv (string-append "\\end" env))
+          (in-table? (and (not (null? *tabular-stack*))
+                          (memv (car *tabular-stack*) '(:block :figure :table)))))
+      (cond (display? (do-end-para))
+            (in-table? (emit "</td><td>")))
+      (munched-a-newline?)
+      (bgroup)
+      (emit "<div align=left><pre class=scheme")
+      (when result? (emit "response"))
+      (emit ">")
+      (fluid-let ((*ligatures?* #f)
+                  (*verb-display?* #t)
+                  (*not-processing?* #t))
+        (let loop ()
+          (let ((c (snoop-actual-char)))
+            (cond ((eof-object? c)
+                   (terror 'do-scm-slatex-lines
+                           "Eof inside " env))
+                  ((char=? c #\newline) (get-actual-char)
+                   (scm-emit-html-char c)
+                   (cond ((not (tex2page-flag-boolean "\\TZPslatexcomments")) #f)
+                         ((char=? (snoop-actual-char) #\;)
+                          (get-actual-char)
+                          (if (char=? (snoop-actual-char) #\;)
+                              (toss-back-char #\;)
+                              (scm-output-slatex-comment))))
+                   (loop))
+                  ((char=? c *esc-char*)
+                   (let ((x (get-ctl-seq)))
+                     (cond ((string=? x endenv) #t)
+                           ((string=? x "\\end")
+                            (let ((g (get-grouped-environment-name-if-any)))
+                              (if (and g (string=? g env))
+                                  (egroup)
+                                  (begin
+                                   (scm-output-token x)
+                                   (when g
+                                     (scm-output-token "{")
+                                     (scm-output-token g)
+                                     (scm-output-token "}"))
+                                   (loop)))))
+                           (else (scm-output-token x) (loop)))))
+                  (else (scm-output-next-chunk)
+                        (loop))))))
+      (emit "</pre></div>")
+      (egroup)
+      (cond (display? (do-para))
+            (in-table? (emit "</td><td>"))))))
+
+(define string-is-all-dots?
+  (lambda (s)
+    (let ((n (string-length s)))
+      (let loop ((i 0))
+        (cond ((>= i n) #t)
+              ((char=? (string-ref s i) #\.) (loop (+ i 1)))
+              (else #f))))))
+
+(define string-is-flanked-by-stars?
+  (lambda (s)
+    (let ((n (string-length s)))
+      (and (>= n 3)
+           (char=? (string-ref s 0) #\*)
+           (char=? (string-ref s (- n 1)) #\*)))))
+
+(define string-starts-with-hash?
+  (lambda (s)
+    (char=? (string-ref s 0) #\#)))
+
+(define scm-get-type
+  (lambda (s)
+    (cond ((table-get *scm-special-symbols* s) 'special-symbol)
+          ((table-get *scm-keywords* s) 'keyword)
+          ((table-get *scm-builtins* s) 'builtin)
+          ((table-get *scm-variables* s) 'variable)
+          ((string-is-flanked-by-stars? s) 'global)
+          (else
+           (let ((colon (string-index s #\:)))
+             ;should use string->number only after ascertaining
+             ;that s has no colon, is not all dots,
+             ;and doesn't start with #.  Otherwise
+             ;the cl version of this code could choke
+             (cond (colon (if (= colon 0) 'selfeval 'variable))
+                   ((string-is-all-dots? s) 'background)
+                   ((string-starts-with-hash? s) 'selfeval)
+                   ((string->number s) 'selfeval)
+                   (else 'variable)))))))
+
+(define eat-star
+  (lambda ()
+    (let ((c (snoop-actual-char)))
+      (if (and (not (eof-object? c))
+               (char=? c #\*))
+          (get-actual-char)
+          #f))))
+
+(define do-cr
+  (lambda (z)
+    (ignorespaces)
+    (let ((top-tabular (if (not (null? *tabular-stack*))
+                           (car *tabular-stack*) 'nothing)))
+      (case top-tabular
+        ((:tabular)
+         (get-bracketed-text-if-any)
+         (egroup)
+         (emit "</td></tr>")
+         (emit-newline)
+         (emit "<tr><td valign=top ")
+         (do-tabular-multicolumn)
+         )
+        ((:eqnarray*)
+         (emit "</td></tr>") (emit-newline)
+         (set! *equation-position* 0)
+         (emit "<tr><td align=right>"))
+        ((:eqnarray)
+         (emit "</td>")
+         (cond (*equation-numbered?*
+                (emit "<td>(")
+                (emit *equation-number*)
+                (bump-dotted-counter "equation")
+                (emit ")</td>"))
+               (else (set! *equation-numbered?* #t)))
+         (emit "</tr>") (emit-newline)
+         (set! *equation-position* 0)
+         (emit "<tr><td align=right>"))
+        ((:ruled-table) (emit "</td></tr>")
+         (emit-newline)
+         (emit "<tr><td>"))
+        ((:minipage :tabbing)
+         (get-bracketed-text-if-any)
+         (emit "<br>") (emit-newline))
+        ((:eqalign :eqalignno :displaylines :pmatrix :mathbox)
+         (unless (char=? (snoop-actual-char) #\})
+           (set! *math-height* (+ *math-height* 1))
+           (emit "</td></tr>") (emit-newline)
+           (emit "<tr><td align=center>")
+           (set! *equation-position* 0)
+           (emit-newline)))
+        ((:header) (emit #\space))
+        (else
+          (when (and (eqv? *tex-format* ':latex)
+                     (string=? z "\\\\"))
+            (get-bracketed-text-if-any)
+            (let ((c (snoop-actual-char)))
+              (when (and (not (eof-object? c)) (char=? c #\*))
+                (get-actual-char)))
+            (emit "<br>")
+            (emit-newline))
+          )))))
+
+(define do-ruledtable
+  (lambda ()
+    (set! *tabular-stack* (cons ':ruled-table *tabular-stack*))
+    (emit "<table border=2><tr><td>") (emit-newline)))
+
+(define do-endruledtable
+  (lambda ()
+    (emit-newline)
+    (emit "</td></tr></table>") (emit-newline)
+    (pop-tabular-stack ':ruled-table)))
+
+(define do-tabular
+  (lambda ()
+    (do-end-para)
+    (get-bracketed-text-if-any)
+    (bgroup)
+    (add-postlude-to-top-frame
+      (let ((old-math-mode? *math-mode?*)
+            (old-in-display-math? *in-display-math?*))
+        (set! *math-mode?* #f)
+        (set! *in-display-math?* #f)
+        (lambda ()
+          (set! *math-mode?* old-math-mode?)
+          (set! *in-display-math?* old-in-display-math?))))
+    (let ((border-width
+            (if (string-index (get-group) #\|) 1 0)))
+      (set! *tabular-stack* (cons ':tabular *tabular-stack*))
+      (emit "<table border=")
+      (emit border-width)
+      (emit "><tr><td valign=top ")
+      (do-tabular-multicolumn))))
+
+(define do-end-tabular
+  (lambda ()
+    (egroup)
+    (do-end-para)
+    (emit "</td></tr></table>")
+    (pop-tabular-stack ':tabular)
+    (egroup)))
+
+(define do-tabular-colsep
+  (lambda ()
+    (egroup)
+    (emit "</td><td valign=top ")
+    (do-tabular-multicolumn)))
+
+(define do-tabular-multicolumn
+  (lambda ()
+    (let loop ()
+      (ignorespaces)
+      (let ((c (snoop-actual-char)))
+        (when (and (char? c) (char=? c #\\ ))
+          (let ((x (get-ctl-seq)))
+            (cond ((string=? x "\\hline") (loop))
+                  ((string=? x "\\multicolumn")
+                   (let ((n (ungroup (get-token))))
+                     (get-token)
+                     (emit " colspan=")
+                     (emit n)))
+                  (else (toss-back-char *invisible-space*)
+                        (toss-back-string x)))))))
+    (emit ">")
+    (bgroup)))
+
+(define do-ruledtable-colsep
+  (lambda ()
+    (emit-newline)
+    (emit "</td><td")
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (when (char=? c #\\ )
+          (let ((x (get-ctl-seq)))
+            (if (string=? x "\\multispan")
+                (let ((n (ungroup (get-token))))
+                  (emit " colspan=")
+                  (emit n))
+                (toss-back-string x)))))
+    (emit ">") (emit-newline)))
+
+(define do-romannumeral
+  (lambda (upcase?)
+    (cond ((get-number-or-false)
+           => (lambda (n)
+                (emit
+                  (number->roman n upcase?)))))))
+
+(define do-uppercase
+  (lambda ()
+    (emit
+      (string-upcase
+        (tex-string->html-string (get-token))))))
+
+(define set-latex-counter
+  (lambda (add?)
+    (let* ((counter-name (get-peeled-group))
+           (new-value (string->number (get-token-or-peeled-group))))
+      (cond ((table-get *dotted-counters* counter-name)
+             => (lambda (counter)
+               (set!counter.value counter
+                                  (if add?
+                                      (+ new-value (counter.value counter))
+                                      new-value))))
+            (else
+              (let ((count-seq (string-append "\\" counter-name)))
+                (cond
+                  ((section-ctl-seq? count-seq)
+                   => (lambda (n)
+                        (table-put! *section-counters* n
+                                    (if add?
+                                        (+ new-value
+                                           (table-get *section-counters* n 0))
+                                        new-value))))
+                  ((find-count count-seq)
+                   ;typically \secnumdepth, \tocdepth
+                   (set-gcount! count-seq
+                                (if add?
+                                    (+ new-value (get-gcount count-seq))
+                                    new-value)))
+                  (else ;(terror 'set-latex-counter)
+                    #f))))))))
+
+(define do-tex-prim
+  (lambda (z)
+    (cond ((find-def z)
+           => (lambda (y)
+             (cond ((tdef.defer y) => toss-back-string)
+                   ((tdef.thunk y) => (lambda (th) (th)))
+                   (else (expand-tex-macro
+                          (tdef.optarg y)
+                          (tdef.argpat y)
+                          (tdef.expansion y))))))
+          ((section-ctl-seq? z) => (lambda (n) (do-heading n)))
+          (*math-mode?* (do-math-ctl-seq z))
+          (else
+            (trace-if (> (find-count "\\tracingcommands") 0)
+                      "Ignoring " z)))))
+
+(define do-char
+  (lambda ()
+    (let ((n (get-number-or-false)))
+      (unless n (terror 'do-char "not a char"))
+      (cond ((< n 128) (emit-html-char (integer->char n)))
+            (else (emit "&#x")
+                  (emit (number->string n 16))
+                  (emit ";"))))))
+
+(define do-tex-char
+  (lambda (c)
+    (cond ((and *comment-char* (char=? c *comment-char*))
+           (do-comment))
+          ((inside-false-world?) #t)
+          ((char=? c #\{) (bgroup))
+          ((char=? c #\}) (egroup))
+          ((char=? c #\$) (do-math))
+          ((char=? c #\-) (do-hyphen))
+          ((char=? c #\`) (do-lsquo))
+          ((char=? c #\') (do-rsquo))
+          ((char=? c #\~) (emit-nbsp 1))
+          ((char=? c #\!) (do-excl))
+          ((char=? c #\?) (do-quest))
+          ((or (char=? c #\<)
+               (char=? c #\>)
+               (char=? c #\")) (emit-html-char c))
+          ((char=? c #\&)
+           (cond ((not (null? *tabular-stack*))
+                  (do-end-para)
+                  (case (car *tabular-stack*)
+                    ((:pmatrix :eqalign :displaylines :mathbox)
+                     (emit "&nbsp;</td><td align=center>&nbsp;"))
+                    ((:eqalignno)
+                     (set! *equation-position* (+ *equation-position* 1))
+                     (emit "</td><td")
+                     (when (= *equation-position* 2)
+                       (emit " width=30% align=right"))
+                     (emit ">"))
+                    ((:eqnarray :eqnarray*)
+                     (set! *equation-position* (+ *equation-position* 1))
+                     (emit "</td><td")
+                     (when (= *equation-position* 1)
+                       (emit " align=center width=2%"))
+                     (emit ">"))
+                    ((:tabular) (do-tabular-colsep))
+                    ((:ruled-table) (do-ruledtable-colsep))))
+                 (else (emit-html-char c))))
+          ((char=? c #\|) (if (and (not (null? *tabular-stack*))
+                                   (eqv? (car *tabular-stack*) ':ruled-table))
+                              (do-ruledtable-colsep)
+                              (emit c)))
+          ((char=? c #\newline) (do-newline))
+          ((char=? c #\space) (do-space))
+          ((char=? c *tab*) (do-tab))
+          (else
+            (cond (*math-mode?*
+                    (case c
+                      ((#\^) (do-sup))
+                      ((#\_) (do-sub))
+                      ((#\+ #\=)
+                       (unless *math-script-mode?* (emit #\space))
+                       (emit c)
+                       (unless *math-script-mode?* (emit #\space)))
+                      (else (if (and (char-alphabetic? c)
+                                     (not *math-roman-mode?*))
+                                (begin (emit "<em>")
+                                  (emit c)
+                                  (emit "</em>"))
+                                (emit c)))))
+                 ((and *in-small-caps?* (char-lower-case? c))
+                  (emit "<small>")
+                  (emit (char-upcase c))
+                  (emit "</small>")
+                  )
+                  (else (emit c)))))))
+
+(define do-tex-ctl-seq-completely
+  (lambda (x)
+    (cond ((resolve-defs x) => tex2page-string)
+          ((do-tex-prim (find-corresp-prim x))
+           => (lambda (y)
+             (when (eqv? y ':encountered-undefined-command)
+                 (emit x)))))))
+
+(define inside-false-world?
+  (lambda ()
+    (memv #f *tex-if-stack*)))
+
+(define do-tex-ctl-seq
+  (lambda (z)
+    ;process ctl-seq z.  Return :encountered-bye,
+    ;:encountered-endinput if z = \bye, \endinput
+    ;respectively
+    (trace-if (> (find-count "\\tracingcommands") 0) z)
+    (cond ((resolve-defs z)
+           => (lambda (s)
+             (trace-if (> (find-count "\\tracingmacros") 0)
+                       "    --> " s)
+             (toss-back-char *invisible-space*)
+             (toss-back-string s)))
+          ((and (inside-false-world?)
+                (not (if-aware-ctl-seq? z)))
+           #f)
+          ((string=? z "\\enddocument") (probably-latex)
+           ':encountered-bye)
+          ((or (string=? z "\\bye")
+               (string=? z "\\TIIPbye")) ':encountered-bye)
+          ((string=? z "\\endinput")
+           (let ((next-token (get-token)))
+             (when (and (not (eof-object? next-token)) (string=? next-token "\\fi"))
+               (do-fi)))
+           ':encountered-endinput)
+          ((find-count z) (do-count= z #f))
+          ((find-toks z) (do-toks= z #f))
+          ((find-dimen z) (do-dimen= z #f))
+          (else (do-tex-prim z)))))
+
+(define generate-html
+  (lambda ()
+    (fluid-let ((*outer?* #t))
+      (let loop ()
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c) 
+                 #t
+                 ;(values)
+                 )
+                ((resolve-chardefs c)
+                 => (lambda (s)
+                      (toss-back-char *invisible-space*)
+                      (toss-back-string s)
+                      (loop)))
+                ((char=? c *esc-char*)
+                 (let ((r (do-tex-ctl-seq (get-ctl-seq))))
+                   (case r
+                     ((:encountered-endinput) #t)
+                     ((:encountered-bye) ':encountered-bye)
+                     (else (loop)))))
+                (else (get-actual-char)
+                      (do-tex-char c)
+                      (loop))))))))
+
+(define do-iffileexists
+  (lambda ()
+    (let* ((file (actual-tex-filename (get-filename-possibly-braced) #f))
+           (thene (ungroup (get-group)))
+           (elsee (ungroup (get-group))))
+      (tex2page-string
+       (if file thene elsee)))))
+
+(define check-input-file-timestamp?
+  (lambda (f)
+    (cond ((let ((e (file-extension f)))
+                 (and e (member/string-ci=?
+                         e '(".t2p" ".bbl" ".ind"))))
+          ;don't use timestamp of .t2p .ind .bbl files
+           #f)
+          (*inputting-boilerplate?* #f)
+          (*ignore-timestamp?* #f)
+          ((> *html-only* 0) #f)
+          ((and (>= (string-length f) 3)
+                (char=? (string-ref f 0) #\.)
+                (char=? (string-ref f 1) #\/)) #f)
+          ((member f *verb-written-files*) #f)
+          (else #t))))
+
+(define do-inputiffileexists
+  (lambda ()
+    (let* ((f (actual-tex-filename (get-filename-possibly-braced) #f))
+           (then-txt (ungroup (get-group)))
+           (else-txt (ungroup (get-group))))
+      (cond (f (tex2page-string then-txt)
+               (tex2page-file f))
+            (else (tex2page-string else-txt))))))
+
+(define tex2page-file
+  (lambda (f)
+    (write-log #\()
+    (write-log f)
+    (write-log ':separation-space)
+    (set! f (tex2page-massage-file f))
+    (trace-if (> (find-count "\\tracingcommands") 0)
+              "Inputting file " f)
+    (let ((r (call-with-input-file/buffered
+               f generate-html)))
+      (write-log #\))
+      (write-log ':separation-space)
+      r)))
+
+(define tex2page-file-if-exists
+  (lambda (f)
+    (when (file-exists? f)
+      (tex2page-file f))))
+
+(define do-input
+  (lambda ()
+    (ignorespaces)
+    (let ((f (get-filename-possibly-braced)))
+      (let ((boilerplate-index *inputting-boilerplate?*))
+        ;this is ugly code that nobody really needs, so
+        ;why am I so invested in keeping it?
+        (when (eqv? *inputting-boilerplate?* 0)
+          (set! *inputting-boilerplate?* #f))
+        (fluid-let ((*inputting-boilerplate?*
+                     (and boilerplate-index (+ boilerplate-index 1))))
+          (cond ((or (latex-style-file? f)
+                     (member/string-ci=?
+                      f '("btxmac" "btxmac.tex"
+                                   "eplain" "eplain.tex"
+                                   "epsf" "epsf.tex"
+                                   "eval4tex" "eval4tex.tex"
+                                   "supp-pdf" "supp-pdf.tex"
+                                   "tex2page" "tex2page.tex"
+                                   )))
+                 ;don't process .sty files,
+                 ;and macro files like btxmac.tex
+                 #f)
+                ((member/string-ci=? f '("miniltx" "miniltx.tex"))
+                 ;like above, but miniltx also makes @ a "letter"
+                 (set-catcode #\@ 11)
+                 #f)
+                ((ormap (lambda (z) (string=? f z))
+                        '("texinfo" "texinfo.tex"))
+                 (let ((txi2p (actual-tex-filename "texi2p" #f)))
+                   (if txi2p
+                       (begin (tex2page-file txi2p)
+                              (tex2page-file *current-source-file*)
+                              ':encountered-endinput)
+                       (terror 'do-input "File texi2p.tex not found"))))
+                ((actual-tex-filename
+                  f (check-input-file-timestamp? f))
+                 => tex2page-file)
+                (else (write-log #\() ;)
+                      (write-log f)
+                      (write-log ':separation-space)
+                      (write-log "not found)")
+                      (write-log ':separation-space))))))))
+
+(define do-includeonly
+  (lambda ()
+    (ignorespaces)
+    (when (eq? *includeonly-list* #t)
+      (set! *includeonly-list* '()))
+    (let ((c (get-actual-char)))
+      (when (or (eof-object? c) (not (char=? c #\{)))
+        (terror 'do-includeonly)))
+    (fluid-let ((*filename-delims* (cons #\} (cons #\, *filename-delims*))))
+      (let loop ()
+        (ignorespaces)
+        (let ((c (snoop-actual-char)))
+          (cond ((eof-object? c) (terror 'do-includeonly))
+                ((and *comment-char* (char=? c *comment-char*))
+                 (eat-till-eol) (ignorespaces) (loop))
+                ((char=? c #\,) (get-actual-char) (loop))
+                ((char=? c #\}) (get-actual-char))
+                ((ormap (lambda (d) (char=? c d)) *filename-delims*)
+                 (terror 'do-includeonly))
+                (else
+                  (set! *includeonly-list*
+                    (cons (get-plain-filename) *includeonly-list*))
+                  (loop))))))))
+
+(define do-include
+  (lambda ()
+    (let ((f (ungroup (get-group))))
+      (when (or (eq? *includeonly-list* #t)
+                (ormap (lambda (i) (string=? f i)) *includeonly-list*))
+        (fluid-let ((*subjobname* (file-stem-name f))
+                    (*img-file-count* 0)
+                    (*imgdef-file-count* 0))
+          (tex2page-file
+           (actual-tex-filename f (check-input-file-timestamp? f))))))))
+
+(define do-eval-string
+  (lambda (s)
+    (call-with-input-string s
+      (lambda (i)
+        (let loop ()
+          (let ((x (read i)))
+            (unless (eof-object? x)
+              (eval1 x) (loop))))))))
+
+(define with-output-to-port
+  (lambda (o th)
+    (parameterize ((current-output-port o))
+      (th))))
+
+(define do-eval
+  (lambda (fmts)
+    (let ((s (if *outer?*
+               ;Careful: This could break existing docs that rely on
+               ;this!
+               (ungroup
+               (fluid-let ((*esc-char* *esc-char-verb*)
+                           (*expand-escape?* #t))
+                 (get-group)))
+              (tex-write-output-string
+                (ungroup (get-group))))))
+      (unless (inside-false-world?)
+        (when (> *html-only* 0) (set! fmts ':html))
+        (case fmts
+          ((:html)
+           (let ((o (open-output-string)))
+             (with-output-to-port o
+               (lambda ()
+                 (do-eval-string s)
+                 ;(display "\\relax")
+                 ))
+             (tex2page-string (get-output-string o))))
+          ((:quiet) (do-eval-string s))
+          (else
+           (set! *eval-file-count* (+ *eval-file-count* 1))
+           (let ((eval4tex-file
+                  (string-append *jobname* *eval-file-suffix*
+                                 (number->string *eval-file-count*)
+                                 ".tex")))
+             (ensure-file-deleted eval4tex-file)
+             (with-output-to-file eval4tex-file
+               (lambda ()
+                 (do-eval-string s)
+                 ;following eats whitespace
+                 ;that creeps after
+                 ;\input file
+                 (display "\\relax")))
+             (fluid-let ((*ignore-timestamp?* #t))
+               (tex2page-file eval4tex-file))
+             ;(ensure-file-deleted eval4tex-file)
+             )))))))
+
+(define eval-for-tex-only
+  (lambda ()
+    (set! *eval-for-tex-only?* #t)
+    (do-end-page)
+    (ensure-file-deleted *html-page*)
+    (set! *main-tex-file* #f)
+    (set! *html-page* ".eval4texignore")
+    (ensure-file-deleted *html-page*)
+    (set! *html* (open-output-file *html-page*))))
+
+(define expand-ctl-seq-into-string
+  (lambda (cs)
+    (let ((tmp-port (open-output-string)))
+      (fluid-let ((*html* tmp-port))
+        (do-tex-ctl-seq cs)
+       ;(do-tex-ctl-seq-completely cs)
+        )
+      (get-output-string tmp-port))))
+
+(define call-with-html-output-going-to
+  ;this allows users of modulized versions of tex2page to
+  ;fluidly set the module-global *html* from .t2p file
+  (lambda (p th)
+    (fluid-let ((*html* p))
+      (th))))
+
+;aux file
+
+(define call-external-programs-if-necessary
+  (lambda ()
+    (let ((run-bibtex?
+           (cond ((not *using-bibliography?*) #f)
+                 ((not (file-exists?
+                        (string-append *aux-dir/* *jobname*
+                                       *bib-aux-file-suffix* ".aux")))
+                  #f)
+                 ((memv 'bibliography *missing-pieces*) #t)
+                 (*source-changed-since-last-run?*
+                  (flag-missing-piece ':fresh-bibliography) #t)
+                 (else #f)))
+          (run-makeindex?
+           (cond ((not *using-index?*) #f)
+                 ((not (file-exists?
+                        (string-append *aux-dir/* *jobname*
+                                       *index-file-suffix* ".idx")))
+                  #f)
+                 ((memv ':index *missing-pieces*) #t)
+                 (*source-changed-since-last-run?*
+                  (flag-missing-piece ':fresh-index) #t)
+                 (else #f))))
+
+      ;bibtex
+      (when run-bibtex?
+        (write-log ':separation-newline)
+        (write-log "Running: bibtex ")
+        (write-log *aux-dir/*)
+        (write-log *jobname*)
+        (write-log *bib-aux-file-suffix*)
+        (write-log #\space)
+        (system
+          (string-append "bibtex " *aux-dir/* *jobname*
+                         *bib-aux-file-suffix*))
+        (unless (file-exists? (string-append *jobname*
+                                             *bib-aux-file-suffix* ".bbl"))
+          (write-log " ... failed; try manually"))
+        (write-log ':separation-newline))
+      ;makeindex
+      (when run-makeindex?
+        (write-log ':separation-newline)
+        (write-log "Running: makeindex ")
+        (write-log *aux-dir/*)
+        (write-log *jobname*)
+        (write-log *index-file-suffix*)
+        (write-log #\space)
+        (system
+          (string-append "makeindex " *aux-dir/* *jobname*
+                         *index-file-suffix*))
+        (unless (file-exists?
+                  (string-append *aux-dir/* *jobname*
+                                 *index-file-suffix* ".ind"))
+          (write-log " ... failed; try manually"))
+        (write-log ':separation-newline))
+      ;metapost
+      (for-each
+        (lambda (f)
+          (when (file-exists? f)
+            (write-log ':separation-newline)
+            (write-log "Running: metapost ")
+            (write-log f)
+            (write-log ':separation-newline)
+            (system
+              (string-append *metapost* " " f))))
+        *mp-files*)
+      ;eps files
+      (for-each
+        (lambda (eps-file+img-file-stem)
+          (retry-lazy-image
+            (car eps-file+img-file-stem)
+            (cdr eps-file+img-file-stem)))
+        *missing-eps-files*)
+      ;
+      )))
+
+(define first-file-that-exists
+  (lambda ff
+    (ormap (lambda (f)
+             (and f (file-exists? f) f))
+           ff)))
+
+(define file-in-home
+  (lambda (f)
+    (let ((home (getenv "HOME")))
+      (and home
+           (let ((slash-already?
+                  (let ((n (string-length home)))
+                    (and (>= n 0)
+                         (let ((c (string-ref home (- n 1))))
+                           (or (char=? c #\/)
+                               (char=? c #\\ )))))))
+             (string-append home
+                            (if slash-already? "" "/")
+                            f))))))
+
+(define make-target-dir
+  (lambda ()
+    (let ((hdir-file
+           (first-file-that-exists
+            (string-append *jobname* ".hdir")
+            ".tex2page.hdir"
+            (file-in-home ".tex2page.hdir"))))
+      (when hdir-file
+        (let ((hdir (call-with-input-file/buffered hdir-file
+                      (lambda ()
+                          (get-filename-possibly-braced)))))
+          (unless (= (string-length hdir) 0)
+            (case *operating-system*
+              ((:cygwin :unix)
+               (system (string-append "mkdir -p " hdir))
+               (system (string-append "touch " hdir "/probe")))
+              ((:windows)
+               (system (string-append "mkdir " hdir))
+               (system (string-append "echo probe > " hdir "\\probe"))))
+            (let ((probe (string-append hdir "/probe")))
+              (when (file-exists? probe)
+                (ensure-file-deleted probe)
+                (set! *aux-dir* hdir)
+                (set! *aux-dir/* (string-append *aux-dir* "/"))))))))))
+
+(define move-aux-files-to-aux-dir
+  (lambda (f)
+    (when (and *aux-dir*
+               (or (file-exists? (string-append f ".tex"))
+                   (file-exists? (string-append f ".scm"))
+                   (file-exists? (string-append f (find-img-file-extn)))))
+      (case *operating-system*
+        ((:cygwin :unix) (system (string-append "mv " f ".* " *aux-dir*)))
+        ((:windows) (system (string-append "copy " f ".* " *aux-dir*))
+         (when (or (file-exists? (string-append f ".tex"))
+                   (file-exists? (string-append f ".scm")))
+           (system (string-append "del " f ".*"))))))))
+
+(define start-css-file
+  (lambda ()
+    (let ((css-file (string-append
+                      *aux-dir/* *jobname* *css-file-suffix*)))
+      (ensure-file-deleted css-file)
+      (set! *css-port* (open-output-file css-file))
+      (display "
+               body {
+               color: black;
+               /*   background-color: #e5e5e5;*/
+               background-color: #ffffff;
+               /*background-color: beige;*/
+               margin-top: 2em;
+               margin-bottom: 2em;
+               /* margin-left: 8%;
+               margin-right: 8%; */
+               }
+
+               @media screen {
+               body {
+               margin-left: 8%;
+               margin-right: 8%;
+               }
+               }
+
+               @media print {
+               body {
+               text-align: justify;
+               }
+               }
+
+               @media print {
+               a:link, a:visited {
+               text-decoration: none;
+               color: black;
+               }
+               }
+
+               /* @media print {
+               p {
+               text-indent: 2em;
+               margin-top: 1ex;
+               margin-bottom: 0;
+               }
+
+               } */
+
+               h1,h2,h3,h4,h5,h6 {
+               margin-top: .8em;
+               margin-bottom: .2em;  /* ?? */
+               }
+
+               .title {
+               font-size: 200%;
+               font-weight: normal;
+               margin-top: 2.8em;
+               text-align: center;
+               }
+
+               .partheading {
+               font-size: 100%;
+               }
+
+               .chapterheading {
+               font-size: 100%;
+               }
+
+               .beginchapter,.beginsection {
+               font-family: sans-serif;
+               }
+
+               .beginchapter {
+               margin-top: 1.8em;
+               font-size: 150%;
+               }
+
+               .beginsection {
+               margin-top: 1.8em;
+               font-size: 110%;
+               }
+
+               .tiny {
+               font-size: 40%;
+               }
+
+               .scriptsize {
+               font-size: 60%;
+               }
+
+               .footnotesize {
+               font-size: 75%;
+               }
+
+               .small {
+               font-size: 90%;
+               }
+
+               .normalsize {
+               font-size: 100%;
+               }
+
+               .large {
+               font-size: 120%;
+               }
+
+               .largecap {
+               font-size: 150%;
+               }
+
+               .largeup {
+               font-size: 200%;
+               }
+
+               .huge {
+               font-size: 300%;
+               }
+
+               .hugecap {
+               font-size: 350%;
+               }
+
+               p.noindent {
+               text-indent: 0;
+               margin-top: 0;
+               }
+
+               p.nopadding {
+               margin-top: 0;
+               }
+
+               pre {
+               overflow: auto;
+               margin-left: 2em;
+               background-color: #f5f5f5;
+               }
+
+               blockquote {
+               background-color: #f0e0e0;
+               margin-top: 2pt;
+               margin-bottom: 2pt;
+               margin-left: 2em;
+               }
+
+               .smallskip {
+               margin-top: 2pt;
+               margin-bottom: 2pt;
+               min-height: 4pt;
+               }
+
+               .medskip {
+               margin-top: 3pt;
+               margin-bottom: 3pt;
+               min-height: 7pt;
+               /*margin-top: 1.6em;
+               margin-bottom: 2.4em;
+               margin-top: 1em;
+               margin-bottom: 1.5em; */
+               /* top and bottom have to be different so successive \\...skips cause more spacing? */
+               }
+
+               .bigskip {
+               margin-top: 4pt;
+               margin-bottom: 4pt;
+               min-height: 13pt;
+               /*margin-top: 2.8em;
+               margin-bottom: 3.4em;
+               margin-top: 2.4em;
+               margin-bottom: 1.6em; */
+               }
+
+               ol {
+               list-style-type: decimal;
+               }
+
+               ol ol {
+               list-style-type: lower-alpha;
+               }
+
+               ol ol ol {
+               list-style-type: lower-roman;
+               }
+
+               ol ol ol ol {
+               list-style-type: upper-alpha;
+               }
+
+               tt i {
+               font-family: serif;
+               }
+
+               .verbatim em {
+               font-family: serif;
+               }
+
+               /*
+               .verbatim {
+               color: #4d0000;
+               }
+               */
+
+               .scheme em {
+               color: black;
+               font-family: serif;
+               }
+
+               .scheme             {color: #993333} /* background punctuation */
+               .scheme  .selfeval  {color: #006600}
+               .scheme  .keyword   {color: #660000; font-weight: bold}
+               .scheme  .builtin   {color: #660000}
+               .scheme  .global    {color: #660066}
+               .scheme  .variable  {color: #000066}
+               .scheme  .comment   {color: #006666; font-style: oblique}
+
+               .schemeresponse {
+               color: #006600;
+               }
+
+               a:hover {
+               text-decoration: none;
+               background-color: yellow;
+               }
+
+               .navigation {
+               color: #993300;
+               text-align: right;
+               font-size: medium;
+               font-style: italic;
+               }
+
+               @media print {
+               .navigation {
+               display: none;
+               }
+               }
+
+               .disable {
+               /* color: #e5e5e5; */
+               color: gray;
+               }
+
+               .smallcaps {
+               font-size: 75%;
+               }
+
+               .smallprint {
+               color: gray;
+               font-size: 75%;
+               text-align: right;
+               }
+
+               /*
+               .smallprint hr {
+               text-align: left;
+               width: 40%;
+               }
+               */
+
+               .footnoterule {
+               text-align: left;
+               width: 40%;
+               }
+
+               @media print {
+               .footnoterule {
+               margin-top: 2em;
+               }
+               }
+
+               .colophon {
+               color: gray;
+               font-size: 80%;
+               font-style: italic;
+               text-align: right;
+               margin-top: 1em;
+               }
+
+               @media print {
+               .colophon .advertisement {
+               display: none;
+               }
+               }
+
+               .colophon a {
+               color: gray;
+               text-decoration: none;
+               }
+               "
+               *css-port*)
+      )))
+
+(define load-aux-file
+  (lambda ()
+    (initialize-globals)
+    (set-start-time)
+    (let ((label-file (string-append *aux-dir/* *jobname*
+                                     *label-file-suffix* ".scm")))
+      (when (file-exists? label-file)
+        (load-tex2page-data-file label-file)
+        (delete-file label-file)))
+    (unless (string=? *jobname* "texput")
+      (let ((jobname-aux
+             (string-append "texput" *aux-file-suffix* ".scm")))
+        (when (file-exists? jobname-aux)
+          (delete-file jobname-aux))))
+    (let ((aux-file (string-append *aux-dir/* *jobname*
+                                   *aux-file-suffix* ".scm")))
+      (when (file-exists? aux-file)
+        (load-tex2page-data-file aux-file)
+        (delete-file aux-file)))
+    (start-css-file)
+    (unless (null? *toc-list*)
+      (set! *toc-list* (nreverse *toc-list*)))
+    (unless (null? *stylesheets*)
+      (set! *stylesheets* (nreverse *stylesheets*)))
+    (unless (null? *html-head*)
+      (set! *html-head* (nreverse *html-head*)))))
+
+(define update-last-modification-time
+  (lambda (f)
+    (let ((s (file-or-directory-modify-seconds f)))
+      (when (and s (or (not *last-modification-time*)
+                       (> s *last-modification-time*)))
+        (set! *source-changed-since-last-run?* #t)
+        (set! *last-modification-time* s)
+        ;(write-aux `(!last-modification-time ,s))
+        (when (and (tex2page-flag-boolean "\\TZPcolophontimestamp")
+                   (not (tex2page-flag-boolean "\\TZPcolophonlastpage"))
+                   (> *html-page-count* 1))
+          ;ie, mod-time was already printed
+          (flag-missing-piece ':last-modification-time))))))
+
+(define probably-latex
+  (lambda ()
+    (when (null? *tex-env*)
+      (set! *latex-probability* (+ *latex-probability* 1))
+      (when (>= *latex-probability* 2)
+          (definitely-latex)))))
+
+(define definitely-latex
+  (let ((already-noted? #f))
+    (lambda ()
+      (unless already-noted?
+        (set! already-noted? #t)
+        (!definitely-latex)
+        (write-aux `(!definitely-latex))))))
+
+;the following are used to make entries in the aux file.
+;Their names all start with "!"
+
+(define !tex-like-layout
+  (lambda ()
+    (set! *tex-like-layout?* #t)))
+
+(define !head-line
+  (lambda (e)
+    (tex-def-toks "\\headline" e #t)))
+
+(define !foot-line
+  (lambda (e)
+    (tex-def-toks "\\footline" e #t)))
+
+(define !toc-page
+  (lambda (p)
+    (set! *toc-page* p)))
+
+(define !index-page
+  (lambda (p)
+    (set! *index-page* p)))
+
+(define !toc-entry
+  (lambda (level number page label header)
+    (set! *toc-list*
+          (cons
+           (make-tocentry 'level level
+                          'number number
+                          'page page
+                          'label label
+                          'header header)
+           *toc-list*))))
+
+(define !label
+  (lambda (label html-page name value)
+    (table-put! *label-table* label
+                (make-label 'src *label-source*
+                            'page html-page
+                            'name name
+                            'value value))))
+
+(define !index
+  (lambda (index-number html-page-number)
+    (table-put! *index-table* index-number
+                html-page-number)))
+
+(define !last-modification-time
+  (let ((seconds-from-1900-to-1970
+         ;CL's (encode-universal-time 0 0 0 1 1 1970 0)
+         2208988800))
+    (lambda (s . epoch)
+      (set! *last-modification-time*
+            (case (if (pair? epoch) (car epoch) 1970)
+              ((1900) (- s seconds-from-1900-to-1970))
+              ((1970) s))))))
+
+(define !last-page-number
+  (lambda (n)
+    (set! *last-page-number* n)))
+
+(define !using-chapters
+  (lambda ()
+    (set! *using-chapters?* #t)))
+
+(define !definitely-latex
+  (lambda ()
+    (set! *tex-format* ':latex)
+    (when (< (get-gcount "\\secnumdepth") -1)
+      (set-gcount! "\\secnumdepth" 3))))
+
+(define !using-external-program ;obsolete
+  (lambda (x)
+    ;(set! *external-programs* (cons x *external-programs*))
+    #f
+    ))
+
+(define !external-labels ;obsolete
+  (lambda (f)
+    #f))
+
+(define !doctype
+  (lambda (d)
+    (set! *doctype* d)))
+
+(define !colophon
+  (lambda (x)
+    (case x
+      ((last-page)
+       (tex-def-0arg "\\TZPcolophonlastpage" "1"))
+      ((no-timestamp)
+       (tex-def-0arg "\\TZPcolophontimestamp" "0"))
+      ((dont-credit-tex2page ingrate)
+       (tex-def-0arg "\\TZPcolophoncredit" "0"))
+      ((dont-link-to-tex2page-website)
+       (tex-def-0arg "\\TZPcolophonweblink" "0")))))
+
+;;
+
+(define fully-qualified-url?
+  (lambda (u)
+    (or (substring? "//" u) ;URL
+        (char=? (string-ref u 0) #\/) ;website-dependent pathname
+        )))
+
+(define fully-qualified-pathname?
+  (lambda (f)
+    (let ((n (string-length f)))
+      (if (= n 0) #t
+          (let ((c0 (string-ref f 0)))
+            (cond ((char=? c0 #\/) #t)
+                  ((= n 1) #f)
+                  ((and (char-alphabetic? c0)
+                        (char=? (string-ref f 1) #\:))
+                   #t)
+                  (else #f)))))))
+
+(define ensure-url-reachable
+  (lambda (f)
+    (if (and *aux-dir* (not (fully-qualified-url? f))
+                     ;but we don't want to try too hard here, so
+             (not (substring? "/" f)))
+        (let ((real-f (string-append *aux-dir/* f)))
+          (when (and (file-exists? f)
+                     (not (file-exists? real-f)))
+            (case *operating-system*
+              ((:cygwin :unix)
+               (system (string-append "cp -p " f " " real-f)))
+              ((:windows)
+               (system (string-append "copy/b " f
+                         " " *aux-dir*)))))
+          real-f)
+        f)))
+
+(define !stylesheet
+  (lambda (css)
+    (if (file-exists? (ensure-url-reachable css))
+        (set! *stylesheets* (cons css *stylesheets*))
+        (begin
+          (write-log "! Can't find stylesheet ")
+          (write-log css)
+          (write-log ':separation-newline)))))
+
+(define !html-head
+  (lambda (s)
+    (set! *html-head* (cons s *html-head*))))
+
+(define !default-title
+  (lambda (title)
+    (unless *title* ;already set
+      (set! *title* title))))
+
+(define !preferred-title
+  (lambda (title)
+    (set! *title* title)))
+
+(define !infructuous-calls-to-tex2page
+  (lambda (n)
+    (set! *infructuous-calls-to-tex2page* n)))
+
+(define load-tex2page-data-file
+  (lambda (f)
+    (when (file-exists? f)
+      (fluid-let ((*current-source-file* f)
+                  (*input-line-no* 0))
+        (call-with-input-file f
+          (lambda (i)
+            (let loop ()
+              (let ((e (read i)))
+                (unless (eof-object? e)
+                  (set! *input-line-no* (+ *input-line-no* 1))
+                  (let ((x (car e)))
+                    (apply
+                      (case x
+                        ((!colophon) !colophon)
+                        ((!default-title) !default-title)
+                        ((!definitely-latex) !definitely-latex)
+                        ((!doctype) !doctype)
+                        ((!external-labels) !external-labels)
+                        ((!foot-line) !foot-line)
+                        ((!head-line) !head-line)
+                        ((!html-head) !html-head)
+                        ((!index) !index)
+                        ((!index-page) !index-page)
+                        ((!infructuous-calls-to-tex2page) !infructuous-calls-to-tex2page)
+                        ((!label) !label)
+                        ((!last-modification-time) !last-modification-time)
+                        ((!last-page-number) !last-page-number)
+                        ((!preferred-title) !preferred-title)
+                        ((!stylesheet) !stylesheet)
+                        ((!tex-like-layout) !tex-like-layout)
+                        ((!toc-entry) !toc-entry)
+                        ((!toc-page) !toc-page)
+                        ((!using-chapters) !using-chapters)
+                        ((!using-external-program) !using-external-program)
+                        (else (terror 'load-tex2page-data-file
+                                      "Fatal aux file error; I'm stymied."
+                                      )))
+                      (cdr e))
+                    (loop)))))))))))
+
+;
+
+(define tex2page-massage-file
+  (lambda (f) f))
+
+(define tex2page-help
+  (lambda (not-a-file)
+    (write-aux
+      `(!infructuous-calls-to-tex2page
+         ,(+ *infructuous-calls-to-tex2page* 1)))
+    ;
+    (unless (or (string=? not-a-file "--help")
+                (string=? not-a-file "--missing-arg")
+                (string=? not-a-file "--version"))
+      (write-log "! I can't find file `")
+      (write-log not-a-file)
+      (write-log "'.")
+      (write-log ':separation-newline))
+    ;
+    (cond
+      ((string=? not-a-file "--version")
+       (write-log "Copyright (c) 1997-")
+       (write-log (substring *tex2page-version* 0 4))
+       (write-log ", Dorai Sitaram.
+
+Permission to distribute and use this work for any
+purpose is hereby granted provided this copyright
+notice is included in the copy.  This work is provided
+as is, with no warranty of any kind.
+
+For information on how to use TeX2page, please see")
+                  (write-log #\newline)
+                  (write-log *tex2page-website*)
+                  (write-log #\.)
+                  (write-log #\newline)
+                  (write-log #\newline))
+      ((string=? not-a-file "--help")
+       (write-log "
+The command tex2page converts a (La)TeX document into
+Web pages.  Call tex2page with the relative or full
+pathname of the main TeX file.  The file extension
+is optional if it is .tex.
+
+The relative pathnames of the main and any subsidiary
+TeX files are resolved against the current working
+directory and the list of directories in the
+environment variable TEX2PAGEINPUTS, or if that does not
+exist, via kpsewhich(1).
+
+The output Web files are generated in the current
+directory by default.  An alternate location can be
+specified in  <jobname>.hdir, tex2page.hdir, or
+~/tex2page.hdir, where <jobname> is the basename of the
+main TeX file.
+
+For more information on how to use tex2page, please see"
+)
+       (write-log #\newline)
+       (write-log *tex2page-website*)
+       (write-log #\.)
+       (write-log #\newline)
+       (write-log #\newline))
+      (else
+        (when (string=? not-a-file "--missing-arg")
+          (write-log "! Missing command-line argument.")
+          (write-log ':separation-newline))
+        ;(write-log "No pages of output.")
+        ;(write-log ':separation-newline)
+        (when (> *infructuous-calls-to-tex2page* 0)
+          (write-log "You have called TeX2page")
+          (write-log #\space)
+          (write-log (+ *infructuous-calls-to-tex2page* 1))
+          (write-log #\space)
+          (write-log "times without a valid input document.")
+          (write-log ':separation-newline))
+        (cond ((>= *infructuous-calls-to-tex2page* 4)
+               (write-log "I can't go on meeting you like this.")
+               (write-log ':separation-newline)
+               (write-log "Good bye!")
+               (write-log ':separation-newline))
+              (else
+                (write-log "Do you need help using TeX2page?
+Try the commands
+  tex2page --help
+  tex2page --version"
+  )
+                 (write-log ':separation-newline)))))
+      (close-all-open-ports)
+      ;(close-output-port *aux-port*)
+      ;(close-output-port *log-port*)
+      ))
+
+(define non-fatal-error
+  (lambda ss
+    (emit-link-start (string-append *jobname* ".hlog"))
+    (emit "<span style=\"color: red\">&#x2388;&nbsp;")
+    (for-each emit-html-string ss)
+    ;(for-each tex2page-string ss)
+    (emit-link-stop)
+    (emit "</span>")))
+
+(define do-math-ctl-seq
+  (lambda (s)
+    (cond ((find-math-def s)
+           => (lambda (x) ((tdef.thunk x))))
+          (else
+            (unless *math-needs-image?* (set! *math-needs-image?* #t))
+            (emit (substring s 1 (string-length s)))
+            ;(emit " ")
+            ))))
+
+(define tex-def-math-prim
+  (lambda (cs thunk)
+    (tex-def cs '() #f #f thunk cs #f *math-primitive-texframe*)))
+
+(define make-reusable-math-image-as-needed
+  (lambda (cs . expn)
+    (let ((expn (if (null? expn) cs (car expn))))
+      (tex-def-math-prim cs
+                         (lambda ()
+                           (tex2page-string
+                             (string-append "\\global\\imgdef" cs
+                                            "{$" expn "$}"))
+                           (tex2page-string cs))))))
+
+;TeXbook, appendix F, p 434
+
+;1. lowercase Greek
+
+(tex-def-math-prim "\\alpha" (lambda () (emit "&alpha;")))
+(tex-def-math-prim "\\beta" (lambda () (emit "&beta;")))
+(tex-def-math-prim "\\gamma" (lambda () (emit "&gamma;")))
+(tex-def-math-prim "\\delta" (lambda () (emit "&delta;")))
+(tex-def-math-prim "\\epsilon" (lambda () (emit "&epsilon;")))
+(tex-def-math-prim "\\varepsilon" (lambda () (emit "&epsilon;")))
+(tex-def-math-prim "\\zeta" (lambda () (emit "&zeta;")))
+(tex-def-math-prim "\\eta" (lambda () (emit "&eta;")))
+(tex-def-math-prim "\\theta" (lambda () (emit "&theta;")))
+(tex-def-math-prim "\\vartheta" (lambda () (emit "&thetasym;")))
+(tex-def-math-prim "\\iota" (lambda () (emit "&iota;")))
+(tex-def-math-prim "\\kappa" (lambda () (emit "&kappa;")))
+(tex-def-math-prim "\\lambda" (lambda () (emit "&lambda;")))
+(tex-def-math-prim "\\mu" (lambda () (emit "&mu;")))
+(tex-def-math-prim "\\nu" (lambda () (emit "&nu;")))
+(tex-def-math-prim "\\xi" (lambda () (emit "&xi;")))
+(tex-def-math-prim "\\omicron" (lambda () (emit "&omicron;")))
+(tex-def-math-prim "\\pi" (lambda () (emit "&pi;")))
+(tex-def-math-prim "\\varpi" (lambda () (emit "&piv;")))
+(tex-def-math-prim "\\rho" (lambda () (emit "&rho;")))
+(tex-def-math-prim "\\varrho" (lambda () (emit "&rho;")))
+(tex-def-math-prim "\\sigma" (lambda () (emit "&sigma;")))
+(tex-def-math-prim "\\varsigma" (lambda () (emit "&sigmaf;")))
+(tex-def-math-prim "\\tau" (lambda () (emit "&tau;")))
+(tex-def-math-prim "\\upsilon" (lambda () (emit "&upsilon;")))
+(tex-def-math-prim "\\phi" (lambda () (emit "&phi;")))
+(tex-def-math-prim "\\varphi" (lambda () (emit "&#x3d5;")))
+(tex-def-math-prim "\\chi" (lambda () (emit "&chi;")))
+(tex-def-math-prim "\\psi" (lambda () (emit "&psi;")))
+(tex-def-math-prim "\\omega" (lambda () (emit "&omega;")))
+
+;2. uppercase Greek
+
+(tex-def-math-prim "\\Gamma" (lambda () (emit "&Gamma;")))
+(tex-def-math-prim "\\Delta" (lambda () (emit "&Delta;")))
+(tex-def-math-prim "\\Theta" (lambda () (emit "&Theta;")))
+(tex-def-math-prim "\\Lambda" (lambda () (emit "&Lambda;")))
+(tex-def-math-prim "\\Xi" (lambda () (emit "&Xi;")))
+(tex-def-math-prim "\\Pi" (lambda () (emit "&Pi;")))
+(tex-def-math-prim "\\Sigma" (lambda () (emit "&Sigma;")))
+(tex-def-math-prim "\\Upsilon" (lambda () (emit "&Upsilon;")))
+(tex-def-math-prim "\\Phi" (lambda () (emit "&Phi;")))
+(tex-def-math-prim "\\Psi" (lambda () (emit "&Psi;")))
+(tex-def-math-prim "\\Omega" (lambda () (emit "&Omega;")))
+
+;4. misc symbols of type Ord
+
+(tex-def-math-prim "\\aleph" (lambda () (emit "&alefsym;")))
+(tex-def-math-prim "\\hbar" (lambda () (emit "&#x210f;")))
+(tex-def-math-prim "\\imath" (lambda () (emit "<i>&#x131;</i>"))) ; #x1d6a4 not supported yet
+(tex-def-math-prim "\\jmath" (lambda () (emit "<i>&#x237;</i>"))) ; #x1d6a5
+(tex-def-math-prim "\\ell" (lambda () (emit "&#x2113;")))
+(tex-def-math-prim "\\wp" (lambda () (emit "&weierp;")))
+(tex-def-math-prim "\\Re" (lambda () (emit "&real;")))
+(tex-def-math-prim "\\Im" (lambda () (emit "&image;")))
+(tex-def-math-prim "\\partial" (lambda () (emit "&part;")))
+(tex-def-math-prim "\\infty" (lambda () (emit "&infin;")))
+(tex-def-math-prim "\\prime" (lambda () (emit "&frasl;"))) ;sic, not &prime;
+(tex-def-math-prim "\\emptyset" (lambda () (emit "&empty;")))
+(tex-def-math-prim "\\nabla" (lambda () (emit "&nabla;")))
+(tex-def-math-prim "\\surd" (lambda () (emit "&radic;")))
+(tex-def-math-prim "\\top" (lambda () (emit "&#x22a4;")))
+(tex-def-math-prim "\\bot" (lambda () (emit "&#x22a5;")))
+(tex-def-math-prim "\\|" (lambda () (emit "&#x2225;")))
+(tex-def-math-prim "\\angle" (lambda () (emit "&ang;")))
+(tex-def-math-prim "\\triangle" (lambda () (emit "&Delta;")))
+(tex-def-math-prim "\\backslash" (lambda () (emit "\\")))
+(tex-def-math-prim "\\forall" (lambda () (emit "&forall;")))
+(tex-def-math-prim "\\exists" (lambda () (emit "&exist;")))
+(tex-def-math-prim "\\neg" (lambda () (emit "&not;")))
+(tex-def-math-prim "\\flat" (lambda () (emit "&#x266d;")))
+(tex-def-math-prim "\\natural" (lambda () (emit "&#x266e;")))
+(tex-def-math-prim "\\sharp" (lambda () (emit "&#x266f;")))
+(tex-def-math-prim "\\clubsuit" (lambda () (emit "&clubs;")))
+(tex-def-math-prim "\\diamondsuit" (lambda () (emit "&#x2662;")))
+(tex-def-math-prim "\\heartsuit" (lambda () (emit "&#x2661;")))
+(tex-def-math-prim "\\spadesuit" (lambda () (emit "&spades;")))
+
+;6. large operators
+
+(tex-def-math-prim "\\sum" (lambda () (emit "&sum;")))
+(tex-def-math-prim "\\prod" (lambda () (emit "&prod;")))
+(tex-def-math-prim "\\coprod" (lambda () (emit "&#x2210;")))
+(tex-def-math-prim "\\int" do-integral)
+(tex-def-math-prim "\\oint" (lambda () (emit "&#x222e;")))
+(tex-def-math-prim "\\bigcap" (lambda () (emit "&#x2229;")))
+(tex-def-math-prim "\\bigcup" (lambda () (emit "&#x222a;")))
+(tex-def-math-prim "\\bigsqcup" (lambda () (emit "&#x2294;")))
+(tex-def-math-prim "\\bigvee" (lambda () (emit "&#x2228;")))
+(tex-def-math-prim "\\bigwedge" (lambda () (emit "&#x2227;")))
+(tex-def-math-prim "\\bigodot" (lambda () (emit "&#x2299;")))
+(tex-def-math-prim "\\bigotimes" (lambda () (emit "&#x2297;")))
+(tex-def-math-prim "\\bigoplus" (lambda () (emit "&#x2295;")))
+(tex-def-math-prim "\\biguplus" (lambda () (emit "&#x228e;")))
+
+;7. binary operations
+
+(tex-def-math-prim "\\pm" (lambda () (emit "&plusmn;")))
+(tex-def-math-prim "\\mp" (lambda () (emit "&#x2213;")))
+(tex-def-math-prim "\\setminus" (lambda () (emit "\\")))
+(tex-def-math-prim "\\cdot" (lambda () (emit " &middot; ")))
+(tex-def-math-prim "\\times" (lambda () (emit "&times;")))
+(tex-def-math-prim "\\ast" (lambda () (emit "&lowast;")))
+(tex-def-math-prim "\\star" (lambda () (emit "&2605;")))
+(tex-def-math-prim "\\diamond" (lambda () (emit "&#x25c7;")))
+(tex-def-math-prim "\\circ" (lambda () (emit "&#x25cb;")))
+(tex-def-math-prim "\\bullet" (lambda () (emit "&bull;")))
+(tex-def-math-prim "\\div" (lambda () (emit "&divide;")))
+(tex-def-math-prim "\\cap" (lambda () (emit "&cap;")))
+(tex-def-math-prim "\\cup" (lambda () (emit "&cup;")))
+(tex-def-math-prim "\\uplus" (lambda () (emit "&#x2283;")))
+(tex-def-math-prim "\\sqcap" (lambda () (emit "&#x2293;")))
+(tex-def-math-prim "\\sqcup" (lambda () (emit "&#x2294;")))
+(tex-def-math-prim "\\triangleleft" (lambda () (emit "&#x2282;")))
+(tex-def-math-prim "\\triangleright" (lambda () (emit "&#x2283;")))
+(tex-def-math-prim "\\wr" (lambda () (emit "&#x2240;")))
+(tex-def-math-prim "\\vee" (lambda () (emit "&or;")))
+(tex-def-math-prim "\\wedge" (lambda () (emit "&and;")))
+(tex-def-math-prim "\\oplus" (lambda () (emit "&oplus;")))
+(tex-def-math-prim "\\otimes" (lambda () (emit "&otimes;")))
+(tex-def-math-prim "\\oslash" (lambda () (emit "&#x2298;")))
+(tex-def-math-prim "\\odot" (lambda () (emit "&#x2299;")))
+(tex-def-math-prim "\\dagger" (lambda () (emit "&dagger;")))
+(tex-def-math-prim "\\ddagger" (lambda () (emit "&Dagger;")))
+(tex-def-math-prim "\\amalg" (lambda () (emit "&#x2210;")))
+
+;8. relations
+
+(tex-def-math-prim "\\leq" (lambda ()(emit "&le;")))
+(tex-def-math-prim "\\prec" (lambda () (emit "&#x227a;")))
+(tex-def-math-prim "\\preceq" (lambda () (emit "&#x227c;")))
+(tex-def-math-prim "\\ll" (lambda () (emit "&#x226a;")))
+(tex-def-math-prim "\\subset" (lambda () (emit "&sub;")))
+(tex-def-math-prim "\\subseteq" (lambda () (emit "&sube;")))
+(tex-def-math-prim "\\sqsubseteq" (lambda () (emit "&#x2291;")))
+(tex-def-math-prim "\\in" (lambda () (emit "&isin;")))
+(tex-def-math-prim "\\vdash" (lambda () (emit "&#x22a2;")))
+(tex-def-math-prim "\\smile" (lambda () (emit "&#x2323;")))
+(tex-def-math-prim "\\frown" (lambda () (emit "&#x2322;")))
+(tex-def-math-prim "\\geq" (lambda () (emit "&ge;")))
+(tex-def-math-prim "\\succ" (lambda () (emit "&#x227b;")))
+(tex-def-math-prim "\\succeq" (lambda () (emit "&#x227d;")))
+(tex-def-math-prim "\\gg" (lambda () (emit "&#x226b;")))
+(tex-def-math-prim "\\supset" (lambda () (emit "&sup;")))
+(tex-def-math-prim "\\supseteq" (lambda () (emit "&supe;")))
+(tex-def-math-prim "\\sqsupseteq" (lambda () (emit "&#x2292;")))
+(tex-def-math-prim "\\ni" (lambda () (emit "&ni;")))
+(tex-def-math-prim "\\dashv" (lambda () (emit "&#x22a3;")))
+(tex-def-math-prim "\\mid" (lambda () (emit "&#x2223;")))
+(tex-def-math-prim "\\parallel" (lambda () (emit "&#x2225;")))
+(tex-def-math-prim "\\equiv" (lambda () (emit "&equiv;")))
+(tex-def-math-prim "\\sim" (lambda () (emit "&sim;")))
+(tex-def-math-prim "\\simeq" (lambda () (emit "&#x2243;")))
+(tex-def-math-prim "\\asymp" (lambda () (emit "&#x224d;")))
+(tex-def-math-prim "\\approx" (lambda () (emit "&asymp;")))
+(tex-def-math-prim "\\cong" (lambda () (emit "&cong;")))
+(tex-def-math-prim "\\bowtie" (lambda () (emit "&#x22c8;")))
+(tex-def-math-prim "\\propto" (lambda () (emit "&#x221d;")))
+(tex-def-math-prim "\\models" (lambda () (emit "&#x22a8;")))
+(tex-def-math-prim "\\doteq" (lambda () (emit "&#x2250;")))
+(tex-def-math-prim "\\propto" (lambda () (emit "&prop;")))
+(tex-def-math-prim "\\perp" (lambda () (emit "&perp;")))
+
+;9. negated relations
+
+(define do-not
+  (lambda ()
+    (ignorespaces)
+    (let ((c (snoop-actual-char)))
+      (if (char=? c *esc-char*)
+          (let ((x (get-ctl-seq)))
+            (emit (cond ((string=? x "\\leq") "&#x2270;")
+                        ((string=? x "\\prec") "&#x2280;")
+                        ((string=? x "\\preceq") "&#x22e0;")
+                        ((string=? x "\\subset") "&#x2284;")
+                        ((string=? x "\\subseteq") "&#x2288;")
+                        ((string=? x "\\sqsubseteq") "&#x22e2;")
+                        ((string=? x "\\geq") "&#x2271;")
+                        ((string=? x "\\succ") "&#x2281;")
+                        ((string=? x "\\succeq") "&#x22e1;")
+                        ((string=? x "\\supset") "&#x2285;")
+                        ((string=? x "\\supseteq") "&#x2289;")
+                        ((string=? x "\\sqsupseteq") "&#x22e3;")
+                        ((string=? x "\\equiv") "&#x2262;")
+                        ((string=? x "\\sim") "&#x2241;")
+                        ((string=? x "\\simeq") "&#x2244;")
+                        ((string=? x "\\approx") "&#x2249;")
+                        ((string=? x "\\cong") "&#x2247;")
+                        ((string=? x "\\asymp") "&#x226d;")
+                        (t (toss-back-string x) ""))))
+        (case c
+          ((#\< #\> #\=) (get-actual-char)
+           (emit (case c
+                   ((#\<) "&#x226e;")
+                   ((#\>) "&#x226f;")
+                   ((#\=) "&#x2260;"))))
+          (else (emit "/")))))))
+
+(tex-def-math-prim "\\not" do-not)
+(tex-def-math-prim "\\notin" (lambda () (emit "&notin;")))
+
+;10. arrows
+
+(tex-def-math-prim "\\leftarrow" (lambda () (emit "&larr;")))
+(tex-def-math-prim "\\Leftarrow" (lambda () (emit "&lArr;")))
+(tex-def-math-prim "\\rightarrow" (lambda () (emit "&rarr;")))
+(tex-def-math-prim "\\Rightarrow" (lambda () (emit "&rArr;")))
+(tex-def-math-prim "\\leftrightarrow" (lambda () (emit "&harr;")))
+(tex-def-math-prim "\\Leftrightarrow" (lambda () (emit "&hArr;")))
+(tex-def-math-prim "\\mapsto" (lambda () (emit "&#x21a6;")))
+(tex-def-math-prim "\\hookleftarrow" (lambda () (emit "&#x21a9;")))
+(tex-def-math-prim "\\leftharpoonup" (lambda () (emit "&#x21bc;")))
+(tex-def-math-prim "\\leftharpoondown" (lambda () (emit "&#x21bd;")))
+(tex-def-math-prim "\\rightleftharpoons" (lambda () (emit "&#x21cb;")))
+(tex-def-math-prim "\\longleftarrow" (lambda () (emit "&larr;---")))
+(tex-def-math-prim "\\Longleftarrow" (lambda () (emit "&lArr;===")))
+(tex-def-math-prim "\\longrightarrow" (lambda () (emit "---&rarr;")))
+(tex-def-math-prim "\\Longrightarrow" (lambda () (emit "===&rArr;")))
+(tex-def-math-prim "\\longleftrightarrow" (lambda () (emit "&larr;---&rarr;")))
+(tex-def-math-prim "\\Longleftrightarrow" (lambda () (emit "&lArr;===&rArr;")))
+(tex-def-math-prim "\\longmapsto" (lambda () (emit "---&#x21a6;")))
+(tex-def-math-prim "\\hookrightarrow" (lambda () (emit "&#x21aa;")))
+(tex-def-math-prim "\\rightharpoonup" (lambda () (emit "&#x21c0;")))
+(tex-def-math-prim "\\rightharpoondown" (lambda () (emit "&#x21c1;")))
+(tex-def-math-prim "\\uparrow" (lambda () (emit "&uarr;")))
+(tex-def-math-prim "\\Uparrow" (lambda () (emit "&uArr;")))
+(tex-def-math-prim "\\downarrow" (lambda () (emit "&darr;")))
+(tex-def-math-prim "\\Downarrow" (lambda () (emit "&dArr;")))
+(tex-def-math-prim "\\nearrow" (lambda () (emit "&#x2197;")))
+(tex-def-math-prim "\\searrow" (lambda () (emit "&#x2198;")))
+(tex-def-math-prim "\\swarrow" (lambda () (emit "&#x2199;")))
+(tex-def-math-prim "\\nwarrow" (lambda () (emit "&#x2196;")))
+
+;11. openings
+
+(tex-def-math-prim "\\lbrack" (lambda () (emit "[")))
+(tex-def-math-prim "\\lbrace" (lambda () (emit "{")))
+(tex-def-math-prim "\\lfloor" (lambda () (emit "&lfloor;")))
+(tex-def-math-prim "\\langle" (lambda () (emit "&lang;")))
+(tex-def-math-prim "\\lceil" (lambda () (emit "&lceil;")))
+
+;12. closings
+
+(tex-def-math-prim "\\rbrack" (lambda () (emit "]")))
+(tex-def-math-prim "\\rbrace" (lambda () (emit "}")))
+(tex-def-math-prim "\\rfloor" (lambda () (emit "&rfloor;")))
+(tex-def-math-prim "\\rangle" (lambda () (emit "&rang;")))
+(tex-def-math-prim "\\rceil" (lambda () (emit "&rceil;")))
+
+;13. punctuation
+
+(tex-def-math-prim "\\colon" (lambda () (emit #\:)))
+(tex-def-math-prim "\\ldotp" (lambda () (emit #\.)))
+(tex-let-prim "\\cdotp" "\\cdot")
+
+;14. alternate names
+
+(tex-def-math-prim "\\ne" (lambda () (emit "&ne;")))
+(tex-let-prim "\\neq" "\\ne")
+(tex-let-prim "\\le" "\\leq")
+(tex-let-prim "\\ge" "\\geq")
+(tex-let-prim "\\{" "\\lbrace")
+(tex-let-prim "\\}" "\\rbrace")
+(tex-let-prim "\\to" "\\rightarrow")
+(tex-let-prim "\\gets" "\\leftarrow")
+(tex-let-prim "\\owns" "\\ni")
+(tex-let-prim "\\land" "\\wedge")
+(tex-let-prim "\\lor" "\\vee")
+(tex-let-prim "\\lnot" "\\neg")
+(tex-let-prim "\\vert" "\\mid")
+(tex-let-prim "\\Vert" "\\parallel")
+(tex-let-prim "\\iff" "\\Longleftrightarrow")
+
+;15. non-math symbols
+
+(tex-def-prim "\\S" (lambda () (emit "&sect;")))
+(tex-def-prim "\\P" (lambda () (emit "&para;")))
+(tex-def-prim "\\dag" (lambda () (emit "&dagger;")))
+(tex-def-prim "\\ddag" (lambda () (emit "&Dagger;")))
+
+;end appendix F
+
+;((string=? s "\\vdots" (lambda () (emit ":")))
+
+(tex-def-math-prim "\\eqalign" (lambda () (do-eqalign ':eqalign)))
+(tex-def-math-prim "\\eqalignno" (lambda () (do-eqalign ':eqalignno)))
+(tex-def-math-prim "\\displaylines" (lambda () (do-eqalign ':displaylines)))
+(tex-def-math-prim "\\noalign" do-noalign)
+(tex-def-math-prim "\\frac" do-frac)
+(tex-def-math-prim "\\pmatrix" do-pmatrix)
+(tex-def-math-prim "\\matrix" do-relax)
+(tex-def-math-prim "\\eqno" do-eqno)
+
+(tex-def-math-prim "\\mathbf" do-relax)
+(tex-def-math-prim "\\mathrm" do-relax)
+(tex-def-math-prim "\\over" do-over)
+(tex-def-math-prim "\\sqrt" (lambda ()
+                              (emit "&radic;(")
+                              (tex2page-string (get-token))
+                              (emit ")")))
+(tex-def-math-prim "\\left" do-math-left)
+(tex-def-math-prim "\\right" do-math-right)
+
+;spaces
+
+(define kern
+  (lambda (len)
+    (string-append "<span style=\"margin-left: "
+                   len "\">&zwnj;</span>")))
+
+(tex-def-prim "\\enspace" (lambda () (emit (kern ".5em"))))
+(tex-def-prim "\\thinspace" (lambda () (emit (kern ".16667em"))))
+(tex-def-prim "\\negthinspace" (lambda () (emit (kern "-.16667em"))))
+(tex-def-prim "\\quad" (lambda () (emit (kern "1em"))))
+(tex-def-prim "\\qquad" (lambda () (emit (kern "2em"))))
+(tex-let-prim "\\enskip" "\\enspace")
+
+(tex-def-math-prim "\\," (lambda () (emit (kern ".16667em"))))
+(tex-def-math-prim "\\>" (lambda () (emit (kern ".22222em"))))
+(tex-def-math-prim "\\;" (lambda () (emit (kern ".27778em"))))
+(tex-def-math-prim "\\!" (lambda () (emit (kern "-.16667em"))))
+
+;
+
+(tex-def-prim "\\AA" (lambda () (emit "&Aring;")))
+(tex-def-prim "\\aa" (lambda () (emit "&aring;")))
+(tex-def-prim "\\abstract"
+              (lambda ()
+                (tex2page-string "\\quote")
+                (tex2page-string "\\centerline{\\bf\\abstractname}\\par")))
+(tex-def-prim "\\addcontentsline" do-addcontentsline)
+(tex-def-prim "\\addtocounter" (lambda () (set-latex-counter #t)))
+(tex-def-prim "\\advance" (lambda () (do-advance (global?))))
+(tex-def-prim "\\advancetally" (lambda () (do-advancetally (global?))))
+(tex-def-prim "\\AE" (lambda () (emit "&AElig;")))
+(tex-def-prim "\\ae" (lambda () (emit "&aelig;")))
+(tex-def-prim "\\afterassignment" do-afterassignment)
+(tex-def-prim "\\aftergroup" do-aftergroup)
+(tex-def-prim "\\align" (lambda () (do-equation ':align)))
+(tex-def-prim "\\alltt" do-alltt)
+(tex-def-prim "\\appendix" do-appendix)
+(tex-def-prim "\\appendixname" (lambda () (emit "Appendix ")))
+(tex-def-prim "\\author" do-author)
+
+(tex-def-prim "\\b" (lambda () (do-diacritic ':barunder)))
+(tex-def-prim "\\begin" do-begin)
+;(tex-def-prim "\\bgroup" bgroup)
+(tex-def-prim-0arg "\\bgroup" "{")
+(tex-def-prim "\\beginchapter" do-beginchapter)
+(tex-def-prim "\\beginsection" do-beginsection)
+(tex-def-prim "\\bf" (lambda () (do-switch ':bf)))
+(tex-def-prim "\\bgcolor" (lambda () (do-switch ':bgcolor)))
+(tex-def-prim "\\bibitem" do-bibitem)
+(tex-def-prim "\\bibliography" do-bibliography)
+(tex-def-prim "\\bibliographystyle" do-bibliographystyle)
+(tex-def-prim "\\bigbreak" (lambda () (do-bigskip ':bigskip)))
+(tex-def-prim "\\bigskip" (lambda () (do-bigskip ':bigskip)))
+(tex-def-prim "\\break" (lambda () (emit "<br>")))
+(tex-def-prim "\\bull" (lambda () (emit "&#x25fe;")))
+
+(tex-def-prim "\\c" (lambda () (do-diacritic ':cedilla)))
+(tex-def-prim "\\caption" do-caption)
+(tex-def-prim "\\catcode" do-catcode)
+(tex-def-math-prim "\\cdots"
+  (lambda () (emit "<tt>&middot;&middot;&middot;</tt>")))
+(tex-def-prim "\\center" (lambda () (do-block ':center)))
+(tex-def-prim "\\centerline" (lambda () (do-function "\\centerline")))
+(tex-def-prim "\\chapter"
+              (lambda ()
+                (!using-chapters)
+                (write-aux `(!using-chapters))
+                (when (and (eqv? *tex-format* ':latex)
+                           (< (get-gcount "\\secnumdepth") -1))
+                  (set-gcount! "\\secnumdepth" 2))
+                (do-heading 0)))
+(tex-def-prim "\\chaptername" (lambda () (emit "Chapter ")))
+(tex-def-prim "\\char" do-char)
+(tex-def-prim "\\cite" do-cite)
+(tex-def-prim "\\closegraphsfile" do-mfpic-closegraphsfile)
+(tex-def-prim "\\closein" (lambda () (do-close-stream ':in)))
+(tex-def-prim "\\closeout" (lambda () (do-close-stream ':out)))
+(tex-def-prim "\\color" do-color)
+(tex-def-prim "\\convertMPtoPDF" do-convertmptopdf)
+(tex-def-prim "\\copyright" (lambda () (emit "&copy;")))
+(tex-def-prim "\\countdef"
+              (lambda ()
+                (do-newcount #t) (eat-integer)))
+(tex-def-prim "\\CR" (lambda () (do-cr "\\CR")))
+(tex-def-prim "\\cr" (lambda () (do-cr "\\cr")))
+(tex-def-prim "\\csname" do-csname)
+(tex-def-prim "\\cssblock" do-cssblock)
+
+(tex-def-prim "\\d" (lambda () (do-diacritic ':dotunder)))
+(tex-def-prim "\\." (lambda () (do-diacritic ':dot)))
+(tex-def-prim "\\dag" (lambda () (emit "&dagger;")))
+(tex-def-prim "\\date" do-date)
+(tex-def-prim "\\ddag" (lambda () (emit "&Dagger;")))
+(tex-def-prim "\\def" (lambda () (do-def (global?) #f)))
+(tex-def-prim "\\defcsactive" (lambda () (do-defcsactive (global?))))
+(tex-def-prim "\\definecolor" do-definecolor)
+(tex-def-prim "\\DefineNamedColor"
+              (lambda () (get-token) (do-definecolor)))
+(tex-def-prim "\\definexref" do-definexref)
+(tex-def-prim "\\definitelylatex" definitely-latex)
+(tex-def-prim "\\defschememathescape" (lambda () (scm-set-mathescape #t)))
+(tex-def-prim "\\degree" (lambda () (emit "&deg;")))
+(tex-def-prim "\\description"
+              ;used to be <ul> ... </ul>
+              (lambda () (do-end-para)
+                (set! *tabular-stack* (cons ':description *tabular-stack*))
+                (emit "<dl><dt></dt><dd>")
+                ))
+(tex-def-prim "\\DH" (lambda () (emit "&ETH;")))
+(tex-def-prim "\\dh" (lambda () (emit "&eth;")))
+(tex-def-prim "\\discretionary" do-discretionary)
+(tex-def-prim "\\displaymath"
+  (lambda () (do-latex-env-as-image "displaymath" ':display)))
+(tex-def-prim "\\divide" (lambda () (do-divide (global?))))
+(tex-def-prim "\\document" probably-latex)
+(tex-def-prim "\\documentclass" do-documentclass)
+(tex-def-prim "\\dontuseimgforhtmlmath" ;obsolete
+              (lambda ()
+                (tex-def-0arg "\\TZPmathimage" "0")
+                ))
+(tex-def-prim "\\dontuseimgforhtmlmathdisplay" ;obsolete
+  (lambda ()
+    (tex-def-0arg "\\TZPmathimage" "0")
+   ))
+(tex-def-prim "\\dontuseimgforhtmlmathintext" ;obsolete
+  (lambda ()
+   #t
+   ))
+(tex-def-prim "\\dots" (lambda () (emit "<tt>...</tt>")))
+
+(tex-def-prim "\\edef" (lambda () (do-def (global?) #t)))
+;(tex-def-prim "\\egroup" egroup)
+(tex-def-prim-0arg "\\egroup" "}")
+(tex-def-prim "\\eject" do-eject)
+(tex-def-prim "\\else" (lambda () (do-else)))
+(tex-def-prim "\\em" (lambda () (do-switch ':em )))
+(tex-def-prim "\\emph" (lambda () (do-function "\\emph")))
+(tex-def-prim-0arg "\\empty" "") ;for \ifx comparisons
+(tex-def-prim "\\end" do-end)
+(tex-def-prim "\\endalign" do-end-equation)
+(tex-def-prim "\\endalltt" do-end-alltt)
+(tex-def-prim "\\endcenter" do-end-block)
+(tex-def-prim "\\enddescription"
+              (lambda ()
+                (pop-tabular-stack ':description)
+                (do-end-para)
+                (emit "</dd></dl>")
+                (do-para)))
+(tex-def-prim "\\endeqnarray" do-end-equation)
+(tex-def-prim "\\endequation" do-end-equation)
+(tex-def-prim "\\endenumerate"
+              (lambda ()
+                (pop-tabular-stack ':enumerate)
+                (do-end-para) (emit "</ol>") (do-para)))
+(tex-def-prim "\\endfigure" (lambda () (do-end-table/figure ':figure)))
+(tex-def-prim "\\endflushleft" do-end-block)
+(tex-def-prim "\\endflushright" do-end-block)
+(tex-def-prim "\\endgraf" do-para)
+(tex-def-prim "\\endhtmlimg"
+  (lambda () (terror 'tex-def-prim "Unmatched \\endhtmlimg")))
+(tex-def-prim "\\endhtmlonly"
+  (lambda () (set! *html-only* (- *html-only* 1))))
+(tex-def-prim "\\enditemize"
+              (lambda ()
+                (pop-tabular-stack ':itemize)
+                (do-end-para) (emit "</ul>") (do-para)))
+(tex-def-prim "\\endminipage" do-endminipage)
+(tex-def-prim "\\endruledtable" do-endruledtable)
+(tex-def-prim "\\endtabbing" do-end-tabbing)
+(tex-def-prim "\\endtable" (lambda () (do-end-table/figure ':table)))
+(tex-def-prim "\\endtableplain" do-end-table-plain)
+(tex-def-prim "\\endtabular" do-end-tabular)
+(tex-def-prim "\\endthebibliography"
+              (lambda () (emit "</table>") (egroup) (do-para)))
+(tex-def-prim "\\endverbatim" do-endverbatim-eplain)
+(tex-def-prim "\\enumerate"
+              (lambda () (do-end-para)
+                (set! *tabular-stack* (cons ':enumerate *tabular-stack*))
+                (emit "<ol>")))
+(tex-def-prim "\\epsfbox" do-epsfbox)
+(tex-def-prim "\\epsfig" do-epsfig)
+;(tex-def-prim "\\eqnarray"
+;  (lambda () (do-latex-env-as-image "eqnarray" 'display)))
+(tex-def-prim "\\eqnarray" (lambda () (do-equation ':eqnarray)))
+;(tex-def-prim "\\equation"
+;  (lambda () (do-latex-env-as-image "equation" 'display)))
+(tex-def-prim "\\equation" (lambda () (do-equation ':equation)))
+(tex-def-prim "\\errmessage" do-errmessage)
+(tex-def-prim "\\eval" (lambda () (do-eval ':both)))
+(tex-def-prim "\\evalh" (lambda () (do-eval ':html)))
+(tex-def-prim "\\evalq" (lambda () (do-eval ':quiet)))
+(tex-def-prim "\\expandafter" do-expandafter)
+(tex-def-prim "\\expandhtmlindex" expand-html-index)
+(tex-def-prim "\\externaltitle" do-externaltitle)
+
+(tex-def-prim "\\fi" (lambda () (do-fi)))
+(tex-def-prim "\\figure" (lambda () (do-table/figure ':figure)))
+(tex-def-prim "\\fiverm" (lambda () (do-switch ':fiverm)))
+(tex-def-prim "\\flushleft" (lambda () (do-block ':flushleft)))
+(tex-def-prim "\\flushright" (lambda () (do-block ':flushright)))
+(tex-def-prim "\\fmtname" (lambda () (emit "TeX2page")))
+(tex-def-prim "\\fmtversion" (lambda () (emit *tex2page-version*)
+                               ;(emit " (") (emit *scheme-version*)
+                               ;(emit ", ") (emit *operating-system*)
+                               ;(emit ")")
+                               ))
+(tex-def-prim "\\folio" (lambda () (emit *html-page-count*)))
+(tex-def-prim "\\font" do-font)
+(tex-def-prim "\\footnote" do-footnote)
+(tex-def-prim "\\footnotesize" (lambda () (do-switch ':footnotesize)))
+(tex-def-prim "\\frac" do-frac)
+(tex-def-prim "\\futurelet" do-futurelet)
+(tex-def-prim "\\futurenonspacelet" do-futurenonspacelet)
+
+(tex-def-prim "\\gdef" (lambda () (do-def #t #f)))
+(tex-def-prim "\\global" do-global)
+(tex-def-prim "\\globaladvancetally" (lambda () (do-advancetally #t)))
+(tex-def-prim "\\gobblegroup" get-group)
+
+(tex-def-prim "\\\"" (lambda () (do-diacritic ':umlaut)))
+(tex-def-prim "\\H" (lambda () (do-diacritic ':hungarianumlaut)))
+(tex-def-prim "\\halign" do-halign)
+(tex-def-prim "\\hbox" do-box)
+(tex-def-prim "\\hfill" (lambda () (emit-nbsp 5))) ;was <br>.  Why?
+(tex-def-prim "\\hlstart" do-hlstart)
+(tex-def-prim "\\href" do-urlh)
+(tex-def-prim "\\hrule" (lambda () (do-end-para) (emit "<hr>")
+                          (emit-newline) (do-para)))
+(tex-def-prim "\\hskip" do-hskip) ; 3nbsp?
+(tex-def-prim "\\hspace" do-hspace)
+(tex-def-prim "\\htmladdimg" do-htmladdimg)
+(tex-def-prim "\\htmlcolophon" do-htmlcolophon)
+(tex-def-prim "\\htmldoctype" do-htmldoctype)
+(tex-def-prim "\\htmlgif" (lambda () (do-htmlimg "htmlgif"))) ;obs
+(tex-def-prim "\\htmlheadonly" do-htmlheadonly)
+(tex-def-prim "\\htmlimageconversionprogram" do-htmlimageconversionprogram) ;obs
+(tex-def-prim "\\htmlimageformat" do-htmlimageformat) ;obs
+(tex-def-prim "\\htmlimg" (lambda () (do-htmlimg "htmlimg"))) ;obs
+(tex-def-prim "\\htmlimgmagnification" do-htmlimgmagnification) ;obs
+(tex-def-prim "\\htmlmathstyle" do-htmlmathstyle)
+(tex-def-prim "\\htmlonly"
+  (lambda () (set! *html-only* (+ *html-only* 1))))
+(tex-def-prim "\\htmlpagelabel" do-htmlpagelabel)
+(tex-def-prim "\\htmlpageref" do-htmlpageref)
+(tex-def-prim "\\htmlref"  do-htmlref)
+(tex-def-prim "\\htmlrefexternal" do-htmlrefexternal)
+(tex-def-prim "\\htmlspan" (lambda () (do-switch ':span)))
+(tex-def-prim "\\htmldiv" (lambda () (do-switch ':div)))
+(tex-def-prim "\\huge" (lambda () (do-switch ':huge)))
+(tex-def-prim "\\Huge" (lambda () (do-switch ':huge-cap)))
+;(tex-def-prim "\\hyperimage" do-hyperimage)
+(tex-def-prim "\\hyperref" do-hyperref)
+(tex-def-prim "\\hyperlink" do-hyperlink)
+(tex-def-prim "\\hypertarget" do-hypertarget)
+
+(tex-def-prim "\\i" (lambda () (emit "&#x131;")))
+(tex-def-prim "\\if" do-if)
+(tex-def-prim "\\ifcase" do-ifcase)
+(tex-def-prim "\\ifdefined" do-ifdefined)
+(tex-def-prim "\\ifeof" do-ifeof)
+(tex-def-prim "\\ifdim" do-iffalse)
+(tex-def-prim "\\iffalse" do-iffalse)
+(tex-def-prim "\\IfFileExists" do-iffileexists)
+(tex-def-prim "\\ifhmode" do-iftrue)
+(tex-def-prim "\\ifmmode" do-ifmmode)
+(tex-def-prim "\\ifnum" (lambda () ( do-ifnum)))
+(tex-def-prim "\\iftrue" do-iftrue)
+(tex-def-prim "\\ifx" do-ifx)
+(tex-def-prim "\\ifodd" do-ifodd)
+(tex-def-prim "\\ignorenextinputtimestamp"
+  (lambda ()
+    (unless *inputting-boilerplate?*
+      (set! *inputting-boilerplate?* 0))))
+(tex-def-prim "\\ignorespaces" ignorespaces)
+(tex-def-prim "\\imgdef" (lambda () (make-reusable-img (global?))))
+(tex-def-prim "\\imgpreamble" do-img-preamble)
+(tex-def-prim "\\IMGtabbing"
+              (lambda () (do-latex-env-as-image "tabbing" ':display)))
+(tex-def-prim "\\IMGtabular"
+              (lambda () (do-latex-env-as-image "tabular" ':display)))
+(tex-def-prim "\\include" do-include)
+(tex-def-prim "\\includeexternallabels" do-includeexternallabels)
+(tex-def-prim "\\includeonly" do-includeonly)
+(tex-def-prim "\\includegraphics" do-includegraphics)
+(tex-def-prim "\\index" do-index)
+(tex-def-prim "\\indexitem" (lambda () (do-indexitem 0)))
+(tex-def-prim "\\indexsubitem" (lambda () (do-indexitem 1)))
+(tex-def-prim "\\indexsubsubitem" (lambda () (do-indexitem 2)))
+(tex-def-prim "\\input" do-input)
+(tex-def-prim "\\inputcss" do-inputcss)
+(tex-def-prim "\\inputexternallabels" do-inputexternallabels)
+(tex-def-prim "\\InputIfFileExists" do-inputiffileexists)
+(tex-def-prim "\\inputindex" (lambda () (do-inputindex #f)))
+(tex-def-prim "\\it" (lambda () (do-switch ':it)))
+(tex-def-prim "\\item" do-item)
+(tex-def-prim "\\itemitem" (lambda () (do-plain-item 2)))
+(tex-def-prim "\\itemize"
+              (lambda () (do-end-para)
+                (set! *tabular-stack* (cons ':itemize *tabular-stack*))
+                (emit "<ul>")))
+(tex-def-prim "\\itshape" (lambda () (do-switch ':itshape)))
+
+(tex-def-prim "\\j" (lambda () (emit "&#x237;")))
+(tex-def-prim "\\jobname" (lambda () (tex2page-string *jobname*)))
+
+(tex-def-prim "\\k" (lambda () (do-diacritic ':ogonek)))
+(tex-def-prim "\\kern" do-hskip)
+
+(tex-def-prim "\\l" (lambda () (emit "&#x142;")))
+(tex-def-prim "\\L" (lambda () (emit "&#x141;")))
+(tex-def-prim "\\label" do-label)
+(tex-def-prim "\\large" (lambda () (do-switch ':large)))
+(tex-def-prim "\\Large" (lambda () (do-switch ':large-cap)))
+(tex-def-prim "\\LARGE" (lambda () (do-switch ':large-up)))
+(tex-def-prim "\\latexonly"
+  (lambda () (ignore-tex-specific-text "latexonly")))
+(tex-def-prim "\\leftdisplays"
+  (lambda () (set! *display-justification* "left")))
+(tex-def-prim "\\leftline" (lambda () (do-function "\\leftline")))
+(tex-def-prim "\\let" (lambda () (do-let (global?))))
+(tex-def-prim "\\linebreak"
+  (lambda () (get-bracketed-text-if-any) (emit "<br>")))
+(tex-def-prim "\\listing" do-verbatiminput)
+(tex-def-prim "\\lstlisting" (lambda () (do-verbatim-latex "lstlisting")))
+
+(tex-def-prim "\\magnification" do-magnification)
+(tex-def-prim "\\magstep" do-magstep)
+(tex-def-prim-0arg "\\magstephalf" "1095")
+(tex-def-prim "\\mailto" do-mailto)
+(tex-def-prim "\\makeatletter" (lambda () (set-catcode #\@ 11)))
+(tex-def-prim "\\makeatother" (lambda () (set-catcode #\@ 12)))
+(tex-def-prim "\\makehtmlimage" do-makehtmlimage)
+(tex-def-prim "\\maketitle" do-maketitle)
+(tex-def-prim "\\marginpar" do-marginpar)
+(tex-def-prim "\\mathg" do-mathg)
+(tex-def-prim "\\mathdg" do-mathdg)
+(tex-def-prim "\\mathp" do-mathp)
+(tex-def-prim "\\medbreak" (lambda () (do-bigskip ':medskip)))
+(tex-def-prim "\\medskip" (lambda () (do-bigskip ':medskip)))
+(tex-def-prim "\\message" do-message)
+(tex-def-prim "\\mfpic" do-mfpic)
+(tex-def-prim "\\minipage" do-minipage)
+(tex-def-prim "\\multiply" (lambda () (do-multiply (global?))))
+
+(tex-def-prim "\\narrower" (lambda () (do-switch ':narrower)))
+(tex-def-prim "\\newcommand" (lambda () (do-newcommand #f)))
+(tex-def-prim "\\newcount" (lambda () (do-newcount (global?))))
+(tex-def-prim "\\newdimen" (lambda () (do-newdimen (global?))))
+(tex-def-prim "\\newenvironment" (lambda () (do-newenvironment #f)))
+(tex-def-prim "\\newif" do-newif)
+(tex-def-prim "\\newread" (lambda () (do-new-stream ':in)))
+(tex-def-prim "\\newtheorem" do-newtheorem)
+(tex-def-prim "\\newtoks" (lambda () (do-newtoks (global?))))
+(tex-def-prim "\\newwrite" (lambda () (do-new-stream ':out)))
+(tex-def-prim "\\noad"
+              (lambda () (tex-def-0arg "\\TZPcolophoncredit" "0")))
+(tex-def-prim "\\nocite" do-nocite)
+(tex-def-prim "\\node" do-node)
+(tex-def-prim "\\noindent" do-noindent)
+(tex-def-prim "\\nonumber" do-nonumber)
+(tex-def-prim "\\noslatexlikecomments"
+              (lambda () (tex-def-0arg "\\TZPslatexcomments" "0")))
+(tex-def-prim "\\notimestamp"
+              (lambda () (tex-def-0arg "\\TZPcolophontimestamp" "0")))
+(tex-def-prim "\\nr" (lambda () (do-cr "\\nr")))
+(tex-def-prim "\\number" do-number)
+(tex-def-prim "\\numberedfootnote" do-numbered-footnote)
+
+(tex-def-prim "\\@ldc@l@r" do-color)
+(tex-def-prim "\\O" (lambda () (emit "&Oslash;")))
+(tex-def-prim "\\o" (lambda () (emit "&oslash;")))
+(tex-def-prim "\\obeylines" do-obeylines)
+(tex-def-prim "\\obeyspaces" do-obeyspaces)
+(tex-def-prim "\\obeywhitespace" do-obeywhitespace)
+(tex-def-prim "\\OE" (lambda () (emit "&OElig;")))
+(tex-def-prim "\\oe" (lambda () (emit "&oelig;")))
+(tex-def-prim "\\opengraphsfile" do-mfpic-opengraphsfile)
+(tex-def-prim "\\openin" (lambda () (do-open-stream ':in)))
+(tex-def-prim "\\openout" (lambda () (do-open-stream ':out)))
+
+(tex-def-prim "\\pagebreak" (lambda () (get-bracketed-text-if-any) (do-eject)))
+(tex-def-prim "\\pageno" (lambda () (emit *html-page-count*)))
+(tex-def-prim "\\pageref" do-pageref)
+(tex-def-prim "\\part" (lambda () (do-heading -1)))
+(tex-def-prim "\\pdfximage" do-pdfximage)
+(tex-def-prim "\\picture" (lambda () (do-latex-env-as-image "picture" #f)))
+(tex-def-prim "\\plainfootnote" do-plain-footnote)
+(tex-def-prim "\\pounds" (lambda () (emit "&pound;")))
+(tex-def-prim "\\printindex" (lambda () (do-inputindex #t)))
+(tex-def-prim "\\providecommand" (lambda () (do-newcommand #f)))
+
+(tex-def-prim "\\quote"
+              (lambda ()
+                (do-end-para) (emit "<blockquote>") (bgroup)))
+(tex-def-prim "\\endquote"
+  (lambda () (do-end-para) (egroup) (emit "</blockquote>")))
+
+(tex-def-prim "\\r" (lambda () (do-diacritic ':ring)))
+(tex-def-prim "\\raggedleft" (lambda () (do-switch ':raggedleft)))
+(tex-def-prim "\\rawhtml" do-rawhtml)
+(tex-def-prim "\\read" (lambda () (do-read (global?))))
+(tex-def-prim "\\readtocfile" do-toc)
+(tex-def-prim "\\ref" do-ref)
+(tex-def-prim "\\refexternal" do-refexternal)
+(tex-def-prim "\\refn" do-ref)
+(tex-def-prim "\\relax" do-relax)
+(tex-def-prim "\\renewcommand" (lambda () (do-newcommand #t)))
+(tex-def-prim "\\renewenvironment" (lambda () (do-newenvironment #t)))
+(tex-def-prim "\\resetatcatcode" (lambda () (set-catcode #\@ 12)))
+(tex-def-prim "\\resizebox" do-resizebox)
+(tex-def-prim "\\rightline" (lambda () (do-function "\\rightline")))
+(tex-def-prim "\\rm" (lambda ()
+                       (when *math-mode?*
+                           (do-switch ':rm))))
+(tex-def-prim "\\romannumeral" (lambda () (do-romannumeral #f)))
+(tex-def-prim "\\Romannumeral" (lambda () (do-romannumeral #t)))
+(tex-def-prim "\\ruledtable" do-ruledtable)
+
+(tex-def-prim "\\sc" (lambda () (do-switch ':sc)))
+(tex-def-prim "\\schemedisplay"
+  (lambda () (do-scm-slatex-lines "schemedisplay" #t #f)))
+(tex-def-prim "\\schemebox"
+  (lambda () (do-scm-slatex-lines "schemebox" #f #f)))
+(tex-def-prim "\\schemeresponse"
+              (lambda () (do-scm-slatex-lines "schemeresponse" #t ':result)))
+(tex-def-prim "\\schemeresponsebox"
+              (lambda () (do-scm-slatex-lines "schemeresponsebox" #f ':result)))
+(tex-def-prim "\\schemeresult"
+              (lambda () (do-scm ':result)))
+(tex-def-prim "\\scm"
+              (lambda () (do-scm #f)))
+(tex-def-prim "\\scmbuiltin" do-scm-set-builtins)
+(tex-def-prim "\\scmdribble" do-scmdribble)
+;(tex-def-prim "\\scmwritefile" do-scm-set-filename)
+(tex-def-prim "\\scminput" do-scminput)
+(tex-def-prim "\\scmkeyword" do-scm-set-keywords)
+(tex-def-prim "\\scmspecialsymbol" do-scm-set-specialsymbol)
+(tex-def-prim "\\scmvariable" do-scm-set-variables)
+;(tex-def-prim "\\scmwrite" do-scm-write)
+(tex-def-prim "\\scriptsize" (lambda () (do-switch ':scriptsize)))
+(tex-def-prim "\\section" (lambda () (do-heading 1)))
+(tex-def-prim "\\seealso" do-see-also)
+(tex-def-prim "\\setcounter" (lambda () (set-latex-counter #f)))
+(tex-def-prim "\\sevenrm" (lambda () (do-switch ':sevenrm)))
+(tex-def-prim "\\sf" (lambda () (do-switch ':sf)))
+(tex-def-prim "\\sidx" do-index)
+(tex-def-prim "\\sl" (lambda () (do-switch ':sl)))
+(tex-def-prim "\\slatexdisable" get-group)
+(tex-def-prim "\\slatexlikecomments"
+  (lambda () (tex-def-0arg "\\TZPslatexcomments" "1")))
+(tex-def-prim "\\small" (lambda () (do-switch ':small)))
+(tex-def-prim "\\smallbreak" (lambda () (do-bigskip ':smallskip)))
+(tex-def-prim "\\smallskip" (lambda () (do-bigskip ':smallskip)))
+(tex-def-prim "\\ss" (lambda () (emit "&szlig;")))
+(tex-def-prim "\\strike" (lambda () (do-switch ':strike)))
+(tex-def-prim "\\string" do-string)
+(tex-def-prim "\\subject" do-subject)
+(tex-def-prim "\\subsection"
+(lambda () (get-bracketed-text-if-any) (do-heading 2)))
+(tex-def-prim "\\subsubsection" (lambda () (do-heading 3)))
+(tex-def-prim "\\symfootnote" do-symfootnote)
+
+(tex-def-prim "\\t" (lambda () (do-diacritic ':tieafter)))
+(tex-def-prim "\\tabbing" do-tabbing)
+(tex-def-prim "\\table" (lambda () (do-table/figure ':table)))
+(tex-def-prim "\\tableplain" do-table-plain)
+(tex-def-prim "\\tableofcontents" do-toc)
+(tex-def-prim "\\tabular" do-tabular)
+(tex-def-prim "\\tag" do-tag)
+(tex-def-prim "\\texonly" (lambda () (ignore-tex-specific-text "texonly")))
+(tex-def-prim "\\textasciicircum" (lambda () (emit "^")))
+(tex-def-prim "\\textbar" (lambda () (emit "|")))
+(tex-def-prim "\\textbackslash" (lambda () (emit "\\")))
+(tex-def-prim "\\textbf" (lambda () (do-function "\\textbf")))
+(tex-def-prim "\\textbullet" (lambda () (emit "&bull;")))
+(tex-def-prim "\\textdegree" (lambda () (ignorespaces) (emit "&deg;")))
+(tex-def-prim "\\textemdash" (lambda () (emit "&mdash;")))
+(tex-def-prim "\\textendash" (lambda () (emit "&ndash;")))
+(tex-def-prim "\\textexclamdown" (lambda () (emit "&iexcl;")))
+(tex-def-prim "\\textgreater" (lambda () (emit "&gt;")))
+(tex-def-prim "\\textindent" do-textindent)
+(tex-def-prim "\\textit" (lambda () (do-function "\\textit")))
+(tex-def-prim "\\textless" (lambda () (emit "&lt;")))
+(tex-def-prim "\\textperiodcentered" (lambda () (emit "&middot;")))
+(tex-def-prim "\\textquestiondown" (lambda () (emit "&iquest;")))
+(tex-def-prim "\\textquotedblleft" (lambda () (emit "&ldquo;")))
+(tex-def-prim "\\textquotedblright" (lambda () (emit "&rdquo;")))
+(tex-def-prim "\\textquoteleft" (lambda () (emit "&lsquo;")))
+(tex-def-prim "\\textquoteright" (lambda () (emit "&rsquo;")))
+(tex-def-prim "\\textregistered" (lambda () (emit "&reg;")))
+(tex-def-prim "\\textrm" (lambda () (do-function "\\textrm")))
+(tex-def-prim "\\textsc"
+  (lambda ()
+    (fluid-let ((*in-small-caps?* #t))
+      (tex2page-string (get-group)))))
+(tex-def-prim "\\textsl" (lambda () (do-function "\\textsl")))
+(tex-def-prim "\\textasciitilde" (lambda () (emit "~")))
+(tex-def-prim "\\texttt" (lambda () (do-function "\\texttt")))
+(tex-def-prim "\\textvisiblespace" (lambda () (emit *verbatim-visible-space*)))
+(tex-def-prim "\\TH" (lambda () (emit "&THORN;")))
+(tex-def-prim "\\th" (lambda () (emit "&thorn;")))
+(tex-def-prim "\\the" do-the)
+(tex-def-prim "\\thebibliography" do-thebibliography)
+(tex-def-prim "\\theindex" do-theindex)
+(tex-def-prim "\\TIIPanchor" do-anchor-for-potential-label)
+(tex-def-prim "\\TIIPbackslash" (lambda () (emit "\\")))
+(tex-def-prim "\\TIIPbr" do-br)
+(tex-def-prim "\\TIIPcmyk" (lambda () (do-switch ':cmyk)))
+(tex-def-prim "\\TIIPcsname" do-saved-csname)
+(tex-def-prim "\\TIIPcomment" eat-till-eol)
+(tex-def-prim "\\TIIPeatstar" eat-star)
+(tex-def-prim "\\TIIPendgraf" do-end-para)
+(tex-def-prim "\\TIIPpar" do-para-nopadding)
+(tex-def-prim "\\TIIPfolio" point-to-adjacent-pages)
+(tex-def-prim "\\TIIPgobblegroup" get-group)
+(tex-def-prim "\\TIIPgray" (lambda () (do-switch ':gray)))
+(tex-def-prim "\\TIIPhlend" do-hlend)
+(tex-def-prim "\\TIIPlatexenvasimage" do-following-latex-env-as-image)
+(tex-def-prim "\\TIIPnbsp" (lambda () (emit-nbsp 1)))
+(tex-def-prim "\\TIIPnewline" do-newline)
+(tex-def-prim "\\TIIPnull" get-actual-char)
+(tex-def-prim "\\TIIPreuseimage" reuse-img)
+(tex-def-prim "\\TIIPrgb" (lambda () (do-switch ':rgb)))
+(tex-def-prim "\\TIIPRGB" (lambda () (do-switch ':rgb255)))
+(tex-def-prim "\\TIIPtheorem" do-theorem)
+(tex-def-prim "\\TIIPrelax" do-relax)
+(tex-def-prim "\\tiny" (lambda () (do-switch ':tiny)))
+(tex-def-prim "\\title" do-title)
+(tex-def-prim "\\TM" (lambda () (emit "&trade;")))
+(tex-def-prim "\\today" do-today)
+(tex-def-prim "\\tracingall" do-tracingall)
+(tex-def-prim "\\tt" (lambda () (do-switch ':tt)))
+(tex-def-prim "\\typein" do-typein)
+(tex-def-prim "\\TZPauxdir" (lambda () (emit *aux-dir/*)))
+(tex-def-prim "\\TZPlastpageno" (lambda () (emit *last-page-number*)))
+(tex-def-prim-0arg "\\TZPcommonlisp" (if 'nil "0" "1"))
+
+(tex-def-prim "\\undefcsactive" do-undefcsactive)
+(tex-def-prim "\\undefschememathescape" (lambda () (scm-set-mathescape #f)))
+(tex-def-prim "\\underline" (lambda () (do-function "\\underline")))
+(tex-def-prim "\\unscmspecialsymbol" do-scm-unset-specialsymbol)
+(tex-def-prim "\\uppercase" do-uppercase)
+(tex-def-prim "\\url" do-url)
+(tex-def-prim "\\urlh" do-urlh)
+(tex-def-prim "\\urlhd" do-urlhd)
+(tex-def-prim "\\urlp" do-urlp)
+
+(tex-def-prim "\\v" (lambda () (do-diacritic ':hacek)))
+(tex-def-prim "\\vdots"
+  (lambda ()
+    (emit "<tt><table><tr><td>.</td></tr>")
+    (emit "<tr><td>.</td></tr>")
+    (emit "<tr><td>.</td></tr></table></tt>")))
+(tex-def-prim "\\verb" do-verb)
+(tex-def-prim "\\verbatim" do-verbatim)
+(tex-def-prim "\\verbatiminput" do-verbatiminput)
+(tex-def-prim "\\verbc" do-verbc)
+(tex-def-prim "\\verbatimescapechar" do-verbatimescapechar)
+(tex-def-prim "\\verbwrite" do-verbwrite)
+(tex-def-prim "\\verbwritefile" do-verbwritefile)
+(tex-def-prim "\\vfootnote" do-vfootnote)
+(tex-def-prim "\\vskip" do-vskip)
+;(tex-def-prim "\\vskip" (lambda () (eat-dimen) (do-bigskip ':vskip)))
+(tex-def-prim "\\vspace" do-vspace)
+
+(tex-def-prim "\\write" do-write)
+(tex-def-prim "\\writenumberedcontentsline" do-writenumberedcontentsline)
+(tex-def-prim "\\writenumberedtocline" do-writenumberedtocline)
+
+(tex-def-prim "\\xdef" (lambda () (do-def #t #t)))
+(tex-def-prim "\\xrdef" do-xrdef)
+(tex-def-prim "\\xrefn" do-ref)
+(tex-def-prim "\\xrtag" do-tag)
+(tex-def-prim "\\xspace" do-xspace)
+
+(tex-def-prim "\\yen" (lambda () (emit "&yen;")))
+
+(tex-def-prim "\\contentsname" (lambda () (emit "Contents")))
+(tex-def-prim "\\listfigurename" (lambda () (emit "List of Figures")))
+(tex-def-prim "\\listtablename" (lambda () (emit "List of Tables")))
+(tex-def-prim "\\refname" (lambda () (emit "References")))
+(tex-def-prim "\\indexname" (lambda () (emit "Index")))
+(tex-def-prim "\\figurename" (lambda () (emit "Figure")))
+(tex-def-prim "\\tablename" (lambda () (emit "Table")))
+(tex-def-prim "\\partname" (lambda () (emit "Part")))
+(tex-def-prim "\\appendixname" (lambda () (emit "Appendix")))
+(tex-def-prim "\\abstractname" (lambda () (emit "Abstract")))
+(tex-def-prim "\\bibname" (lambda () (emit "Bibliography")))
+(tex-def-prim "\\chaptername" (lambda () (emit "Chapter")))
+
+(tex-def-prim "\\\\" (lambda () (do-cr "\\\\")))
+(tex-def-prim "\\`" (lambda () (do-diacritic ':grave)))
+;(tex-def-prim "\\-" (lambda () (emit "&shy;")))
+(tex-def-prim "\\(" do-latex-intext-math)
+(tex-def-prim "\\[" do-latex-display-math)
+(tex-def-prim "\\)" egroup)
+(tex-def-prim "\\]" egroup)
+(tex-def-prim "\\{" (lambda () (emit "{")))
+(tex-def-prim "\\}" (lambda () (emit "}")))
+(tex-let-prim "\\-" "\\TIIPrelax")
+(tex-def-prim "\\'" (lambda () (do-diacritic ':acute)))
+(tex-def-prim "\\="
+  (lambda ()
+    (unless (and (not (null? *tabular-stack*))
+                 (eqv? (car *tabular-stack*) ':tabbing))
+      (do-diacritic ':macron))))
+(tex-def-prim "\\>"
+  (lambda ()
+    (when (and (not (null? *tabular-stack*))
+             (eqv? (car *tabular-stack*) ':tabbing))
+        (emit-nbsp 3))))
+(tex-def-prim "\\^" (lambda () (do-diacritic ':circumflex)))
+(tex-def-prim "\\~" (lambda () (do-diacritic ':tilde)))
+(tex-def-prim "\\#" (lambda () (emit "#")))
+(tex-def-prim "\\ " (lambda () (emit #\space)))
+(tex-def-prim "\\%" (lambda () (emit "%")))
+(tex-def-prim "\\&" (lambda () (emit "&amp;")))
+(tex-def-prim "\\@" (lambda () (emit "@")))
+(tex-def-prim "\\_" (lambda () (emit "_")))
+(tex-def-prim "\\$" (lambda () (emit "$")))
+(tex-def-prim (string #\\ #\newline) emit-newline)
+
+;TeX logos
+
+(let* ((TeX *tex-logo*)
+       (AmS (string-append "<span style=\"font-family: cursive;\">"
+              "A"
+              "<span style=\""
+              "position: relative; "
+              "top: 0.5ex; "
+              "margin-left: -.1667em; "
+              "margin-right: -.075em"
+              "\">M</span>"
+              "S</span>"))
+       (Bib (string-append "B" "<span style=\""
+              "text-transform: uppercase"
+              "\"><small>ib</small></span>"))
+       (ConTeXt (string-append "Con"
+                  TeX
+                  "t"))
+       (LaTeX (string-append "L" "<span style=\""
+                "position: relative; "
+                "bottom: 0.3ex; "
+                "margin-left: -0.36em; "
+                "margin-right: -0.15em; "
+                "text-transform: uppercase"
+                "\"><small>a</small></span>"
+                TeX))
+       (Xe (string-append "X" "<span style=\""
+              "text-transform: uppercase; "
+              "position: relative; "
+              "top: 0.5ex; "
+              "margin-left: -0.125em; "
+              "margin-right: -0.1667em"
+              "\">&#x18e;</span>"))
+       (thinspace (string-append "<span style=\""
+                  "margin-left: 0.1667em"
+                  "\">&zwnj;</span>"))
+       (_2e (string-append "<span style=\""
+              "margin-left: .05em"
+              "\">2<span>"
+              "<span style=\""
+              "position: relative; "
+              "top: .5ex"
+              "\">&epsilon;</span>"))
+       (MF (string-append "<span style=\""
+             "font-family: sans-serif"
+             "\">METAFONT</span>")))
+  (tex-def-prim "\\AmSTeX" (lambda () (emit AmS) (emit #\-) (emit TeX)))
+  (tex-def-prim "\\BibTeX" (lambda () (emit Bib) (emit TeX)))
+  (tex-def-prim "\\ConTeXt" (lambda () (emit ConTeXt)))
+  (tex-def-prim "\\eTeX" (lambda () (emit "&epsilon;-") (emit TeX)))
+  (tex-def-prim "\\LaTeX" (lambda () (emit LaTeX)))
+  (tex-def-prim "\\LaTeXe" (lambda () (emit LaTeX) (emit _2e)))
+  (tex-def-prim "\\MF" (lambda () (emit MF)))
+  (tex-def-prim "\\TeX" (lambda () (emit TeX)))
+  (tex-def-prim "\\XeLaTeX" (lambda () (emit Xe) (emit thinspace) (emit LaTeX)))
+  (tex-def-prim "\\XeTeX" (lambda () (emit Xe) (emit TeX))))
+;ignoring these
+
+(tex-let-prim "\\htmladvancedentities" "\\TIIPrelax")
+(tex-let-prim "\\displaystyle" "\\TIIPrelax")
+(tex-let-prim "\\textstyle" "\\TIIPrelax")
+(tex-let-prim "\\endsloppypar" "\\TIIPrelax")
+(tex-let-prim "\\frenchspacing" "\\TIIPrelax")
+;(tex-let-prim "\\noindent" "\\TIIPrelax")
+(tex-let-prim "\\oldstyle" "\\TIIPrelax")
+(tex-let-prim "\\protect" "\\TIIPrelax")
+(tex-let-prim "\\raggedbottom" "\\TIIPrelax")
+(tex-let-prim "\\raggedright" "\\TIIPrelax")
+;(tex-let-prim "\\rm" "\\TIIPrelax")
+(tex-let-prim "\\sloppy" "\\TIIPrelax")
+(tex-let-prim "\\sloppypar" "\\TIIPrelax")
+(tex-let-prim "\\beginpackages" "\\TIIPrelax")
+(tex-let-prim "\\endpackages" "\\TIIPrelax")
+
+;probably shdn't be ignoring these
+
+(tex-let-prim "\\normalfont" "\\TIIPrelax")
+(tex-let-prim "\\textnormal" "\\TIIPrelax")
+;(tex-let-prim "\\textrm" "\\TIIPrelax")
+(tex-let-prim "\\unskip" "\\TIIPrelax")
+
+;(tex-def-prim "\\font" eat-till-eol) ;kludge
+
+(tex-def-prim "\\cline" get-group)
+(tex-def-prim "\\externalref" get-group)
+(tex-def-prim "\\GOBBLEARG" get-group)
+(tex-def-prim "\\hyphenation" get-group)
+(tex-def-prim "\\newcounter" get-group)
+(tex-def-prim "\\newlength" get-group)
+(tex-def-prim "\\hphantom" get-group)
+(tex-def-prim "\\vphantom" get-group)
+(tex-def-prim "\\phantom" get-group)
+(tex-def-prim "\\pagenumbering" get-group)
+(tex-def-prim "\\pagestyle" get-group)
+(tex-def-prim "\\raisebox" get-group)
+(tex-def-prim "\\thispagestyle" get-group)
+(tex-def-prim "\\manpagesection" get-group)
+(tex-def-prim "\\manpagedescription" get-group)
+(tex-def-prim "\\lstset" get-group)
+
+(tex-def-prim "\\externallabels" (lambda () (get-group) (get-group)))
+(tex-let-prim "\\markboth" "\\externallabels")
+
+;\advance
+
+(tex-def-prim "\\columnsep" eat-dimen)
+(tex-def-prim "\\columnseprule" eat-dimen)
+(tex-def-prim "\\evensidemargin" eat-dimen)
+(tex-def-prim "\\fboxsep" eat-dimen)
+(tex-def-prim "\\headsep" eat-dimen)
+(tex-def-prim "\\itemsep" eat-dimen)
+(tex-def-prim "\\leftcodeskip" eat-dimen)
+(tex-def-prim "\\lower" eat-dimen)
+(tex-def-prim "\\oddsidemargin" eat-dimen)
+(tex-def-prim "\\parsep" eat-dimen)
+(tex-def-prim "\\parskip" eat-dimen)
+(tex-def-prim "\\raise" eat-dimen)
+(tex-def-prim "\\rightcodeskip" eat-dimen)
+(tex-def-prim "\\sidemargin" eat-dimen)
+(tex-def-prim "\\textheight" eat-dimen)
+(tex-def-prim "\\topmargin" eat-dimen)
+(tex-def-prim "\\topsep" eat-dimen)
+(tex-def-prim "\\vertmargin" eat-dimen)
+
+(tex-def-prim "\\magstep" get-token)
+(tex-def-prim "\\textfont" get-token)
+(tex-def-prim "\\scriptfont" get-token)
+(tex-def-prim "\\scriptscriptfont" get-token)
+
+(tex-def-prim "\\addtolength" (lambda () (get-token) (get-token)))
+(tex-let-prim "\\addvspace" "\\vspace")
+(tex-let-prim "\\setlength" "\\addtolength")
+(tex-let-prim "\\settowidth" "\\addtolength")
+(tex-let-prim "\\hookaction" "\\addtolength")
+
+(tex-def-prim "\\enlargethispage"
+              (lambda () (eat-star) (get-group)))
+
+(tex-def-prim "\\parbox"
+  (lambda () (get-bracketed-text-if-any) (get-group)))
+
+(tex-def-prim "\\ProvidesFile"
+              (lambda () (get-group) (get-bracketed-text-if-any)))
+
+(tex-def-prim "\\DeclareGraphicsRule"
+              (lambda () (get-group) (get-group) (get-group) (get-group)))
+
+(tex-def-prim "\\makebox"
+  (lambda () (get-bracketed-text-if-any) (get-bracketed-text-if-any)))
+
+(tex-let-prim "\\framebox" "\\makebox")
+
+(tex-def-prim "\\rule"
+  (lambda ()
+    (get-bracketed-text-if-any) (get-group) (get-group)))
+
+(tex-def-prim "\\GOBBLEOPTARG" get-bracketed-text-if-any)
+(tex-def-prim "\\nolinebreak" get-bracketed-text-if-any)
+(tex-def-prim "\\nopagebreak" get-bracketed-text-if-any)
+
+(tex-def-prim "\\hyphenchar"
+              (lambda ()
+                (get-token) (eat-integer)))
+
+(tex-def-prim "\\skewchar"
+              (lambda ()
+                (get-token) (eat-integer)))
+
+(tex-def-prim "\\usepackage"
+              (lambda () (get-bracketed-text-if-any) (get-group)
+                (probably-latex)))
+
+(tex-def-prim "\\readindexfile"
+              (lambda () (get-token) (do-inputindex #f)))
+
+(tex-let-prim "\\colophon" "\\htmlcolophon")
+(tex-let-prim "\\path" "\\verb")
+(tex-let-prim "\\par" "\\endgraf")
+(tex-let-prim "\\u" "\\`")
+(tex-let-prim "\\vbox" "\\hbox")
+(tex-let-prim "\\endabstract" "\\endquote")
+(tex-let-prim "\\mbox" "\\hbox")
+(tex-let-prim "\\supereject" "\\eject")
+(tex-let-prim "\\dosupereject" "\\eject")
+(tex-let-prim "\\endgroup" "\\egroup")
+(tex-let-prim "\\begingroup" "\\bgroup")
+(tex-let-prim "\\ldots" "\\dots")
+(tex-let-prim "\\documentstyle" "\\documentclass")
+;(tex-let-prim "\\edef" "\\def")
+(tex-let-prim "\\/" "\\TIIPrelax")
+(tex-let-prim "\\leavevmode" "\\TIIPrelax")
+(tex-let-prim "\\space" "\\ ")
+(tex-let-prim "\\quotation" "\\quote")
+(tex-let-prim "\\endquotation" "\\endquote")
+;(tex-let-prim "\\xdef" "\\gdef")
+(tex-let-prim "\\TIIPdate" "\\today")
+(tex-let-prim "\\schemeinput" "\\scminput")
+
+;aliases
+
+(tex-let-prim "\\obeywhitespaces" "\\obeywhitespace")
+(tex-let-prim "\\ensuremath" "\\mathg")
+(tex-let-prim "\\epsffile" "\\epsfbox")
+(tex-let-prim "\\htmlimgformat" "\\htmlimageformat")
+(tex-let-prim "\\p" "\\verb")
+(tex-let-prim "\\ttraggedright" "\\tt")
+(tex-let-prim "\\ttfamily" "\\tt")
+(tex-let-prim "\\htmladdnormallink" "\\urlp")
+(tex-let-prim "\\htmladdnormallinkfoot" "\\urlp")
+(tex-let-prim "\\pagehtmlref" "\\htmlref")
+(tex-let-prim "\\circledR" "\\textregistered")
+(tex-let-prim "\\registered" "\\textregistered")
+(tex-let-prim "\\scmconstant" "\\scmbuiltin")
+(tex-let-prim "\\setbuiltin" "\\scmbuiltin")
+(tex-let-prim "\\setconstant" "\\scmconstant")
+(tex-let-prim "\\setkeyword" "\\scmkeyword")
+(tex-let-prim "\\setvariable" "\\scmvariable")
+(tex-let-prim "\\unssetspecialsymbol" "\\unscmspecialsymbol")
+(tex-let-prim "\\setspecialsymbol" "\\scmspecialsymbol")
+(tex-let-prim "\\scmp" "\\scm")
+(tex-let-prim "\\q" "\\scm")
+(tex-let-prim "\\scheme" "\\scm")
+(tex-let-prim "\\tagref" "\\ref")
+(tex-let-prim "\\numfootnote" "\\numberedfootnote")
+(tex-let-prim "\\f" "\\numberedfootnote")
+(tex-let-prim "\\newpage" "\\eject")
+(tex-let-prim "\\clearpage" "\\eject")
+(tex-let-prim "\\cleardoublepage" "\\eject")
+(tex-let-prim "\\htmlpagebreak" "\\eject")
+(tex-let-prim "\\typeout" "\\message")
+(tex-let-prim "\\unorderedlist" "\\itemize")
+(tex-let-prim "\\li" "\\item")
+(tex-let-prim "\\htmlstylesheet" "\\inputcss")
+(tex-let-prim "\\hr" "\\hrule")
+(tex-let-prim "\\htmlrule" "\\hrule")
+(tex-let-prim "\\numberedlist" "\\enumerate")
+(tex-let-prim "\\orderedlist" "\\enumerate")
+(tex-let-prim "\\endunorderedlist" "\\enditemize")
+(tex-let-prim "\\endnumberedlist" "\\endenumerate")
+(tex-let-prim "\\endorderedlist" "\\endenumerate")
+(tex-let-prim "\\newline" "\\break")
+
+;obsoletisms
+
+(tex-let-prim "\\gifdef" "\\imgdef")
+(tex-let-prim "\\schemeeval" "\\eval")
+(tex-let-prim "\\gifpreamble" "\\imgpreamble")
+(tex-let-prim "\\mathpreamble" "\\imgpreamble")
+(tex-let-prim "\\scmverbatim" "\\scm")
+(tex-let-prim "\\scmfilename" "\\verbwritefile")
+(tex-let-prim "\\scmwritefile" "\\verbwritefile")
+(tex-let-prim "\\verbfilename" "\\verbwritefile")
+(tex-let-prim "\\scmfileonly" "\\verbwrite")
+(tex-let-prim "\\scmverbatimfile" "\\scminput")
+(tex-let-prim "\\scmverbatiminput" "\\scminput")
+(tex-let-prim "\\scmwrite" "\\verbwrite")
+(tex-let-prim "\\scmfile" "\\scmdribble")
+(tex-let-prim "\\scmverb" "\\scm")
+(tex-let-prim "\\verbinput" "\\verbatiminput")
+(tex-let-prim "\\verbatimfile" "\\verbatiminput")
+(tex-let-prim "\\verbescapechar" "\\verbatimescapechar")
+(tex-let-prim "\\setverbatimescapechar" "\\verbescapechar")
+(tex-let-prim "\\nohtmlmathimg" "\\dontuseimgforhtmlmath")
+(tex-let-prim "\\nohtmlmathintextimg" "\\dontuseimgforhtmlmathintext")
+(tex-let-prim "\\nohtmlmathdisplayimg" "\\dontuseimgforhtmlmathdisplay")
+(tex-let-prim "\\textdegree" "\\degree")
+(tex-let-prim "\\texttrademark" "\\TM")
+(tex-let-prim "\\trademark" "\\TM")
+(tex-let-prim "\\writetotoc" "\\writenumberedtocline") ;obs
+
+(tex-let-prim "\\n" "\\noindent")
+
+;for use within inner \eval
+
+(tex-let-prim "\\Lbackslash" "\\char`\\\\")
+(tex-let-prim "\\Ltilde" "\\char`\\~")
+(tex-let-prim "\\Llbrace" "\\char`\\{")
+(tex-let-prim "\\Lrbrace" "\\char`\\}")
+(tex-let-prim "\\Lsup" "\\char`\\^")
+(tex-let-prim "\\Lsub" "\\char`\\_")
+
+(define tex2page
+  (lambda (tex-file)
+    (unless (= *write-log-index* 0)
+      ;nested call to tex2page
+      (newline))
+    (when (or (not tex-file) (string=? tex-file ""))
+      (set! tex-file "--missing-arg"))
+    (fluid-let ((*afterassignment* #f)
+                (*afterpar* '())
+                (*afterbye* '())
+                (*aux-dir* #f)
+                (*aux-dir/* "")
+                (*aux-port* #f)
+                ;
+                (*bib-aux-port* #f)
+                (*bibitem-num* 0)
+                ;
+                (*color-names* '())
+                (*comment-char* #\%)
+                (*css-port* #f)
+                (*current-tex2page-input* #f) ;will be set by tex2page-file
+                (*current-source-file* #f) ; ''
+                ;
+                (*display-justification* "center")
+                (*doctype* *doctype*)
+                (*dotted-counters* #f)
+                (*dumping-nontex?* #f)
+                ;
+                (*equation-number* #f)
+                (*equation-numbered?* #t)
+                (*equation-position* 0)
+                (*esc-char* #\\ )
+                (*esc-char-std* #\\ )
+                (*esc-char-verb* #\|)
+                (*eval-file-count* 0)
+                (*eval-for-tex-only?* #f)
+                (*external-label-tables* (make-table 'equ string=?))
+                ;
+                (*footnote-list* '())
+                (*footnote-sym* 0)
+                ;
+                (*global-texframe* #f)
+                (*graphics-file-extensions* '(".eps"))
+                ;
+                (*html* (current-output-port))
+                (*html-head* '())
+                (*html-only* 0)
+                (*html-page* #f)
+                (*html-page-count* 0)
+                ;
+                (*img-file-count* 0)
+                (*img-file-tally* 0)
+                (*imgdef-file-count* 0)
+                (*imgpreamble* "")
+                (*imgpreamble-inferred* '())
+                (*in-alltt?* #f)
+                (*in-display-math?* #f)
+                (*in-para?* #f)
+                (*in-small-caps?* #f)
+                (*includeonly-list* #t)
+                (*index-table* (make-table))
+                (*index-count* 0)
+                (*index-page* #f)
+                (*index-port* #f)
+                (*infructuous-calls-to-tex2page* 0)
+                (*input-line-no* 0) ;will be set by tex2page-file
+                (*input-streams* (make-table))
+                (*inputting-boilerplate?* #f)
+                (*inside-appendix?* #f)
+                ;
+                (*jobname* "texput")
+                ;
+                (*label-port* #f)
+                (*label-source* #f)
+                (*label-table* (make-table 'equ string=?))
+                (*last-modification-time* #f)
+                (*last-page-number* -1)
+                (*latex-probability* 0)
+                (*ligatures?* #t)
+                (*loading-external-labels?* #f)
+                (*log-file* #f)
+                (*log-port* #f)
+                ;
+                (*main-tex-file* #f)
+                (*math-delim-left* #f)
+                (*math-delim-right* #f)
+                (*math-height* 0)
+                (*math-mode?* #f)
+                (*mfpic-file-num* #f)
+                (*mfpic-file-stem* #f)
+                (*mfpic-port* #f)
+                (*missing-eps-files* '())
+                (*missing-pieces* '())
+                (*mp-files* '())
+                ;
+                (*not-processing?* #f)
+                ;
+                (*outer?* #t)
+                (*output-streams* (make-table))
+                (*outputting-external-title?* #f)
+                (*outputting-to-non-html?* #f)
+                ;
+                (*package* *this-package*) ;place-holder for CL
+                ;
+                (*reading-control-sequence?* #f)
+                (*recent-node-name* #f)
+                ;
+                (*scm-dribbling?* #f)
+                (*scm-keywords* #f)
+                (*scm-special-symbols* #f)
+                (*scm-builtins* #f)
+                (*scm-variables* #f)
+                (*section-counter-dependencies* #f)
+                (*section-counters* (make-table))
+                ;(*slatex-like-comments?* #f)
+                (*slatex-math-escape* #f)
+                (*source-changed-since-last-run?* #f)
+                (*stylesheets* '())
+                (*subjobname* #f)
+                ;
+                (*tabular-stack* '())
+                (*temp-string-count* 0)
+                (*temporarily-use-utf8-for-math?* #f)
+                (*tex2page-inputs* (path-to-list (or (getenv "TEX2PAGEINPUTS")
+                                                     (getenv "TIIPINPUTS"))))
+                (*tex-env* '())
+                (*tex-format* ':plain)
+                (*tex-if-stack* '())
+                (*tex-like-layout?* *tex-like-layout?*)
+                (*tex-prog-name* *tex-prog-name*)
+                (*title* #f)
+                (*toc-list* '())
+                (*toc-page* #f)
+                ;
+                (*unresolved-xrefs* '())
+                (*using-bibliography?* #f)
+                (*using-chapters?* #f)
+                (*using-index?* #f)
+                ;
+                (*verb-display?* #f)
+                (*verb-port* #f)
+                (*verb-visible-space?* #f)
+                (*verb-written-files* '())
+                ;
+                (*write-log-index* 0)
+                (*write-log-possible-break?* #f))
+      (initialize-globals)
+      (set! *main-tex-file* (actual-tex-filename
+                              tex-file (check-input-file-timestamp? tex-file)))
+      (write-log "This is TeX2page, Version ")
+      (write-log *tex2page-version*)
+      (write-log #\space) (write-log #\()
+      (write-log *scheme-version*)
+      (write-log #\,) (write-log #\space)
+      (write-log *operating-system*)
+      (write-log #\))
+      (write-log ':separation-newline)
+      (cond (*main-tex-file*
+             (set! *subjobname* *jobname*)
+             ;(initialize-globals)
+             (set! *html-page* (string-append *aux-dir/* *jobname*
+                                              *output-extension*))
+             (ensure-file-deleted *html-page*)
+             (set! *html* (open-output-file *html-page*))
+             (do-start)
+             (fluid-let ((*html-only* (+ *html-only* 1)))
+               (tex2page-file-if-exists (file-in-home ".tex2page.t2p"))
+               (tex2page-file-if-exists ".tex2page.t2p")
+               (cond ((actual-tex-filename
+                        (string-append *jobname* ".t2p") #f)
+                      => tex2page-file)))
+             (unless (eqv? (tex2page-file *main-tex-file*)
+                           ':encountered-bye)
+               (insert-missing-end))
+             (do-bye))
+            (else (tex2page-help tex-file)))
+      (output-stats))))
+
+(define main
+  (lambda args
+    (tex2page
+     (and (>= (length args) 1)
+          (list-ref args 0)))))
+
+; vi:ft=scheme
diff --git b/document/unicode.tex a/document/unicode.tex
index adfabeb..70e79d1 100644
--- b/document/unicode.tex
+++ a/document/unicode.tex
@@ -1,8 +1,6 @@
 \chapter{Unicode}
 \label{unicodechapter}
 
-\newcommand{\latingreek}[1]{\texonly\mathit{#1}\endtexonly\htmlonly\textit{#1}\endhtmlonly}
-
 The procedures exported by the \defrsixlibrary{unicode}
 library provide access to some aspects
 of the Unicode semantics for characters and strings:
@@ -38,8 +36,12 @@ Finally, if the character has a case-folded character,
 then {\cf char-foldcase} returns that character.
 Otherwise the character returned is the same
 as the argument.
-For Turkic characters \.I ({\tt \#\backwhack{}x130})
-and \i{} ({\tt \#\backwhack{}x131}),
+For Turkic characters
+\texonly\.I\endtexonly\htmlonly\rawhtml&#x130;\endrawhtml\endhtmlonly
+~({\tt \#\backwhack{}x130})
+and
+\texonly\i{}\endtexonly\htmlonly\rawhtml&#x131;\endrawhtml\endhtmlonly
+~({\tt \#\backwhack{}x131}),
 {\cf char-foldcase} behaves as the identity function; otherwise 
 {\cf char-foldcase} is the
 same as {\cf char-downcase} composed with {\cf char-upcase}.
@@ -180,8 +182,8 @@ The {\cf string-upcase} procedure converts a string to upper case;
   string-foldcase} procedure converts the string to its case-folded
 counterpart, using the full case-folding mapping, but without the
 special mappings for Turkic languages.  The {\cf string-titlecase}
-procedure converts the first cased character of each word via {\cf
-  char-titlecase}, and downcases all other cased characters.
+procedure converts the first cased character of each word,
+and downcases all other cased characters.
 
 \begin{scheme}
 (string-upcase "Hi") \ev "HI"
@@ -196,27 +198,26 @@ procedure converts the first cased character of each word via {\cf
 (string-downcase "$\Sigma$") \ev "$\sigma$"
 
 ; \textrm{Chi Alpha Omicron Sigma}:
-(string-upcase "$\latingreek{XAO}\Sigma$") \ev "$\latingreek{XAO}\Sigma$" 
-(string-downcase "$\latingreek{XAO}\Sigma$") \ev "$\chi\alpha{}o\varsigma$"
-(string-downcase "$\latingreek{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\varsigma$"
-(string-downcase "$\latingreek{XAO}\Sigma~\Sigma$") \ev "$\chi\alpha{}o\varsigma~\sigma$"
-(string-foldcase "$\latingreek{XAO}\Sigma\Sigma$") \ev "$\chi\alpha{}o\sigma\sigma$"
-(string-upcase "$\chi\alpha{}o\varsigma$") \ev "$\latingreek{XAO}\Sigma$"
-(string-upcase "$\chi\alpha{}o\sigma$") \ev "$\latingreek{XAO}\Sigma$"
+(string-upcase "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly") \ev "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly"
+(string-downcase "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly") \ev "\texonly$\chi\alpha{}o\varsigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C2;\endrawhtml\endhtmlonly"
+(string-downcase "\texonly$\mathit{XAO}\Sigma\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;&#x03A3;\endrawhtml\endhtmlonly") \ev "\texonly$\chi\alpha{}o\sigma\varsigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C3;&#x03C2;\endrawhtml\endhtmlonly"
+(string-downcase "\texonly$\mathit{XAO}\Sigma~\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3; &#x03A3;\endrawhtml\endhtmlonly") \ev "\texonly$\chi\alpha{}o\varsigma~\sigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C2; &#x03C3;\endrawhtml\endhtmlonly"
+(string-foldcase "\texonly$\mathit{XAO}\Sigma\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;&#x03A3;\endrawhtml\endhtmlonly") \ev "\texonly$\chi\alpha{}o\sigma\sigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C3;&#x03C3;\endrawhtml\endhtmlonly"
+(string-upcase "\texonly$\chi\alpha{}o\varsigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C2;\endrawhtml\endhtmlonly") \ev "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly"
+(string-upcase "\texonly$\chi\alpha{}o\sigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C3;\endrawhtml\endhtmlonly") \ev "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly"
 
 (string-titlecase "kNock KNoCK")
 \ev "Knock Knock"
 (string-titlecase "who's there?")
 \ev "Who's There?"
-(string-titlecase "r6rs") \ev "R6Rs"
-(string-titlecase "R6RS") \ev "R6Rs"%
+(string-titlecase "r6rs") \ev "R6rs"
+(string-titlecase "r6rs") \ev "R6rs"%
 \end{scheme}
 
 \begin{note}
   The case mappings needed for implementing these procedures
   can be extracted from {\cf UnicodeData.txt}, {\cf
-    SpecialCasing.txt}, {\cf WordBreakProperty.txt} 
-  (the ``MidLetter'' property partly defines case-ignorable characters), 
+    SpecialCasing.txt}, {\cf WordBreakProperty.txt},
   and {\cf CaseFolding.txt} from the Unicode Consortium.
 
   Since these procedures are locale-independent, they may not
@@ -248,7 +249,7 @@ operate on the case-folded versions of the strings.
 \ev \schtrue
 (string-ci=? "Stra\ss{}e" "STRASSE")
 \ev \schtrue
-(string-ci=? "$\latingreek{XAO}\Sigma$" "$\chi\alpha{}o\sigma$")
+(string-ci=? "\texonly$\mathit{XAO}\Sigma$\endtexonly\htmlonly\rawhtml&#x03A7;&#x0391;&#x039F;&#x03A3;\endrawhtml\endhtmlonly" "\texonly$\chi\alpha{}o\sigma$\endtexonly\htmlonly\rawhtml&#x03C7;&#x03B1;&#x03BF;&#x03C3;\endrawhtml\endhtmlonly")
 \ev \schtrue%
 \end{scheme}
 
diff --git b/model/README a/model/README
index 1f49712..1573a4b 100644
--- b/model/README
+++ a/model/README
@@ -1,35 +1,35 @@
 This directory contains the PLT Redex implementation of the
 R6RS operational semantics and a test suite for the
-semantics. It runs in DrScheme v371 (and possibly others as
-well).
+semantics. It runs in DrScheme v4.x.
 
-This version of the semantics matches the r5.92rs report and
-the figures in it were automatically generated from
-r6rs.scm.
+This version of the semantics matches the r5.92rs report.
 
 == r6rs.scm: the semantics itself.
 
 == r6rs-tests.scm: the test suite for the semantics. Use:
 
-   mzscheme -mvqt r6rs-tests.scm -e '(run-tests)'
+   mzscheme -t r6rs-tests.scm -m
 
    to run the tests and see a single period shown per test
    run (each test that explores more than 100 states shows a
    colon for each 100 states it explores). To see a more
    verbose output (that shows each test), use:
 
-   mzscheme -mvqt r6rs-tests.scm -e '(run-tests #t)'
+   mzscheme -t r6rs-tests.scm -m #t
 
 == show-examples.scm: use this file to explore particular
    examples in a GUI. Its content shows how to use it and
    gives a few examples. Either run it in DrScheme's module
    language, or like this from the commandline:
 
-   mred -qu show-examples.scm
+   mred show-examples.scm
 
 == test.scm: test suite infrastructure
 
 For details on PLT Redex see:
 
-  http://www.cs.uchicago.edu/~robby/plt-redex/
+  http://redex.plt-scheme.org/
+
+Although note that this version of the semantics uses an 
+old version of Redex.
 
diff --git b/model/r6rs-tests.scm a/model/r6rs-tests.scm
index 3e742f6..dabec0b 100644
--- b/model/r6rs-tests.scm
+++ a/model/r6rs-tests.scm
@@ -2,7 +2,7 @@
   (require (lib "match.ss")
            (lib "list.ss")
            (lib "etc.ss")
-           (planet "reduction-semantics.ss" ("robby" "redex.plt" 3 10))
+           (planet "reduction-semantics.ss" ("robby" "redex.plt" 4))
            "test.scm"
            "r6rs.scm")
   
@@ -252,7 +252,12 @@
      (make-r6test '(store () (letrec ([x 1]) (dynamic-wind (lambda () 0) (lambda () (set! x 2)) (lambda () 1))))
                   (list '(unknown "unspecified result")))
      (make-r6test '(store () (letrec ([x 1]) (begin (dynamic-wind (lambda () 0) (lambda () (set! x 2)) (lambda () 1)) 5)))
-                  (list '(store ((lx-x 2)) (values 5))))))
+                  (list '(store ((lx-x 2)) (values 5))))
+     
+     ;; letrec
+     ;; bug one that Casey found
+     (make-r6test '(store () (letrec* ([y 1] [x (set! y 2)]) y))
+                  (list '(unknown "unspecified result")))))
   
   (define basic-form-tests
     (list
@@ -894,7 +899,30 @@
                         (lambda (x) 17))))
                   (list '(store ((lx-g (lambda (y) y))
                                  (lx-f (lambda (x) (lx-g 1))))
-                           (values 17))))))
+                           (values 17))))
+     
+     (make-r6test '(store () ((lambda (x)
+                                (letrec ([x 1]) 
+                                  1))
+                              1))
+                  (list '(store ((lx-x 1)) (values 1))))
+     
+     (make-r6test '(store () ((lambda (x)
+                                (letrec* ([x 1]) 
+                                  1))
+                              1))
+                  (list '(store ((lx-x 1)) (values 1))))
+     
+     (make-r6test '(store () 
+                     (letrec ((x 1))
+                       ((lambda (f) (letrec ([x 3]) (f)))
+                        (lambda () x))))
+                  (list '(store ((lx-x 1) (lx-x1 3)) (values 1))))
+     (make-r6test '(store () 
+                     (letrec ((x 1))
+                       ((lambda (f) (letrec* ([x 3]) (f)))
+                        (lambda () x))))
+                  (list '(store ((lx-x 1) (lx-x1 3)) (values 1))))))
   
   (define mv-tests
     (list
@@ -1886,7 +1914,7 @@ of digits with deconv-base
                        (k (lambda (x) x))
                        (k 2)))
                   (list '(uncaught-exception (make-cond "reinvoked continuation of letrec init"))
-                        '(store ((lx-k (lambda (x2) x2))) (values 2))))
+                        '(store ((lx-k (lambda (x3) x3))) (values 2))))
      
      (make-r6test '(store ()
                      ((lambda (flag)
@@ -1930,7 +1958,7 @@ of digits with deconv-base
                       #t))
                   (list '(uncaught-exception (make-cond "reinvoked continuation of letrec init"))
                         '(uncaught-exception (make-cond "can't take car of non-pair"))
-                        '(store ((lx-k (lambda (x2) x2)) (lx-x 'nothing-doing)) (values 2))))
+                        '(store ((lx-k (lambda (x3) x3)) (lx-x 'nothing-doing)) (values 2))))
      
      (make-r6test '(store ()
                      ((lambda (flag)
@@ -2017,7 +2045,7 @@ of digits with deconv-base
   
   (define the-tests (apply append (map cadr the-sets)))
   
-  (define run-tests
+  (define main
     (opt-lambda ([verbose? #f])
       (time
        (let ()
@@ -2047,15 +2075,12 @@ of digits with deconv-base
              (printf "~a tests, ~a tests failed\n" test-count failed-tests))
          (printf "verified that ~a terms are p*\n" verified-terms)))
       (collect-garbage) (collect-garbage) (collect-garbage)
-      (printf "mem ~s\n" (current-memory-use))
-      (let ([v (make-vector 10)])
-        (vector-set-performance-stats! v)
-        (printf "ht searches    ~a\nslots searched ~a\n" (vector-ref v 8) (vector-ref v 9)))))
+      (printf "mem ~s\n" (current-memory-use))))
   
-  (provide run-tests
+  (provide main
            the-tests
            
-           ;; the test and the expected are not compared with equal?.
+           ;; the 'test' and the 'expected' are not compared with equal?.
            ;; instead, the result of running the test is first simplified
            ;; by substituting all of the variables with a colon in their
            ;; names thru the term, and then the results from the test are
diff --git b/model/r6rs.scm a/model/r6rs.scm
index 92f525c..34c3931 100644
--- b/model/r6rs.scm
+++ a/model/r6rs.scm
@@ -1,6 +1,6 @@
 
 (module r6rs mzscheme
-  (require (planet "reduction-semantics.ss" ("robby" "redex.plt" 3 10))
+  (require (planet "reduction-semantics.ss" ("robby" "redex.plt" 4))
            (lib "plt-match.ss"))
   
   (provide lang 
@@ -27,134 +27,163 @@
     ;; these are only used in the figures
     #''ignore)
 
-  (define lang
-    (language
-     (p* (store (sf ...) es) (uncaught-exception v) (unknown string))
-     (a* (store (sf ...) (values v ...)) (uncaught-exception v) (unknown string))
-     (r* (values r*v ...) exception unknown)
-     (r*v  pair null 'sym sqv condition procedure)
-     (sf (x v) (x bh) (pp (cons v v)))
-     
-     (es 'seq 'sqv '()
-         (begin es es ...) (begin0 es es ...) (es es ...)
-         (if es es es) (set! x es) x
-         nonproc pproc (lambda f es es ...)
-         (letrec ([x es] ...) es es ...) 
-         (letrec* ([x es] ...) es es ...)
-         
-         ;; intermediate states
-         (dw x es es es) 
-         (throw x es)
-         unspecified
-         (handlers es ... es)
-         (l! x es)
-         (reinit x))
-     (f (x ...)
-        (x x ... dot x)
-        x)
-     
-     (s seq () sqv sym)
-     (seq (s s ...) (s s ... dot sqv) (s s ... dot sym))
-     (sqv n #t #f)
-
-     (p (store (sf ...) e))
-     (e (begin e e ...) (begin0 e e ...)
-        (e e ...) (if e e e)
-        (set! x e) (handlers e ... e)
-        x nonproc proc (dw x e e e)
+  (define-language lang
+    (p* (store (side-condition (sf_1 ...)
+                               (unique? (map car (term (sf_1 ...)))))
+               es)
+        (uncaught-exception v)
+        (unknown string))
+    (a* (store (side-condition (sf_1 ...)
+                               (unique? (map car (term (sf_1 ...)))))
+               (values v ...))
+        (uncaught-exception v)
+        (unknown string))
+    (r* (values r*v ...) exception unknown)
+    (r*v  pair null 'sym sqv condition procedure)
+    (sf (x v) (x bh) (pp (cons v v)))
+    
+    (es 'seq 'sqv '()
+        (begin es es ...) (begin0 es es ...) (es es ...)
+        (if es es es) (set! x es) x
+        nonproc pproc (lambda f es es ...)
+        (letrec (side-condition ([x_1 es] ...)
+                                (unique? (term (x_1 ...))))
+          es es ...) 
+        (letrec* (side-condition ([x_1 es] ...)
+                                 (unique? (term (x_1 ...))))
+                 es es ...)
+        
+        ;; intermediate states
+        (dw x es es es) 
+        (throw x es)
         unspecified
-        (letrec ([x e] ...) e e ...)
-        (letrec* ([x e] ...) e e ...)
+        (handlers es ... es)
         (l! x es)
         (reinit x))
-     (v nonproc proc)
-     (nonproc pp null 'sym sqv (make-cond string))
-     
-     (proc (lambda f e e ...) pproc (throw x e))
-     (pproc aproc proc1 proc2 list dynamic-wind apply values)
-     (proc1 null? pair? car cdr call/cc procedure? condition? raise*)
-     (proc2 cons consi set-car! set-cdr! eqv? call-with-values with-exception-handler)
-     (aproc + - / *)
-     (raise* raise-continuable raise)
-     
-     ; pair pointers, both mutable and immutable
-     (pp ip mp)
-     (ip (variable-prefix ip))
-     (mp (variable-prefix mp))
-     
-     (sym (variable-except dot))
-     
-     (x (side-condition 
-         (name var_none
-               (variable-except 
-                dot                         ; the . in dotted pairs
-                lambda if loc set!          ; core syntax names
-                quote
-                begin begin0
-                
-                null                      ; non-function values
-                unspecified
-                pair closure
-                
-                error                       ; signal an error
-                
-                letrec letrec* l! reinit
-                
-                procedure? condition?
-                cons consi pair? null? car cdr       ; list functions
-                set-car! set-cdr! list
-                + - * /                          ; math functions
-                call/cc throw dw dynamic-wind  ; call/cc functions
-                values call-with-values              ; values functions
-                apply eqv?
-                
-                with-exception-handler handlers
-                raise-continuable raise))
-         (not (pp? (term var_none)))))
-     
-     (n number)
-     
-     (P (store (sf ...) E*))
-     
-     (E (in-hole F (handlers proc ... E*)) (in-hole F (dw x e E* e)) F)
-     (E* (hole multi) E)
-     (Eo (hole single) E)
-     
-     (F hole (v ... Fo v ...) (if Fo e e) (set! x Fo)  
-        (begin F* e e ...) (begin0 F* e e ...) 
-        (begin0 (values v ...) F* e ...) (begin0 unspecified F* e ...)
-        (call-with-values (lambda () F* e ...) v)
-        (l! x Fo))
-
-     (F* (hole multi) F)
-     (Fo (hole single) F)
-     
-     ;; all of the one-layer contexts that "demand" their values, 
-     ;; (maybe just "demand" it enough to ensure it is the right # of values)
-     ;; which requires unspecified to blow up.
-     (U (v ... hole v ...) (if hole e e) (set! x hole) 
-        (call-with-values (lambda () hole) v))
-        
-     ;; everything except exception handler bodies
-     (PG (store (sf ...) G))
-     (G (in-hole F (dw x e G e))
-        F)
-     
-     ;; everything except dw
-     (H (in-hole F (handlers proc ... H)) F)
-     
-     (S hole (begin e e ... S es ...) (begin S es ...)
-        (begin0 e e ... S es ...) (begin0 S es ...)
-        (e ... S es ...) (if S es es) (if e S es) (if e e S)
-        (set! x S) (handlers s ... S es ... es) (handlers s ... S)
-        (throw x e) 
-        (lambda f S es ...) (lambda f e e ... S es ...)
-        (letrec ([x e] ... [x S] [x es] ...) es es ...)
-        (letrec ([x e] ...) S es ...)
-        (letrec ([x e] ...) e e ... S es ...)
-        (letrec* ([x e] ... [x S] [x es] ...) es es ...)
-        (letrec* ([x e] ...) S es ...)
-        (letrec* ([x e] ...) e e ... S es ...))))
+    (f (side-condition (x_1 ...) (unique? (term (x_1 ...))))
+       (side-condition (x_1 x_2 ... dot x_3) (unique? (term (x_1 x_2 ... x_3))))
+       x)
+    
+    (s seq () sqv sym)
+    (seq (s s ...) (s s ... dot sqv) (s s ... dot sym))
+    (sqv n #t #f)
+    
+    (p (store (sf ...) e))
+    (e (begin e e ...) (begin0 e e ...)
+       (e e ...) (if e e e)
+       (set! x e) (handlers e ... e)
+       x nonproc proc (dw x e e e)
+       unspecified
+       (letrec (side-condition ([x_1 e] ...)
+                               (unique? (term (x_1 ...))))
+         e e ...)
+       (letrec* (side-condition ([x_1 e] ...)
+                                (unique? (term (x_1 ...))))
+                e e ...)
+       (l! x es)
+       (reinit x))
+    (v nonproc proc)
+    (nonproc pp null 'sym sqv (make-cond string))
+    
+    (proc (lambda f e e ...) pproc (throw x e))
+    (pproc aproc proc1 proc2 list dynamic-wind apply values)
+    (proc1 null? pair? car cdr call/cc procedure? condition? raise*)
+    (proc2 cons consi set-car! set-cdr! eqv? call-with-values with-exception-handler)
+    (aproc + - / *)
+    (raise* raise-continuable raise)
+    
+    ; pair pointers, both mutable and immutable
+    (pp ip mp)
+    (ip (variable-prefix ip))
+    (mp (variable-prefix mp))
+    
+    (sym (variable-except dot))
+    
+    (x (side-condition 
+        (name var_none
+              (variable-except 
+               dot                         ; the . in dotted pairs
+               lambda if loc set!          ; core syntax names
+               quote
+               begin begin0
+               
+               null                      ; non-function values
+               unspecified
+               pair closure
+               
+               error                       ; signal an error
+               
+               letrec letrec* l! reinit
+               
+               procedure? condition?
+               cons consi pair? null? car cdr       ; list functions
+               set-car! set-cdr! list
+               + - * /                          ; math functions
+               call/cc throw dw dynamic-wind  ; call/cc functions
+               values call-with-values              ; values functions
+               apply eqv?
+               
+               make-cond
+               with-exception-handler handlers
+               raise-continuable raise))
+        (not (pp? (term var_none)))))
+    
+    (n number)
+    
+    (P (store (sf ...) E*))
+    
+    (E (in-hole F (handlers proc ... E*)) (in-hole F (dw x e E* e)) F)
+    (E* (hole multi) E)
+    (Eo (hole single) E)
+    
+    (F hole (v ... Fo v ...) (if Fo e e) (set! x Fo)  
+       (begin F* e e ...) (begin0 F* e e ...) 
+       (begin0 (values v ...) F* e ...) (begin0 unspecified F* e ...)
+       (call-with-values (lambda () F* e ...) v)
+       (l! x Fo))
+    
+    (F* (hole multi) F)
+    (Fo (hole single) F)
+    
+    ;; all of the one-layer contexts that "demand" their values, 
+    ;; (maybe just "demand" it enough to ensure it is the right # of values)
+    ;; which requires unspecified to blow up.
+    (U (v ... hole v ...) (if hole e e) (set! x hole) (l! x hole)
+       (call-with-values (lambda () hole) v))
+    
+    ;; everything except exception handler bodies
+    (PG (store (sf ...) G))
+    (G (in-hole F (dw x e G e))
+       F)
+    
+    ;; everything except dw
+    (H (in-hole F (handlers proc ... H)) F)
+    
+    (S hole (begin e e ... S es ...) (begin S es ...)
+       (begin0 e e ... S es ...) (begin0 S es ...)
+       (e ... S es ...) (if S es es) (if e S es) (if e e S)
+       (set! x S) (handlers s ... S es ... es) (handlers s ... S)
+       (throw x e) 
+       (lambda f S es ...) (lambda f e e ... S es ...)
+       (letrec ([x e] ... [x S] [x es] ...) es es ...)
+       (letrec ([x e] ...) S es ...)
+       (letrec ([x e] ...) e e ... S es ...)
+       (letrec* ([x e] ... [x S] [x es] ...) es es ...)
+       (letrec* ([x e] ...) S es ...)
+       (letrec* ([x e] ...) e e ... S es ...)))
+  
+  (define (unique? lst)
+    (let ([ht (make-hash-table)])
+      (let loop ([lst lst])
+        (cond
+          [(null? lst) #t]
+          [else
+           (let ([var (car lst)])
+             (cond
+               [(hash-table-get ht var #f) #f]
+               [else
+                (hash-table-put! ht var #t)
+                (loop (cdr lst))]))]))))
 
   (define Basic--syntactic--forms
     (reduction-relation
@@ -202,7 +231,7 @@
           (in-hole P_1 ,(/ (term n_1) (product-of (term (n_2 n_3 ...)))))
           "6/"
           (side-condition (not (member 0 (term (n_2 n_3 ...))))))
-     (--> (in-hole P_1 (/ n n ... 0 n ...))
+     (--> (in-hole P_1 (/ n_1 n_2 ... 0 n_3 ...))
           (in-hole P_1 (raise (make-cond "divison by zero")))
           "6/0")
      (--> (in-hole P_1 (/))
@@ -238,10 +267,10 @@
           (side-condition (or (not (condition? (term v_1)))
                               (not (condition? (term v_2))))))
      
-     (--> (in-hole P_1 (eqv? (make-cond string) (make-cond string)))
+     (--> (in-hole P_1 (eqv? (make-cond string_1) (make-cond string_2)))
           (in-hole P_1 #t)
           "6eqct")
-     (--> (in-hole P_1 (eqv? (make-cond string) (make-cond string)))
+     (--> (in-hole P_1 (eqv? (make-cond string_1) (make-cond string_2)))
           (in-hole P_1 #f)
           "6eqcf")))
   
@@ -381,14 +410,14 @@
      (--> (in-hole P_1 (procedure? nonproc)) (in-hole P_1 #f) "6procf")
      
      ;; mu-lambda too few arguments case
-     (--> (in-hole P_1 ((lambda (x_1 ...) e e ...) v_1 ...))
+     (--> (in-hole P_1 ((lambda (x_1 ...) e_1 e_2 ...) v_1 ...))
           (in-hole P_1 (raise (make-cond "arity mismatch")))
           "6arity"
           (side-condition
            (not (= (length (term (x_1 ...)))
                    (length (term (v_1 ...)))))))
      
-     (--> (in-hole P_1 ((lambda (x_1 x_2 ... dot x) e e ...) v_1 ...))
+     (--> (in-hole P_1 ((lambda (x_1 x_2 ... dot x) e_1 e_2 ...) v_1 ...))
           (in-hole P_1 (raise (make-cond "arity mismatch")))
           "6μarity"
           (side-condition
@@ -417,12 +446,12 @@
           "6applyf")
      
      (--> (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole E_1 (apply proc_1 v_1 ... pp_1)))
-          (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole  E_1 (apply proc_1 v_1 ... v_2 v_3)))
+          (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole E_1 (apply proc_1 v_1 ... v_2 v_3)))
           "6applyc"
           (side-condition (not (term (circular? (pp_1 v_3 (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...)))))))
      
      (--> (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole E_1 (apply proc_1 v_1 ... pp_1)))
-          (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole  E_1 (raise (make-cond "apply called on circular list"))))
+          (store (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...) (in-hole E_1 (raise (make-cond "apply called on circular list"))))
           "6applyce"
           (side-condition (term (circular? (pp_1 v_3 (sf_1 ... (pp_1 (cons v_2 v_3)) sf_2 ...))))))
      
@@ -525,7 +554,7 @@
           "6dwarity"
           (side-condition (not (= (length (term (v_1 ...))) 3))))
      
-     (--> (in-hole P_1 (dw x e (values v_1 ...) e))
+     (--> (in-hole P_1 (dw x e_1 (values v_1 ...) e_2))
           (in-hole P_1 (values v_1 ...))
           "6dwdone")
      
@@ -718,7 +747,7 @@
   (define Underspecification
     (reduction-relation
      lang
-     (--> (in-hole P (eqv? proc proc))
+     (--> (in-hole P (eqv? proc_1 proc_2))
           (unknown "equivalence of procedures")
           "6ueqv")
      (--> (in-named-hole single P (values v_1 ...))
@@ -738,7 +767,7 @@
      (--> (in-hole P_1 (handlers v ... unspecified))
           (in-hole P_1 unspecified)
           "6uhandlers")
-     (--> (in-hole P_1 (dw x e unspecified e))
+     (--> (in-hole P_1 (dw x e_1 unspecified e_2))
           (in-hole P_1 unspecified)
           "6udw")
      (--> (in-hole P_1 (begin0 (values v_1 ...) unspecified e_1 ...))
@@ -828,7 +857,15 @@
     [(variable_1 e (lambda variable_1 e_2 e_3 ...))
      (lambda variable_1 e_2 e_3 ...)]
     
-    ;; next 3 cases: we know no capture can occur, so we just recur
+    ;; when the letrec binds the variable, stop stubstituting
+    [(variable_1 e (letrec ([variable_2 e_2] ... [variable_1 e_1] [variable_3 e_3] ...) e_4 e_5 ...))
+     (letrec ([variable_2 e_2] ... [variable_1 e_1] [variable_3 e_3] ...) e_4 e_5 ...)]
+    
+    ;; when the letrec* binds the variable, stop stubstituting
+    [(variable_1 e (letrec* ([variable_2 e_2] ... [variable_1 e_1] [variable_3 e_3] ...) e_4 e_5 ...))
+     (letrec ([variable_2 e_2] ... [variable_1 e_1] [variable_3 e_3] ...) e_4 e_5 ...)]
+    
+    ;; next 5 cases: we know no capture can occur, so we just recur
     [(variable_1 e_1 (lambda (variable_2 ...) e_2 e_3 ...))
      (lambda (variable_2 ...) 
        (r6rs-subst-one (variable_1 e_1 e_2))
@@ -848,6 +885,19 @@
      (side-condition (equal? (variable-not-in (term e_1) (term variable_2)) 
                              (term variable_2)))]
     
+    [(variable_1 e_1 (letrec ([variable_2 e_2] ...) e_3 e_4 ...))
+     (letrec ([variable_2 (r6rs-subst-one (variable_1 e_1 e_2))] ...)
+       (r6rs-subst-one (variable_1 e_1 e_3)) 
+       (r6rs-subst-one (variable_1 e_1 e_4)) ...)
+     (side-condition (andmap (λ (x) (equal? (variable-not-in (term e_1) x) x))
+                             (term (variable_2 ...))))]
+    [(variable_1 e_1 (letrec* ([variable_2 e_2] ...) e_3 e_4 ...))
+     (letrec* ([variable_2 (r6rs-subst-one (variable_1 e_1 e_2))] ...)
+       (r6rs-subst-one (variable_1 e_1 e_3)) 
+       (r6rs-subst-one (variable_1 e_1 e_4)) ...)
+     (side-condition (andmap (λ (x) (equal? (variable-not-in (term e_1) x) x))
+                             (term (variable_2 ...))))]
+    
     ;; capture avoiding cases
     [(variable_1 e_1 (lambda (variable_2 ... dot variable_3) e_2 e_3 ...))
      ,(term-let ([(variable_new ... variable_new_dot) (variables-not-in (term (variable_1 e_1 e_2 e_3 ...))
@@ -873,6 +923,19 @@
                 (r6rs-subst-one (variable_1 e_1 (r6rs-subst-one (variable_2 variable_new e_2))))
                 (r6rs-subst-one (variable_1 e_1 (r6rs-subst-one (variable_2 variable_new e_3)))) ...)))]
     
+    [(variable_1 e_1 (letrec ([variable_2 e_2] ...) e_3 e_4 ...))
+     ,(term-let ([(variable_new ...) (variables-not-in (term (variable_1 e_1 e_2 ... e_3 e_4 ...))
+                                                       (term (variable_2 ...)))])
+        (term (letrec ([variable_new (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_2))))] ...)
+                (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_3))))
+                (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_4)))) ...)))]
+    [(variable_1 e_1 (letrec* ([variable_2 e_2] ...) e_3 e_4 ...))
+     ,(term-let ([(variable_new ...) (variables-not-in (term (variable_1 e_1 e_2 ... e_3 e_4 ...))
+                                                       (term (variable_2 ...)))])
+        (term (letrec* ([variable_new (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_2))))] ...)
+                (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_3))))
+                (r6rs-subst-one (variable_1 e_1 (r6rs-subst-many ((variable_2 variable_new) ... e_4)))) ...)))]
+    
     ;; last two cases cover all other expressions -- they don't have any variables, 
     ;; so we don't care about their structure. 
     [(variable_1 e_1 (any_1 ...)) ((r6rs-subst-one (variable_1 e_1 any_1)) ...)]
diff --git b/model/show-examples.scm a/model/show-examples.scm
index bb214c5..b06282e 100644
--- b/model/show-examples.scm
+++ a/model/show-examples.scm
@@ -1,7 +1,7 @@
 (module show-examples mzscheme
   
-  (require (planet "gui.ss" ("robby" "redex.plt" 3 10))
-           (planet "reduction-semantics.ss" ("robby" "redex.plt" 3 10))
+  (require (planet "gui.ss" ("robby" "redex.plt" 4))
+           (planet "reduction-semantics.ss" ("robby" "redex.plt" 4))
            "r6rs.scm")
   (provide trace trace-expression
            step step-expression)
@@ -38,32 +38,26 @@
   ;; example uses of the above functions
   ;; if any of the terms in the graph don't 
   ;;    match p*, they will be colored red
-  ;; #; comments out an entire sexpression.
   ;; 
   
-  #;
-  (show '(store () (((lambda (x y) (set! x (+ x y)) x) 2 3))))
+  (trace '(store () ((lambda (x y) (set! x (+ x y)) x) 2 3)))
 
   ;; an infinite, tail-recursive loop
-  #;
-  (show-expression '((lambda (x) ((call/cc call/cc) x)) (call/cc call/cc)))
+  (trace-expression '((lambda (x) ((call/cc call/cc) x)) (call/cc call/cc)))
 
   ;; two infinite loops, one in left-to-right and one in right-to-left evaluation order
   ;; one goes into a non-tail infinite loop, the other's reduction graph has a cycle
-  #;
   (step '(store () 
            ((call/cc call/cc) 
             (call/cc call/cc))))
           
   
   ;; demonstrates sharing
-  #;
-  (show-expression
+  (trace-expression
    '((lambda (c)
        ((lambda (x y) 
           (set-car! x 3)
           (car y))
         c c))
-     (cons 1 2)))
-  
-  (step  '(store () ((lambda (sx first-time?) ((lambda (k) (if first-time? (begin (set! first-time? #f) (with-exception-handler (lambda (x) (k values)) (lambda () (dynamic-wind + (lambda () (raise-continuable 1)) (lambda () (set! sx (+ sx 1))))))) sx)) (call/cc values))) 1 #t))))
+     (cons 1 2))))
+
diff --git b/model/test.scm a/model/test.scm
index b3fe148..bfbf0d2 100644
--- b/model/test.scm
+++ a/model/test.scm
@@ -1,5 +1,5 @@
 (module test mzscheme
-  (require (planet "reduction-semantics.ss" ("robby" "redex.plt" 3 10))
+  (require (planet "reduction-semantics.ss" ("robby" "redex.plt" 4))
            (lib "etc.ss")
            (lib "contract.ss"))
   
